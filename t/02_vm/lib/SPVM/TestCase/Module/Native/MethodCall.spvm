class TestCase::Module::Native::MethodCall {
  use Native::MethodCall;
  use Fn;
  use TestCase::Point_3b;
  use TestCase::Point_3s;
  use TestCase::Point_3i;
  use TestCase::Point_3l;
  use TestCase::Point_3f;
  use TestCase::Point_3d;
  
  static method call : int () {
    
    {
      my $class_method_call = Native::MethodCall->new_class_method("TestCase::Module::Native::MethodCall", "add_byte");
      
      {
        my $ret = $class_method_call->call([(object)(byte)Fn->BYTE_MIN, (byte)1]);
        
        unless ($ret is_type Byte) {
          return 0;
        }
        
        unless ((byte)$ret == Fn->BYTE_MIN + 1) {
          return 0;
        }
      }
    }
    
    {
      my $class_method_call = Native::MethodCall->new_class_method("TestCase::Module::Native::MethodCall", "add_short");
      
      {
        my $ret = $class_method_call->call([(object)(short)Fn->SHORT_MIN, (short)1]);
        
        unless ($ret is_type Short) {
          return 0;
        }
        
        unless ((short)$ret ==Fn->SHORT_MIN + 1) {
          return 0;
        }
      }
    }
    
    {
      my $class_method_call = Native::MethodCall->new_class_method("TestCase::Module::Native::MethodCall", "add_int");
      
      {
        my $ret = $class_method_call->call([(object)(int)Fn->INT_MIN, (int)1]);
        
        unless ($ret is_type Int) {
          return 0;
        }
        
        unless ((int)$ret == Fn->INT_MIN + 1) {
          return 0;
        }
      }
    }
    
    {
      my $class_method_call = Native::MethodCall->new_class_method("TestCase::Module::Native::MethodCall", "add_long");
      
      {
        my $ret = $class_method_call->call([(object)(long)Fn->LONG_MIN, (long)1]);
        
        unless ($ret is_type Long) {
          return 0;
        }
        
        unless ((long)$ret == Fn->LONG_MIN + 1) {
          return 0;
        }
      }
    }
    
    {
      my $class_method_call = Native::MethodCall->new_class_method("TestCase::Module::Native::MethodCall", "add_float");
      
      {
        my $ret = $class_method_call->call([(object)(float)Fn->FLOAT_MIN, (float)1]);
        
        unless ($ret is_type Float) {
          return 0;
        }
        
        unless ((float)$ret == Fn->FLOAT_MIN + 1) {
          return 0;
        }
      }
    }
    
    {
      my $class_method_call = Native::MethodCall->new_class_method("TestCase::Module::Native::MethodCall", "add_double");
      
      {
        my $ret = $class_method_call->call([(object)(double)Fn->DOUBLE_MIN, (double)1]);
        
        unless ($ret is_type Double) {
          return 0;
        }
        
        unless ((double)$ret == Fn->DOUBLE_MIN + 1) {
          return 0;
        }
      }
    }
    
    {
      my $class_method_call = Native::MethodCall->new_class_method("TestCase::Module::Native::MethodCall", "add_mulnum_byte");
      
      {
        my $ret = (byte[])$class_method_call->call([(object)[(byte)Fn->BYTE_MIN, 2, 3], [(byte)1, 4, 5]]);
        
        unless ($ret is_type byte[]) {
          return 0;
        }
        
        unless ($ret->[0] == Fn->BYTE_MIN + 1) {
          return 0;
        }
        
        unless ($ret->[1] == 6) {
          return 0;
        }
        
        unless ($ret->[2] == 8) {
          return 0;
        }
        
      }
    }
    
    return 1;
  }
  
  static method add_byte : byte ($arg0 : byte, $arg1 : byte) {
    
    my $ret = (byte)($arg0 + $arg1);
    
    return $ret;
  }
  
  static method add_short : short ($arg0 : short, $arg1 : short) {
    
    my $ret = (short)($arg0 + $arg1);
    
    return $ret;
  }
  
  static method add_int : int ($arg0 : int, $arg1 : int) {
    
    my $ret = (int)($arg0 + $arg1);
    
    return $ret;
  }
  
  static method add_long : long ($arg0 : long, $arg1 : long) {
    
    my $ret = (long)($arg0 + $arg1);
    
    return $ret;
  }
  
  static method add_float : float ($arg0 : float, $arg1 : float) {
    
    my $ret = (float)($arg0 + $arg1);
    
    return $ret;
  }
  
  static method add_double : double ($arg0 : double, $arg1 : double) {
    
    my $ret = (double)($arg0 + $arg1);
    
    return $ret;
  }
  
  static method add_mulnum_byte : TestCase::Point_3b ($arg0 : TestCase::Point_3b, $arg1 : TestCase::Point_3b) {
    
    my $ret : TestCase::Point_3b;
    $ret->{x} = (byte)($arg0->{x} + $arg1->{x});
    $ret->{y} = (byte)($arg0->{y} + $arg1->{y});
    $ret->{z} = (byte)($arg0->{z} + $arg1->{z});
    
    return $ret;
  }
  
}
