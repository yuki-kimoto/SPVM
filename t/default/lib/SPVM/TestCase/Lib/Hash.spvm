class TestCase::Lib::Hash {
  use Int;
  use Hash;
  use Comparator;
  use List;
  use Fn;
  use Fn;
  use Comparator;
  use Comparator::Int;

  static method new : int () {
    # undef
    {
      my $hash = Hash->new(undef);
      my $keys = $hash->keys;
      unless (@$keys == 0) {
        return 0;
      }
    }
    
    # Empty array
    {
      my $hash = Hash->new({});
      my $keys = $hash->keys;
      unless (@$keys == 0) {
        return 0;
      }
    }
    
    # int values
    {
      my $hash = Hash->new({foo => 1, bar => 3L});
      my $keys = $hash->keys;
      unless (@$keys == 2) {
        return 0;
      }
      
      {
        my $foo = (Int)$hash->get("foo");
        unless ($foo->value == 1) {
          return 0;
        }
        my $bar = (Long)$hash->get("bar");
        unless ($bar->value == 3) {
          return 0;
        }
      }

      {
        my $foo = (int)$hash->get("foo");
        unless ($foo == 1) {
          return 0;
        }
      }
    }

    # string values
    {
      my $hash = Hash->new({foo => "4px", bar => "5px"});
      my $keys = $hash->keys;
      unless (@$keys == 2) {
        return 0;
      }
      
      {
        my $foo = (string)$hash->get("foo");
        unless ($foo && $foo eq "4px") {
          return 0;
        }
        my $bar = (string)$hash->get("bar");
        unless ($bar && $bar eq "5px") {
          return 0;
        }
      }
    }

    # string and int values
    {
      my $hash = Hash->new({foo => "4px", bar => 3});
      my $keys = $hash->keys;
      unless (@$keys == 2) {
        return 0;
      }
      
      {
        my $foo = $hash->get_string("foo");
        unless ($foo && $foo eq "4px") {
          return 0;
        }
        my $bar = $hash->get_int("bar");
        unless ($bar && $bar == 3) {
          return 0;
        }
      }
    }
    
    # Exception
    {
      # odd number array
      {
        eval { Hash->new([(object)foo => "4px", "bar"]); };
        unless ($@) {
          return 0;
        }
      }
      
      # Key must be string
      {
        eval { Hash->new({1 => "4px"}); };
        unless ($@) {
          return 0;
        }
      }
      
    }
    
    $@ = undef;
    
    return 1;
  }

  static method set_get_numeric : int () {

    my $hash = Hash->new({});

    # set_byte, get_byte
    {
      $hash->set_byte(foo => Fn->INT8_MAX());
      unless ($hash->get("foo") isa Byte) {
        return 0;
      }
      my $value = $hash->get_byte("foo");

      unless ($value == Fn->INT8_MAX()) {
        return 0;
      }
    }

    # set_short, get_short
    {
      $hash->set_short(foo => Fn->INT16_MAX());
      unless ($hash->get("foo") isa Short) {
        return 0;
      }
      my $value = $hash->get_short("foo");

      unless ($value == Fn->INT16_MAX()) {
        return 0;
      }
    }

    # set_int, get_int
    {
      $hash->set_int(foo => Fn->INT32_MAX());
      unless ($hash->get("foo") isa Int) {
        return 0;
      }
      my $value = $hash->get_int("foo");

      unless ($value == Fn->INT32_MAX()) {
        return 0;
      }
    }

    # set_string, get_string
    {
      my $str = "bar";
      $hash->set_string(foo => $str);
      unless ($hash->get_string("foo") isa string) {
        return 0;
      }
      my $value = $hash->get_string("foo");

      unless ($value == $str) {
        return 0;
      }
    }

    # set_long, get_long
    {
      $hash->set_long(foo => Fn->INT64_MAX());
      unless ($hash->get("foo") isa Long) {
        return 0;
      }
      my $value = $hash->get_long("foo");

      unless ($value == Fn->INT64_MAX()) {
        return 0;
      }
    }

    # set_float, get_float
    {
      $hash->set_float(foo => Fn->FLT_MIN());
      unless ($hash->get("foo") isa Float) {
        return 0;
      }
      my $value = $hash->get_float("foo");

      unless ($value == Fn->FLT_MIN()) {
        return 0;
      }
    }

    # set_double, get_double
    {
      $hash->set_double(foo => Fn->DBL_MIN());
      unless ($hash->get("foo") isa Double) {
        return 0;
      }
      my $value = $hash->get_double("foo");

      unless ($value == Fn->DBL_MIN()) {
        return 0;
      }
    }

    return 1;
  }

  static method murmur_hash : int () {
    my $seed = 123456789;
    # Testcase is created from https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/libsupc++/hash_bytes.cc#L72-L112
    # Change size_t to uint32_t to use 32bit integer.
    # Compile the program by the following command:
    # g++ -std=c++2a -D__SIZEOF_SIZE_T__=4 hash_bytes.cc
    my $strings = ["a", "<>", "ABC", "1234", "asdfg", "zxcvbn", "1qazxsw", "3edcvfr4", "1234567890-=\\][poiuytrewqasdfghjkl;'"];
    my $hashes = [846967266L, 200612280L, 4178773334L, 1870759112L, 61159236L, 623182920L, 1738266155L, 123403562L, 4243681504L];
    for (my $i = 0; $i < @$strings; ++$i) {
      unless (Hash->_murmur_hash($strings->[$i], $seed) == $hashes->[$i]) {
        return 0;
      }
    }
    return 1;
  }

  static method set : int () {
    my $keys = ["alice", "bob", "carol", "1234567890-="];
    my $vals = [Int->new(1), Int->new(2), undef, Int->new(3)];
    my $hash = Hash->new({});
    for (my $i = 0; $i < @$keys; ++$i) {
      $hash->set($keys->[$i], $vals->[$i]);
    }
    unless ($hash->count == @$keys) {
      return 0;
    }
    for (my $i = 0; $i < @$keys; ++$i) {
      unless ($hash->get($keys->[$i]) == $vals->[$i]) {
        return 0;
      }
    }
    return 1;
  }

  static method set_do_not_refer_caller_key : int () {
    my $hash = Hash->new({});
    my $key = "a";
    $hash->set($key, Int->new(1));
    $key = "b";
    unless ($hash->exists("a")) {
      return 0;
    }
    unless ($hash->exists("b") == 0) {
      return 0;
    }
    return 1;
  }

  static method get : int () {
    my $hash = Hash->new({});
    $hash->set_int("a" => 1);
    $hash->set("b" => undef);
    $hash->set("c" => "str");

    unless (((Int)($hash->get("a")))->value == 1) {
      return 0;
    }
    unless ($hash->get("b") == undef) {
      return 0;
    }
    unless (((string)$hash->get("c")) eq "str") {
      return 0;
    }
    unless ($hash->get("no_key") == undef) {
      return 0;
    }
    return 1;
  }

  static method exists : int () {
    my $keys = ["alice", "bob"];
    my $vals = [Int->new(1), Int->new(2)];
    my $hash = Hash->new({});
    for (my $i = 0; $i < @$keys; ++$i) {
      $hash->set($keys->[$i], $vals->[$i]);
    }
    for (my $i = 0; $i < @$keys; ++$i) {
      unless ($hash->exists($keys->[$i])) {
        return 0;
      }
    }
    unless ($hash->exists("carol") == 0) {
      return 0;
    }
    return 1;
  }

  static method delete_with_no_hash_collision : int () {
    my $hash = Hash->new({});
    $hash->set("alice", Int->new(1));
    $hash->set("bob", Int->new(2));
    unless (((Int)($hash->delete("alice")))->value == 1) {
      return 0;
    }
    unless ($hash->exists("alice") == 0) {
      return 0;
    }
    unless ($hash->count == 1) {
      return 0;
    }
    unless ($hash->delete("alice") == undef) {
      return 0;
    }
    unless ($hash->delete("carol") == undef) {
      return 0;
    }
    unless ($hash->count == 1) {
      return 0;
    }
    unless ($hash->exists("bob") == 1) {
      return 0;
    }
    return 1;
  }

  static method delete_with_hash_collision : int () {
    my $hash = Hash->new({});
    $hash->set("alice", Int->new(1));
    $hash->set("bob", Int->new(2));
    unless (((Int)$hash->delete("alice"))->value == 1) {
      return 0;
    }
    unless ($hash->exists("alice") == 0) {
      return 0;
    }
    unless ($hash->count == 1) {
      return 0;
    }
    unless ($hash->delete("alice") == undef) {
      return 0;
    }
    unless ($hash->count == 1) {
      return 0;
    }

    unless ($hash->exists("bob") == 1) {
      return 0;
    }
    unless (((Int)($hash->delete("bob")))->value == 2) {
      return 0;
    }
    unless ($hash->count == 0) {
      return 0;
    }
    unless ($hash->exists("bob") == 0) {
      return 0;
    }
    return 1;
  }

  static method rehash : int () {
    my $initial_capacity = 16;
    my $hash = Hash->new({});
    for (my $i = 0; $i < 14; ++$i) {
      my $key = "key" . $i;
      $hash->set_int($key => $i);
    }

    unless ($hash->_bucket_count == $initial_capacity * 2) {
      return 0;
    }
    unless (@{$hash->_entries} == $initial_capacity * 2) {
      return 0;
    }

    unless ($hash->get_int("key12") == 12) {
      return 0;
    }

    return 1;
  }

  static method keys : int () {
    my $hash = Hash->new({});
    my $key0 = "a";
    my $key1 = "b";
    
    my $key2 = (mutable string)new_string_len(1);
    $key2->[0] = 'c';

    $hash->set_int($key0 => 1);
    $hash->set_int($key1 => 2);
    $hash->set_int($key2 => 3);

    my $keys = $hash->keys;

    unless (@$keys == 3) {
      return 0;
    }

    Fn->sort_object($keys, 0, scalar @$keys, method : int ($a : object, $b : object) {
      return (string)$a cmp (string)$b;
    });

    unless ($keys->[0] == $key0) {
      return 0;
    }

    unless ($keys->[1] == $key1) {
      return 0;
    }

    unless ($keys->[2] eq $key2) {
      return 0;
    }
    unless ($keys->[2] != $key2) {
      return 0;
    }

    return 1;
  }

  static method values : int () {
    my $hash = Hash->new({});
    my $key0 = "a";
    my $key1 = "b";
    my $key2 = "c";

    $hash->set_int($key0 => 1);
    $hash->set_int($key1 => 2);
    $hash->set_int($key2 => 3);

    my $values = $hash->values;

    unless (@$values == 3) {
      return 0;
    }

    my $int_values = new int[3];
    $int_values->[0] = (int)$values->[0];
    $int_values->[1] = (int)$values->[1];
    $int_values->[2] = (int)$values->[2];

    Fn->sort_int($int_values, 0, scalar @$int_values, method : int ($a : int, $b : int) {
      return $a <=> $b;
    });

    unless ($int_values->[0] == 1) {
      return 0;
    }

    unless ($int_values->[1] == 2) {
      return 0;
    }

    unless ($int_values->[2] == 3) {
      return 0;
    }

    return 1;
  }

  static method copy : int () {
    my $hash = Hash->new({});
    for (my $i = 0; $i < 3; ++$i) {
      $hash->set("key$i", $i);
    }
    my $copied = $hash->copy;
    for (my $i = 0; $i < 3; ++$i) {
      unless (((Int)$copied->get("key$i"))->value == $i) {
        return 0;
      }
    }
    $copied->set("extra_key", 123);
    if ($hash->exists("extra_keys")) {
      return 0;
    }
    unless ($copied->exists("extra_key")) {
      return 0;
    }
    return 1;
  }
}
