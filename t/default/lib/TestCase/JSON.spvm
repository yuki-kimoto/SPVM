package TestCase::JSON {
  use SPVM::JSON;
  use SPVM::List;
  use SPVM::Int;
  use SPVM::Double;
  use SPVM::JSON::Bool;

  our $DEFAULT_JSON : SPVM::JSON;

  BEGIN {
    $DEFAULT_JSON = SPVM::JSON->new;
    $DEFAULT_JSON->{canonical} = 1;
  }

  sub _validate : int ($json : SPVM::JSON, $input : string[], $expected : string[]) {
    for (my $i = 0; $i < @$input; $i++) {
      my $decoded = $json->decode($input->[$i]);
      my $actual = $json->encode($decoded);
      unless ($actual eq $expected->[$i]) {
        warn("input: " . $input->[$i] . "\nexpected: " . $expected->[$i] . "\nactual: $actual");
        return 0;
      }
    }
    return 1;
  }

  sub test_empty : int () {
    my $input = [
      # empty
      "",
      # spaces
      " ", "\n", "\t", "\r",
      # multiple spaces
      " \r\n\t  \r\r\t\t\n "
    ];
    my $expected = ["", "", "", "", "", ""];
    return _validate($DEFAULT_JSON, $input, $expected);
  }

  sub test_flat_hash : int () {
    my $json_texts = ["{}", "{\"digit\":42}", "{\"string\":\"vstr\"}", "{\"double\":0.123}", "{\"bool_true\":true}", "{\"bool_false\":false}", "{\"A\":0.1,\"ABC\":false,\"a\":1,\"qwerty\":\"asdfg\"}"];
    return _validate($DEFAULT_JSON, $json_texts, $json_texts);
  }

  sub test_flat_list : int () {
    my $json_texts = ["[]", "[1,2,3]", "[\"abc\",\"123\"]", "[123,\"abc\",0,\"123abc\",3.1415]"];
    return _validate($DEFAULT_JSON, $json_texts, $json_texts);
  }

  sub test_digits_int : int () {
    my $json_texts = ["[0,1,-1]"];
    return _validate($DEFAULT_JSON, $json_texts, $json_texts);
  }

  sub test_digits_long : int () {
    my $json_texts = ["[100000000000,-100000000000]"];
    return _validate($DEFAULT_JSON, $json_texts, $json_texts);
  }

  sub test_digits_double : int () {
    my $json_texts = ["[0.123,-0.123,3.14,-3.14,123.987,-123.987,1.23456e+1,1.23456e-1,1.23456e+08,1.23456e-08,1.23456e+008,1.23456e-008,1.23456e+018,1.23456e-018,9.9e-100,9.9e+300,-1.23e+123]"];
    return _validate($DEFAULT_JSON, $json_texts, $json_texts);
  }

  sub test_root_is_primitive : int () {
    my $json_texts = ["\"abc\"", "123", "true"];
    return _validate($DEFAULT_JSON, $json_texts, $json_texts);
  }

  sub test_nest_object : int () {
    my $json_texts = [
      "{\"A\":{\"B\":1,\"C\":{\"D\":0.1,\"E\":true,\"F\":\"str\",\"G\":[\"elem\",\"ents\",{\"key\":\"value\"}]}},\"end\":\"eof\"}"
    ];
    unless (_validate($DEFAULT_JSON, $json_texts, $json_texts)) {
      return 0;
    }
    return 1;
  }

  sub test_spaces : int () {
    my $inputs = [
      # Root type is "hash"
      " { \"key\" \n\t: 123\t,\n\t\t\"list\" :\n[\t1\t,\r2\t,\t3\n]}\r\r",
      # Root type is "list"
      " [ 1, 3.14\n, true \t , \"a\" ] " # primitives: Int, Double, Bool, string
    ];
    my $outputs = [
      "{\"key\":123,\"list\":[1,2,3]}",
      "[1,3.14,true,\"a\"]"
    ];
    return _validate($DEFAULT_JSON, $inputs, $outputs);
  }

  sub test_format_name_separator : int () {
    my $hash = SPVM::Hash->new_with_array([(object) "key", "value"]);
    my $json = SPVM::JSON->new;
    $json->{space_before} = 0;
    $json->{space_after} = 0;
    unless ($json->encode($hash) eq "{\"key\":\"value\"}") {
      return 0;
    }
    $json->{space_before} = 1;
    $json->{space_after} = 0;
    unless ($json->encode($hash) eq "{\"key\" :\"value\"}") {
      return 0;
    }
    $json->{space_before} = 0;
    $json->{space_after} = 1;
    unless ($json->encode($hash) eq "{\"key\": \"value\"}") {
      return 0;
    }
    $json->{space_before} = 1;
    $json->{space_after} = 1;
    unless ($json->encode($hash) eq "{\"key\" : \"value\"}") {
      return 0;
    }
    return 1;
  }

  sub test_format_indent : int () {
    my $hash = SPVM::Hash->new_with_array([(object) "a", "v1", "b", "v2", "c", SPVM::List->new_with_array([(object) "x", "y"])]);
    my $json = SPVM::JSON->new;
    $json->{indent} = 1;
    $json->{indent_length} = 2;
    $json->{canonical} = 1;
    my $expected = "{\n  \"a\":\"v1\",\n  \"b\":\"v2\",\n  \"c\":[\n    \"x\",\n    \"y\"\n  ]\n}";
    my $actual = $json->encode($hash);
    unless ($expected eq $actual) {
      warn ("expected:\n$expected\nactual:\n$actual");
      return 0;
    }
    return 1;
  }

  sub test_format_pretty : int () {
    my $hash = SPVM::Hash->new_with_array([(object) "a", "v1", "b", "v2", "c", SPVM::List->new_with_array([(object) "x", "y"])]);
    my $json = SPVM::JSON->new;
    $json->{canonical} = 1;
    $json->pretty(1);
    my $expected = "{\n   \"a\" : \"v1\",\n   \"b\" : \"v2\",\n   \"c\" : [\n      \"x\",\n      \"y\"\n   ]\n}";
    my $actual = $json->encode($hash);
    unless ($expected eq $actual) {
      warn ("expected:\n$expected\nactual:\n$actual");
      return 0;
    }
    $json->pretty(0);
    $expected = "{\"a\":\"v1\",\"b\":\"v2\",\"c\":[\"x\",\"y\"]}";
    $actual = $json->encode($hash);
    unless ($expected eq $actual) {
      warn ("expected:\n$expected\nactual:\n$actual");
      return 0;
    }
    return 1;
  }
}
