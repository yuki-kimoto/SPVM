lib/SPVM/Global.pm:      $env->destroy_class_vars($stack);
lib/SPVM/Global.pm:    my $builder_stack = $builder_env->new_stack;
lib/SPVM/Global.pm:      $builder_env->set_command_info_program_name($builder_stack, $0);
lib/SPVM/Global.pm:      $builder_env->set_command_info_argv($builder_stack, \@ARGV);
lib/SPVM/Global.pm:      $builder_env->set_command_info_base_time($builder_stack, $base_time);
lib/SPVM/Global.pm:    my $stack = $env->new_stack;
lib/SPVM/Global.pm:  my $compiler = $env->runtime->get_compiler;
lib/SPVM/Hash.c:  const char* buf = env->get_chars(env, stack, object);
lib/SPVM/Hash.c:  uint32_t len = env->length(env, stack, object);
lib/SPVM/Hash.c:  char* seed = (char*)env->get_chars(env, stack, obj_seed);
lib/SPVM/Hash.c:  int32_t seed_length = env->length(env, stack, obj_seed);
lib/SPVM/Hash.c:  const char* buf = env->get_chars(env, stack, object);
lib/SPVM/Hash.c:  uint32_t len = env->length(env, stack, object);
lib/SPVM/Hash.c:  const char* seed = env->get_chars(env, stack, obj_seed);
lib/SPVM/Builder/Exe.pm:void* class_basic_type = env->api->runtime->get_basic_type_by_name(env->runtime, class_name);
lib/SPVM/Builder/Exe.pm:void* method = env->api->basic_type->get_method_by_name(env->runtime, class_basic_type, method_name);
lib/SPVM/Builder/Exe.pm:env->api->method->set_precompile_address(env->runtime, method, precompile_address);
lib/SPVM/Builder/Exe.pm:  void* class_basic_type = env->api->runtime->get_basic_type_by_name(env->runtime, class_name);
lib/SPVM/Builder/Exe.pm:  void* method = env->api->basic_type->get_method_by_name(env->runtime, class_basic_type, method_name);
lib/SPVM/Builder/Exe.pm:  env->api->method->set_native_address(env->runtime, method, native_address);
lib/SPVM/Builder/Exe.pm:  env->runtime = runtime;
lib/SPVM/Builder/Exe.pm:  FILE* spvm_stderr = env->api->runtime->get_spvm_stderr(env->runtime);
lib/SPVM/Builder/Exe.pm:  SPVM_VALUE* stack = env->new_stack(env);
lib/SPVM/Builder/Exe.pm:    int32_t mortal_stack_top = env->enter_scope(env, stack);
lib/SPVM/Builder/Exe.pm:    void* obj_program_name = env->new_string(env, stack, command_args[0], strlen(command_args[0]));
lib/SPVM/Builder/Exe.pm:    void* obj_argv = env->new_string_array(env, stack, command_args_length - 1);
lib/SPVM/Builder/Exe.pm:      void* obj_arg = env->new_string(env, stack, command_args[arg_index], strlen(command_args[arg_index]));
lib/SPVM/Builder/Exe.pm:      env->set_elem_object(env, stack, obj_argv, arg_index - 1, obj_arg);
lib/SPVM/Builder/Exe.pm:      error_id = env->set_command_info_program_name(env, stack, obj_program_name);
lib/SPVM/Builder/Exe.pm:        env->die(env, stack, env->get_chars(env, stack, env->get_exception(env, stack)), __func__, __FILE__, __LINE__);
lib/SPVM/Builder/Exe.pm:        error_id = env->set_command_info_argv(env, stack, obj_argv);
lib/SPVM/Builder/Exe.pm:          env->die(env, stack, env->get_chars(env, stack, env->get_exception(env, stack)), __func__, __FILE__, __LINE__);
lib/SPVM/Builder/Exe.pm:          error_id = env->set_command_info_base_time(env, stack, base_time);
lib/SPVM/Builder/Exe.pm:            env->die(env, stack, env->get_chars(env, stack, env->get_exception(env, stack)), __func__, __FILE__, __LINE__);
lib/SPVM/Builder/Exe.pm:    env->leave_scope(env, stack, mortal_stack_top);
lib/SPVM/Builder/Exe.pm:    error_id = env->check_bootstrap_method(env, stack, class_name);
lib/SPVM/Builder/Exe.pm:      env->die(env, stack, env->get_chars(env, stack, env->get_exception(env, stack)), __func__, __FILE__, __LINE__);
lib/SPVM/Builder/Exe.pm:      error_id = env->call_init_methods(env, stack);
lib/SPVM/Builder/Exe.pm:        void* class_basic_type = env->api->runtime->get_basic_type_by_name(env->runtime, class_name);
lib/SPVM/Builder/Exe.pm:        void* method = env->api->basic_type->get_method_by_name(env->runtime, class_basic_type, "main");
lib/SPVM/Builder/Exe.pm:        error_id = env->call_method(env, stack, method, args_width);
lib/SPVM/Builder/Exe.pm:          env->die(env, stack, env->get_chars(env, stack, env->get_exception(env, stack)), __func__, __FILE__, __LINE__);
lib/SPVM/Builder/Exe.pm:    env->print_stderr(env, stack, env->get_exception(env, stack));
lib/SPVM/Builder/Exe.pm:  env->destroy_class_vars(env, stack);
lib/SPVM/Builder/Exe.pm:  env->free_stack(env, stack);
lib/SPVM/Builder/Exe.pm:  env->free_env(env);
lib/SPVM/Builder/Exe.pm:    $source_class_file .= qq|    env->api->compiler->add_class_file(compiler, "$class_name");\n|;
lib/SPVM/Builder/Exe.pm:    $source_class_file .= qq|    void* class_file = env->api->compiler->get_class_file(compiler, "$class_name");\n|;
lib/SPVM/Builder/Exe.pm:      $source_class_file .= qq|    env->api->class_file->set_rel_file(compiler, class_file, "$class_file_rel_file");\n|;
lib/SPVM/Builder/Exe.pm:      $source_class_file .= qq|    env->api->class_file->set_content(compiler, class_file, "$content_espcaped");\n|;
lib/SPVM/Builder/Exe.pm:    $source_class_file .= qq|    env->api->class_file->set_content_length(compiler, class_file, $class_file_content_length);\n|;
lib/SPVM/Builder/Exe.pm:  $source .= qq|  env->api->compiler->set_start_file(compiler, __FILE__);\n|;
lib/SPVM/Builder/Exe.pm:  $source .= qq|  env->api->compiler->set_start_line(compiler, __LINE__ + 1);\n|;
lib/SPVM/Builder/Exe.pm:  $source .= qq|  int32_t error_id = env->api->compiler->compile(compiler, \"$start_class_name\");\n|;
lib/SPVM/Builder/Exe.pm:  $source .= qq|  void* runtime = env->api->compiler->get_runtime(compiler);\n|;
lib/SPVM/Builder/Exe.pm:  $source .= qq|  FILE* spvm_stderr = env->api->runtime->get_spvm_stderr(runtime);\n|;
lib/SPVM/Builder/Exe.pm:  $source .= qq|    fprintf(spvm_stderr, "[Unexpected Compile Error]%s.", env->api->compiler->get_error_message(compiler, 0));\n|;
lib/SPVM/Builder/src/spvm_vm.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_vm.c:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_CALL_STACK_ALLOCATION_FAILED]);
lib/SPVM/Builder/src/spvm_vm.c:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/src/spvm_vm.c:  int32_t object_data_offset = env->api->runtime->get_object_data_offset(env->runtime);
lib/SPVM/Builder/src/spvm_vm.c:  int32_t object_ref_count_offset = env->api->runtime->get_object_ref_count_offset(env->runtime);
lib/SPVM/Builder/src/spvm_vm.c:  int32_t object_length_offset = env->api->runtime->get_object_length_offset(env->runtime);
lib/SPVM/Builder/src/spvm_vm.c:          env->set_exception(env, stack, env->new_stack_trace_no_mortal(env, stack, env->get_exception(env, stack), current_method, line));
lib/SPVM/Builder/src/spvm_vm.c:          env->set_exception(env, stack, env->new_stack_trace_no_mortal(env, stack, env->get_exception(env, stack), current_method, line));
lib/SPVM/Builder/src/spvm_vm.c:        void* dist_basic_type = env->api->runtime->get_basic_type_by_id(env->runtime, dist_basic_type_id);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_BASIC_TYPE* basic_type = SPVM_API_RUNTIME_get_basic_type_by_id(env->runtime, basic_type_id);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_BASIC_TYPE* basic_type = SPVM_API_RUNTIME_get_basic_type_by_id(env->runtime, basic_type_id);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_BASIC_TYPE* basic_type = SPVM_API_RUNTIME_get_basic_type_by_id(env->runtime, basic_type_id);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_BASIC_TYPE* basic_type = SPVM_API_RUNTIME_get_basic_type_by_id(env->runtime, basic_type_id);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_index(env->runtime, field_current_basic_type, field_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_index(env->runtime, field_current_basic_type, field_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_index(env->runtime, field_current_basic_type, field_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_index(env->runtime, field_current_basic_type, field_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_index(env->runtime, field_current_basic_type, field_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_index(env->runtime, field_current_basic_type, field_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_index(env->runtime, field_current_basic_type, field_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_index(env->runtime, field_current_basic_type, field_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_index(env->runtime, field_current_basic_type, field_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_index(env->runtime, field_current_basic_type, field_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_index(env->runtime, field_current_basic_type, field_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_index(env->runtime, field_current_basic_type, field_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_index(env->runtime, field_current_basic_type, field_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_index(env->runtime, field_current_basic_type, field_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_index(env->runtime, field_current_basic_type, field_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_index(env->runtime, field_current_basic_type, field_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_index(env->runtime, field_current_basic_type, field_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_index(env->runtime, field_current_basic_type, field_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_index(env->runtime, class_var_current_basic_type, class_var_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_index(env->runtime, class_var_current_basic_type, class_var_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_index(env->runtime, class_var_current_basic_type, class_var_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_index(env->runtime, class_var_current_basic_type, class_var_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_index(env->runtime, class_var_current_basic_type, class_var_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_index(env->runtime, class_var_current_basic_type, class_var_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_index(env->runtime, class_var_current_basic_type, class_var_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_index(env->runtime, class_var_current_basic_type, class_var_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_index(env->runtime, class_var_current_basic_type, class_var_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_index(env->runtime, class_var_current_basic_type, class_var_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_index(env->runtime, class_var_current_basic_type, class_var_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_index(env->runtime, class_var_current_basic_type, class_var_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_index(env->runtime, class_var_current_basic_type, class_var_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_index(env->runtime, class_var_current_basic_type, class_var_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_index(env->runtime, class_var_current_basic_type, class_var_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_BASIC_TYPE* basic_type = SPVM_API_RUNTIME_get_basic_type_by_id(env->runtime, basic_type_id);
lib/SPVM/Builder/src/spvm_vm.c:        void* src_basic_type = SPVM_API_RUNTIME_get_basic_type_by_id(env->runtime, src_basic_type_id);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_BASIC_TYPE* basic_type = SPVM_API_RUNTIME_get_basic_type_by_id(env->runtime, basic_type_id);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_BASIC_TYPE* basic_type = SPVM_API_RUNTIME_get_basic_type_by_id(env->runtime, basic_type_id);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_BASIC_TYPE* basic_type = SPVM_API_RUNTIME_get_basic_type_by_id(env->runtime, basic_type_id);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_METHOD* method = SPVM_API_BASIC_TYPE_get_method_by_index(env->runtime, invocant_decl_basic_type, decl_method_index);
lib/SPVM/Builder/src/spvm_vm.c:        SPVM_RUNTIME_METHOD* method = SPVM_API_BASIC_TYPE_get_method_by_index(env->runtime, invocant_decl_basic_type, decl_method_index);
lib/SPVM/Builder/src/spvm_vm.c:          env->api->internal->dec_ref_count(env, stack, *(void**)&stack[0]);
Binary file lib/SPVM/Builder/src/spvm_precompile.o matches
lib/SPVM/Builder/src/spvm_api.c:  SPVM_API_ALLOCATOR_free_api(env->api->allocator);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_API_STRING_BUFFER_free_api(env->api->string_buffer);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_API_COMPILER_free_api(env->api->compiler);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_API_RUNTIME_free_api(env->api->runtime);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_API_CLASS_FILE_free_api(env->api->class_file);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_API_BASIC_TYPE_free_api(env->api->basic_type);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_API_CLASS_VAR_free_api(env->api->class_var);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_API_FIELD_free_api(env->api->field);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_API_TYPE_free_api(env->api->type);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_API_METHOD_free_api(env->api->method);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_API_ARG_free_api(env->api->arg);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_API_INTERNAL_free_api(env->api->internal);
lib/SPVM/Builder/src/spvm_api.c:  free(env->api);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:    SPVM_RUNTIME_BASIC_TYPE* basic_type = SPVM_API_RUNTIME_get_basic_type_by_id(env->runtime, basic_type_id);
lib/SPVM/Builder/src/spvm_api.c:      SPVM_RUNTIME_METHOD* init_method = SPVM_API_BASIC_TYPE_get_method_by_index(env->runtime, basic_type, basic_type->init_method->index);      
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:    SPVM_RUNTIME_BASIC_TYPE* basic_type = SPVM_API_RUNTIME_get_basic_type_by_id(env->runtime, basic_type_id);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_METHOD* method = SPVM_API_BASIC_TYPE_get_method_by_name(env->runtime, basic_type, method_name);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_METHOD* method = SPVM_API_BASIC_TYPE_get_method_by_name(env->runtime, basic_type, method_name);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_name(env->runtime, basic_type, class_var_name);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_name(env->runtime, basic_type, class_var_name);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_name(env->runtime, basic_type, class_var_name);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_name(env->runtime, basic_type, class_var_name);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_name(env->runtime, basic_type, class_var_name);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_name(env->runtime, basic_type, class_var_name);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_name(env->runtime, basic_type, class_var_name);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_name(env->runtime, basic_type, class_var_name);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_name(env->runtime, basic_type, class_var_name);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_name(env->runtime, basic_type, class_var_name);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_name(env->runtime, basic_type, class_var_name);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_name(env->runtime, basic_type, class_var_name);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_name(env->runtime, basic_type, class_var_name);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_name(env->runtime, basic_type, class_var_name);
lib/SPVM/Builder/src/spvm_api.c:  int8_t value = *(int8_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field->offset);
lib/SPVM/Builder/src/spvm_api.c:  int16_t value = *(int16_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field->offset);
lib/SPVM/Builder/src/spvm_api.c:  int32_t value = *(int32_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field->offset);
lib/SPVM/Builder/src/spvm_api.c:  int64_t value = *(int64_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field->offset);
lib/SPVM/Builder/src/spvm_api.c:  float value = *(float*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field->offset);
lib/SPVM/Builder/src/spvm_api.c:  double value = *(double*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field->offset);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_OBJECT* value_maybe_weaken = *(SPVM_OBJECT**)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field->offset);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_OBJECT** object_ref = (SPVM_OBJECT**)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field->offset);
lib/SPVM/Builder/src/spvm_api.c:  *(int8_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field->offset) = value;
lib/SPVM/Builder/src/spvm_api.c:  *(int16_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field->offset) = value;
lib/SPVM/Builder/src/spvm_api.c:  *(int32_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field->offset) = value;
lib/SPVM/Builder/src/spvm_api.c:  *(int64_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field->offset) = value;
lib/SPVM/Builder/src/spvm_api.c:  *(float*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field->offset) = value;
lib/SPVM/Builder/src/spvm_api.c:  *(double*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field->offset) = value;
lib/SPVM/Builder/src/spvm_api.c:  void* object_ref = (void**)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field->offset);
lib/SPVM/Builder/src/spvm_api.c:  void* obj_field = env->get_field_object_by_name(env, stack, object, field_name, error_id, func_name, file_name, line);
lib/SPVM/Builder/src/spvm_api.c:    *error_id = env->die(env, stack, "The \"%s\" field must be defined.", field_name, func_name, file_name, line);
lib/SPVM/Builder/src/spvm_api.c:  void* field = env->get_pointer(env, stack, obj_field);
lib/SPVM/Builder/src/spvm_api.c:    *error_id = env->die(env, stack, "The pointer of the \"%s\" field must be defined.", field_name, func_name, file_name, line);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_VALUE* stack = env->new_memory_block(env, NULL, sizeof(SPVM_VALUE) * 512);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  env->free_memory_block(env, stack, stack);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:      is_object_array = SPVM_API_TYPE_is_object_type(env->runtime, object_basic_type, element_type_dimension, type_flag);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  FILE* spvm_stderr = SPVM_API_RUNTIME_get_spvm_stderr(env->runtime);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:                int8_t* element = &((int8_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime)))[array_index * fields_length];
lib/SPVM/Builder/src/spvm_api.c:                int16_t* element = &((int16_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime)))[array_index * fields_length];
lib/SPVM/Builder/src/spvm_api.c:                int32_t* element = &((int32_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime)))[array_index * fields_length];
lib/SPVM/Builder/src/spvm_api.c:                int64_t* element = &((int64_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime)))[array_index * fields_length];
lib/SPVM/Builder/src/spvm_api.c:                float* element = &((float*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime)))[array_index * fields_length];
lib/SPVM/Builder/src/spvm_api.c:                double* element = &((double*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime)))[array_index * fields_length];
lib/SPVM/Builder/src/spvm_api.c:              int8_t element = ((int8_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime)))[array_index];
lib/SPVM/Builder/src/spvm_api.c:              int16_t element = ((int16_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime)))[array_index];
lib/SPVM/Builder/src/spvm_api.c:              int32_t element = ((int32_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime)))[array_index];
lib/SPVM/Builder/src/spvm_api.c:              int64_t element = ((int64_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime)))[array_index];
lib/SPVM/Builder/src/spvm_api.c:              float element = ((float*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime)))[array_index];
lib/SPVM/Builder/src/spvm_api.c:              double element = ((double*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime)))[array_index];
lib/SPVM/Builder/src/spvm_api.c:          SPVM_OBJECT* element = (((SPVM_OBJECT**)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime)))[array_index]);
lib/SPVM/Builder/src/spvm_api.c:                int8_t field_value = *(int8_t*)((intptr_t)object + (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field_offset);
lib/SPVM/Builder/src/spvm_api.c:                int16_t field_value = *(int16_t*)((intptr_t)object + (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field_offset);
lib/SPVM/Builder/src/spvm_api.c:                int32_t field_value = *(int32_t*)((intptr_t)object + (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field_offset);
lib/SPVM/Builder/src/spvm_api.c:                int64_t field_value = *(int64_t*)((intptr_t)object + (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field_offset);
lib/SPVM/Builder/src/spvm_api.c:                float field_value = *(float*)((intptr_t)object + (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field_offset);
lib/SPVM/Builder/src/spvm_api.c:                double field_value = *(double*)((intptr_t)object + (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field_offset);
lib/SPVM/Builder/src/spvm_api.c:            SPVM_OBJECT* field_value = *(SPVM_OBJECT**)((intptr_t)object + (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field_offset);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_BASIC_TYPE* string_basic_type = SPVM_API_RUNTIME_get_basic_type_by_id(env->runtime, SPVM_NATIVE_C_BASIC_TYPE_ID_STRING);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  size_t alloc_size = (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + basic_type->fields_size + 1;
lib/SPVM/Builder/src/spvm_api.c:      memcpy((void*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime)), (char*)bytes, length);
lib/SPVM/Builder/src/spvm_api.c:  size_t alloc_size = (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + sizeof(char) * (length + 1);
lib/SPVM/Builder/src/spvm_api.c:      memcpy((void*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime)), (char*)bytes, length);
lib/SPVM/Builder/src/spvm_api.c:  int32_t value = *(int32_t*)((intptr_t)bool_object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime));
lib/SPVM/Builder/src/spvm_api.c:  size_t alloc_size = (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + sizeof(int8_t) * (length + 1);
lib/SPVM/Builder/src/spvm_api.c:  size_t alloc_size = (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + sizeof(int16_t) * (length + 1);
lib/SPVM/Builder/src/spvm_api.c:  size_t alloc_size = (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + sizeof(int32_t) * (length + 1);
lib/SPVM/Builder/src/spvm_api.c:  size_t alloc_size = (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + sizeof(int64_t) * (length + 1);
lib/SPVM/Builder/src/spvm_api.c:  size_t alloc_size = (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + sizeof(float) * (length + 1);
lib/SPVM/Builder/src/spvm_api.c:  size_t alloc_size = (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + sizeof(double) * (length + 1);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  size_t alloc_size = (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + sizeof(void*) * (length + 1);
lib/SPVM/Builder/src/spvm_api.c:  size_t alloc_size = (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + sizeof(void*) * (length + 1);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  size_t alloc_size = (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + unit_size * fields_length * (length + 1);
lib/SPVM/Builder/src/spvm_api.c:  size_t alloc_size = (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + element_size * (length + 1);
lib/SPVM/Builder/src/spvm_api.c:  return (int8_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime));
lib/SPVM/Builder/src/spvm_api.c:  return (const char*)((intptr_t)string + SPVM_API_RUNTIME_get_object_data_offset(env->runtime));
lib/SPVM/Builder/src/spvm_api.c:  return (int16_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime));
lib/SPVM/Builder/src/spvm_api.c:  return (int32_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime));
lib/SPVM/Builder/src/spvm_api.c:  return (int64_t*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime));
lib/SPVM/Builder/src/spvm_api.c:  return (float*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime));
lib/SPVM/Builder/src/spvm_api.c:  return (double*)((intptr_t)object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime));
lib/SPVM/Builder/src/spvm_api.c:  SPVM_OBJECT* object_maybe_weaken = ((SPVM_OBJECT**)((intptr_t)array + SPVM_API_RUNTIME_get_object_data_offset(env->runtime)))[index];
lib/SPVM/Builder/src/spvm_api.c:  void* object_ref = &((void**)((intptr_t)array + SPVM_API_RUNTIME_get_object_data_offset(env->runtime)))[index];
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_FIELD* field = SPVM_API_BASIC_TYPE_get_field_by_name(env->runtime, basic_type, field_name);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_CLASS_VAR* class_var = SPVM_API_BASIC_TYPE_get_class_var_by_name(env->runtime, basic_type, class_var_name);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME_METHOD* method = SPVM_API_BASIC_TYPE_get_method_by_name(env->runtime, basic_type, method_name);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:      isa = SPVM_API_TYPE_can_assign(env->runtime, basic_type, type_dimension, 0, object_basic_type, object_type_dimension, 0);
lib/SPVM/Builder/src/spvm_api.c:  void* basic_type = SPVM_API_RUNTIME_get_basic_type_by_id(env->runtime, basic_type_id);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:        int32_t arg_is_object_type = SPVM_API_TYPE_is_object_type(env->runtime, arg->basic_type, arg->type_dimension, arg->type_flag);
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:          SPVM_OBJECT** ref = &(((SPVM_OBJECT**)((intptr_t)released_object + SPVM_API_RUNTIME_get_object_data_offset(env->runtime)))[index]);
lib/SPVM/Builder/src/spvm_api.c:          SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:            SPVM_RUNTIME_METHOD* destructor_method = SPVM_API_BASIC_TYPE_get_method_by_index(env->runtime, released_object_basic_type, released_object_basic_type->destructor_method->index);
lib/SPVM/Builder/src/spvm_api.c:              SPVM_OBJECT** ref = (SPVM_OBJECT**)((intptr_t)released_object + (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + field->offset);
lib/SPVM/Builder/src/spvm_api.c:    SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:    SPVM_RUNTIME* runtime = env->runtime;
lib/SPVM/Builder/src/spvm_api.c:  FILE* spvm_stdin = env->api->runtime->get_spvm_stdin(env->runtime);
lib/SPVM/Builder/src/spvm_api.c:  FILE* spvm_stdout = env->api->runtime->get_spvm_stdout(env->runtime);
lib/SPVM/Builder/src/spvm_api.c:  FILE* spvm_stderr = env->api->runtime->get_spvm_stderr(env->runtime);
lib/SPVM/Builder/src/spvm_api.c:  void* class_basic_type = env->api->runtime->get_basic_type_by_name(env->runtime, basic_type_name);
lib/SPVM/Builder/src/spvm_api.c:  void* method = env->api->basic_type->get_method_by_name(env->runtime, class_basic_type, "main");
lib/SPVM/Builder/src/spvm_api.c:    int32_t is_class_method = env->api->method->is_class_method(env->runtime, method);
lib/SPVM/Builder/src/spvm_api.c:      int32_t args_length = env->api->method->get_args_length(env->runtime, method);
lib/SPVM/Builder/src/spvm_api.c:        error_id = env->die(env, stack, "The length of the arguments of the \"main\" method in the \"%s\" class must be 0.", basic_type_name, __func__, FILE_NAME, __LINE__);
lib/SPVM/Builder/src/spvm_api.c:        void* return_basic_type = env->api->method->get_return_basic_type(env->runtime, method);
lib/SPVM/Builder/src/spvm_api.c:        const char* return_basic_type_name = env->api->basic_type->get_name(env->runtime, return_basic_type);
lib/SPVM/Builder/src/spvm_api.c:          error_id = env->die(env, stack, "The return type of the \"main\" method in the \"%s\" class must be the void type.", basic_type_name, __func__, FILE_NAME, __LINE__);
lib/SPVM/Builder/src/spvm_api.c:      error_id = env->die(env, stack, "The \"main\" method in the \"%s\" class must be a class method.", basic_type_name, __func__, FILE_NAME, __LINE__);
lib/SPVM/Builder/src/spvm_api.c:    error_id = env->die(env, stack, "The \"main\" method in the \"%s\" class must be defined.", basic_type_name, __func__, FILE_NAME, __LINE__);
lib/SPVM/Builder/src/spvm_api.c:  size_t alloc_size = (size_t)SPVM_API_RUNTIME_get_object_data_offset(env->runtime) + sizeof(void*) * (length + 1);
lib/SPVM/Builder/src/spvm_precompile.c:  SPVM_STRING_BUFFER_add(string_buffer,"  void* current_basic_type = env->api->runtime->get_basic_type_by_name(env->runtime, current_basic_type_name);\n");
lib/SPVM/Builder/src/spvm_precompile.c:  SPVM_STRING_BUFFER_add(string_buffer,"  void* current_method = env->api->basic_type->get_method_by_name(env->runtime, current_basic_type, current_method_name);\n");
lib/SPVM/Builder/src/spvm_precompile.c:  SPVM_STRING_BUFFER_add(string_buffer, "  int32_t object_header_size = env->api->runtime->get_object_data_offset(env->runtime);\n");
lib/SPVM/Builder/src/spvm_precompile.c:  SPVM_STRING_BUFFER_add(string_buffer, "  int32_t object_length_offset = env->api->runtime->get_object_length_offset(env->runtime);\n");
lib/SPVM/Builder/src/spvm_precompile.c:                                              "    env->set_exception(env, stack, env->new_stack_trace_no_mortal(env, stack, env->get_exception(env, stack), current_method, line = ");
lib/SPVM/Builder/src/spvm_precompile.c:                                              "    env->set_exception(env, stack, env->new_stack_trace_no_mortal(env, stack, env->get_exception(env, stack), current_method, line = ");
lib/SPVM/Builder/src/spvm_precompile.c:        SPVM_STRING_BUFFER_add(string_buffer, "  src_basic_type = env->api->runtime->get_basic_type_by_id(env->runtime, src_basic_type_id);");
lib/SPVM/Builder/src/spvm_precompile.c:        SPVM_STRING_BUFFER_add(string_buffer, "  src_basic_type = env->api->runtime->get_basic_type_by_id(env->runtime, src_basic_type_id);\n");
lib/SPVM/Builder/src/spvm_precompile.c:        SPVM_STRING_BUFFER_add(string_buffer, "  basic_type_id = env->api->basic_type->get_id(env->runtime, basic_type);");
lib/SPVM/Builder/src/spvm_precompile.c:                                          "    env->api->internal->dec_ref_count(env, stack, stack[0].oval);\n"
lib/SPVM/Builder/include/spvm_precompile.h:      env->dec_ref_count(env, stack, (*(void**)((intptr_t)SPVM_PRECOMPILE_RUNTIME + SPVM_PRECOMPILE_RUNTIME_EXCEPTION_OFFSET))); \
lib/SPVM/Builder/include/spvm_implement.h:  void* basic_type = env->api->runtime->get_basic_type_by_name(env->runtime, basic_type_name);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, message);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:  void* field = env->get_field_static(env, stack, basic_type_name, field_name);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, message);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:  void* field = env->get_field_static(env, stack, basic_type_name, field_name);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, message);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:  int32_t field_offset = env->api->field->get_offset(env->runtime, field);
lib/SPVM/Builder/include/spvm_implement.h:  void* class_var = env->get_class_var(env, stack, basic_type_name, class_var_name);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, message);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:  void* method = env->get_method(env, stack, basic_type_name, method_name);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, message);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:  env->assign_object(env, stack, dist_address, NULL);
lib/SPVM/Builder/include/spvm_implement.h:  env->api->internal->leave_scope_local(env, stack, object_vars, mortal_stack, mortal_stack_top_ptr, original_mortal_stack_top);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_DIVIDE_ZERO]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_DIVIDE_ZERO]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_DIVIDE_ZERO]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_DIVIDE_ZERO]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_DIVIDE_ZERO]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_DIVIDE_ZERO]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_DIVIDE_ZERO]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_DIVIDE_ZERO]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_MOVE_OBJECT(env, stack, out, in) (env->assign_object(env, stack, out, in))
lib/SPVM/Builder/include/spvm_implement.h:  int32_t isa = env->isa(env, stack, object, dist_basic_type, dist_type_dimension);
lib/SPVM/Builder/include/spvm_implement.h:    env->assign_object(env, stack, out, in);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_VALUE_ASSIGN_NON_ASSIGNABLE_TYPE]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:  if (env->is_read_only(env, stack, string)) {
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ASSIGN_READ_ONLY_STRING_TO_MUTABLE_TYPE]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    env->assign_object(env, stack, out, string);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_CONCAT_LEFT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_CONCAT_RIGHT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* string3 = env->concat_no_mortal(env, stack, string1, string2);
lib/SPVM/Builder/include/spvm_implement.h:    env->assign_object(env, stack, out, string3);
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_BOOL_CONVERSION_BOOL_OBJECT(env, stack, out, in) (out = !!env->get_bool_object_value(env, stack, in))
lib/SPVM/Builder/include/spvm_implement.h:    const char* bytes1 = env->get_chars(env, stack, object1);
lib/SPVM/Builder/include/spvm_implement.h:    const char* bytes2 = env->get_chars(env, stack, object2);
lib/SPVM/Builder/include/spvm_implement.h:  void* object = env->new_object_no_mortal(env, stack, basic_type);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_NEW_OBJECT_FAILED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    env->assign_object(env, stack, out, object);
lib/SPVM/Builder/include/spvm_implement.h:    void* object = env->new_object_array_no_mortal(env, stack, basic_type, length);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_NEW_ARRAY_FAILED]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      env->assign_object(env, stack, out, object);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRRAY_LENGTH_SMALL]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* object = env->new_muldim_array_no_mortal(env, stack, basic_type, type_dimension, length);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_NEW_ARRAY_FAILED]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      env->assign_object(env, stack, out, object);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRRAY_LENGTH_SMALL]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* object = env->new_mulnum_array_no_mortal(env, stack, basic_type, length);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_NEW_ARRAY_FAILED]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      env->assign_object(env, stack, out, object);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRRAY_LENGTH_SMALL]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* object = env->new_byte_array_no_mortal(env, stack, length);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_NEW_ARRAY_FAILED]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      env->assign_object(env, stack, out, object);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRRAY_LENGTH_SMALL]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* object = env->new_short_array_no_mortal(env, stack, length);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_NEW_ARRAY_FAILED]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      env->assign_object(env, stack, out, object);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRRAY_LENGTH_SMALL]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* object = env->new_int_array_no_mortal(env, stack, length);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_NEW_ARRAY_FAILED]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      env->assign_object(env, stack, out, object);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRRAY_LENGTH_SMALL]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* object = env->new_long_array_no_mortal(env, stack, length);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_NEW_ARRAY_FAILED]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      env->assign_object(env, stack, out, object);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRRAY_LENGTH_SMALL]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* object = env->new_float_array_no_mortal(env, stack, length);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_NEW_ARRAY_FAILED]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      env->assign_object(env, stack, out, object);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRRAY_LENGTH_SMALL]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* object = env->new_double_array_no_mortal(env, stack, length);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_NEW_ARRAY_FAILED]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      env->assign_object(env, stack, out, object);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRRAY_LENGTH_SMALL]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:  void* string = env->new_string_no_mortal(env, stack, constant_string, constant_string_length);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_NEW_STRING_FAILED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    env->make_read_only(env, stack, string);
lib/SPVM/Builder/include/spvm_implement.h:    env->assign_object(env, stack, out , string);
lib/SPVM/Builder/include/spvm_implement.h:    void* string = env->new_string_no_mortal(env, stack, NULL, length);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_NEW_STRING_FAILED]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      env->assign_object(env, stack, out, string);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_STRING_LENGTH_SMALL]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_IS_READ_ONLY(env, stack, out, in) (out = env->is_read_only(env, stack, in))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_MAKE_READ_ONLY(env, stack, in) (env->make_read_only(env, stack, in))
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]));
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]));
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]));
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]));
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]));
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]));
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]));
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]));
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]));
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]));
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]));
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]));
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]));
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]));
lib/SPVM/Builder/include/spvm_implement.h:      env->assign_object(env, stack, out, ((void**)((intptr_t)array + object_data_offset))[index]);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      env->assign_object(env, stack, element_address, in);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      int32_t elem_isa = env->elem_isa(env, stack, array, object);
lib/SPVM/Builder/include/spvm_implement.h:        env->assign_object(env, stack, element_address, object);
lib/SPVM/Builder/include/spvm_implement.h:        void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ELEMENT_ASSIGN_NON_ASSIGNABLE_TYPE]);
lib/SPVM/Builder/include/spvm_implement.h:        env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      env->assign_object(env, stack, object_address, NULL);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_FIELD_ACCESS_INVOCANT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_FIELD_ACCESS_INVOCANT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_FIELD_ACCESS_INVOCANT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_FIELD_ACCESS_INVOCANT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_FIELD_ACCESS_INVOCANT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_FIELD_ACCESS_INVOCANT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_FIELD_ACCESS_INVOCANT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    env->assign_object(env, stack, out, object);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_FIELD_ACCESS_INVOCANT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_FIELD_ACCESS_INVOCANT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_FIELD_ACCESS_INVOCANT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_FIELD_ACCESS_INVOCANT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_FIELD_ACCESS_INVOCANT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_FIELD_ACCESS_INVOCANT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_FIELD_ACCESS_INVOCANT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    env->assign_object(env, stack, ref, in);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_FIELD_ACCESS_INVOCANT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    env->assign_object(env, stack, ref, NULL);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_FIELD_ACCESS_INVOCANT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    int32_t status = env->weaken(env, stack, ref);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_WEAKEN_BACK_REFERENCE_ALLOCATION_FAILED]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_FIELD_ACCESS_INVOCANT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    env->unweaken(env, stack, ref);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_FIELD_ACCESS_INVOCANT_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    *out = env->isweak(env, stack, ref);
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_GET_CLASS_VAR_BYTE(env, stack, out, class_var) (out = env->get_class_var_byte(env, stack, class_var))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_GET_CLASS_VAR_SHORT(env, stack, out, class_var) (out = env->get_class_var_short(env, stack, class_var))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_GET_CLASS_VAR_INT(env, stack, out, class_var) (out = env->get_class_var_int(env, stack, class_var))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_GET_CLASS_VAR_LONG(env, stack, out, class_var) (out = env->get_class_var_long(env, stack, class_var))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_GET_CLASS_VAR_FLOAT(env, stack, out, class_var) (out = env->get_class_var_float(env, stack, class_var))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_GET_CLASS_VAR_DOUBLE(env, stack, out, class_var) (out = env->get_class_var_double(env, stack, class_var))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_GET_CLASS_VAR_OBJECT(env, stack, out, class_var) (env->assign_object(env, stack, out, env->get_class_var_object(env, stack, class_var)))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_SET_CLASS_VAR_BYTE(env, stack, class_var, in) (env->set_class_var_byte(env, stack, class_var, in))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_SET_CLASS_VAR_SHORT(env, stack, class_var, in) (env->set_class_var_short(env, stack, class_var, in))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_SET_CLASS_VAR_INT(env, stack, class_var, in) (env->set_class_var_int(env, stack, class_var, in))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_SET_CLASS_VAR_LONG(env, stack, class_var, in) (env->set_class_var_long(env, stack, class_var, in))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_SET_CLASS_VAR_FLOAT(env, stack, class_var, in) (env->set_class_var_float(env, stack, class_var, in))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_SET_CLASS_VAR_DOUBLE(env, stack, class_var, in) (env->set_class_var_double(env, stack, class_var, in))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_SET_CLASS_VAR_OBJECT(env, stack, class_var, in) (env->assign_object(env, stack, env->get_class_var_object_ref(env, stack, class_var), in))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_SET_CLASS_VAR_UNDEF(env, stack, class_var) (env->assign_object(env, stack, env->get_class_var_object_ref(env, stack, class_var), NULL))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_GET_EXCEPTION_VAR(env, stack, out) (env->assign_object(env, stack, out, env->get_exception(env, stack)))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_SET_EXCEPTION_VAR(env, stack, in) (env->set_exception(env, stack, in))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_SET_EXCEPTION_VAR_UNDEF(env, stack) (env->set_exception(env, stack, NULL))
lib/SPVM/Builder/include/spvm_implement.h:    *out = env->isa(env, stack, object, dist_basic_type, dist_type_dimension);
lib/SPVM/Builder/include/spvm_implement.h:  *out = env->api->type->can_assign(env->runtime, dist_basic_type, dist_type_dimension, 0, src_basic_type, 0, 0);
lib/SPVM/Builder/include/spvm_implement.h:    *out = env->is_type(env, stack, object, dist_basic_type, dist_type_dimension);
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_CAN(env, stack, out, object, method_name) (out = (env->get_instance_method(env, stack, object, method_name) != NULL))
lib/SPVM/Builder/include/spvm_implement.h:  env->print(env, stack, string);
lib/SPVM/Builder/include/spvm_implement.h:  env->say(env, stack, string);
lib/SPVM/Builder/include/spvm_implement.h:  env->warn(env, stack, string, NULL, NULL, file, line);
lib/SPVM/Builder/include/spvm_implement.h:  env->warn(env, stack, string, basic_type_name, method_name, file, line);
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_ARGS_WIDTH(env, stack, out) (out = env->args_width(env, stack))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_GET_BASIC_TYPE_ID(env, stack, out, basic_type) (out = env->api->basic_type->get_id(env->runtime, basic_type))
lib/SPVM/Builder/include/spvm_implement.h:    void* type_name = env->get_type_name_no_mortal(env, stack, object);
lib/SPVM/Builder/include/spvm_implement.h:    env->assign_object(env, stack, out, type_name);
lib/SPVM/Builder/include/spvm_implement.h:  void* dump = env->dump_no_mortal(env, stack, object);
lib/SPVM/Builder/include/spvm_implement.h:  env->assign_object(env, stack, out, dump);
lib/SPVM/Builder/include/spvm_implement.h:    if (!(env->is_string(env, stack, object) || env->is_numeric_array(env, stack, object) || env->is_mulnum_array(env, stack, object))) {
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_COPY_OPERAND_INVALID]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* new_object_no_mortal = env->copy_no_mortal(env, stack, object);
lib/SPVM/Builder/include/spvm_implement.h:      env->assign_object(env, stack, out, new_object_no_mortal);
lib/SPVM/Builder/include/spvm_implement.h:    env->assign_object(env, stack, out, NULL);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_UNDEFINED]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_ARRAY_ACCESS_INDEX_OUT_OF_RANGE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:  void* string = env->new_string_no_mortal(env, stack, tmp_buffer, string_length);
lib/SPVM/Builder/include/spvm_implement.h:  env->assign_object(env, stack, out, string);
lib/SPVM/Builder/include/spvm_implement.h:  void* string = env->new_string_no_mortal(env, stack, tmp_buffer, string_length);
lib/SPVM/Builder/include/spvm_implement.h:  env->assign_object(env, stack, out, string);
lib/SPVM/Builder/include/spvm_implement.h:  void* string = env->new_string_no_mortal(env, stack, tmp_buffer, string_length);
lib/SPVM/Builder/include/spvm_implement.h:  env->assign_object(env, stack, out, string);
lib/SPVM/Builder/include/spvm_implement.h:  void* string = env->new_string_no_mortal(env, stack, tmp_buffer, string_length);
lib/SPVM/Builder/include/spvm_implement.h:  env->assign_object(env, stack, out, string);
lib/SPVM/Builder/include/spvm_implement.h:  void* string = env->new_string_no_mortal(env, stack, tmp_buffer, string_length);
lib/SPVM/Builder/include/spvm_implement.h:  env->assign_object(env, stack, out, string);
lib/SPVM/Builder/include/spvm_implement.h:  void* string = env->new_string_no_mortal(env, stack, tmp_buffer, string_length);
lib/SPVM/Builder/include/spvm_implement.h:  env->assign_object(env, stack, out, string);
lib/SPVM/Builder/include/spvm_implement.h:    const char* string = env->get_chars(env, stack, src_string);
lib/SPVM/Builder/include/spvm_implement.h:    const char* string = env->get_chars(env, stack, src_string);
lib/SPVM/Builder/include/spvm_implement.h:    const char* string = env->get_chars(env, stack, src_string);
lib/SPVM/Builder/include/spvm_implement.h:    const char* string = env->get_chars(env, stack, src_string);
lib/SPVM/Builder/include/spvm_implement.h:    const char* string = env->get_chars(env, stack, src_string);
lib/SPVM/Builder/include/spvm_implement.h:    const char* string = env->get_chars(env, stack, src_string);
lib/SPVM/Builder/include/spvm_implement.h:    int32_t src_string_length = env->length(env, stack, src_string);
lib/SPVM/Builder/include/spvm_implement.h:    const char* src_string_data = env->get_chars(env, stack, src_string);
lib/SPVM/Builder/include/spvm_implement.h:    void* byte_array = env->new_byte_array_no_mortal(env, stack, src_string_length);
lib/SPVM/Builder/include/spvm_implement.h:    int8_t* byte_array_data = env->get_elems_byte(env, stack, byte_array);
lib/SPVM/Builder/include/spvm_implement.h:    env->assign_object(env, stack, out, byte_array);
lib/SPVM/Builder/include/spvm_implement.h:    env->assign_object(env, stack, out, NULL);
lib/SPVM/Builder/include/spvm_implement.h:  int32_t src_byte_array_length = env->length(env, stack, src_byte_array);
lib/SPVM/Builder/include/spvm_implement.h:  int8_t* src_byte_array_data = env->get_elems_byte(env, stack, src_byte_array);
lib/SPVM/Builder/include/spvm_implement.h:  void* string = env->new_string_no_mortal(env, stack, (const char*)src_byte_array_data, src_byte_array_length);
lib/SPVM/Builder/include/spvm_implement.h:  env->assign_object(env, stack, out, string);
lib/SPVM/Builder/include/spvm_implement.h:  void* basic_type = env->api->runtime->get_basic_type_by_id(env->runtime, SPVM_NATIVE_C_BASIC_TYPE_ID_BYTE_CLASS);
lib/SPVM/Builder/include/spvm_implement.h:  void* object = env->new_object_no_mortal(env, stack, basic_type);
lib/SPVM/Builder/include/spvm_implement.h:  env->assign_object(env, stack, out, object);
lib/SPVM/Builder/include/spvm_implement.h:  void* basic_type = env->api->runtime->get_basic_type_by_id(env->runtime, SPVM_NATIVE_C_BASIC_TYPE_ID_SHORT_CLASS);
lib/SPVM/Builder/include/spvm_implement.h:  void* object = env->new_object_no_mortal(env, stack, basic_type);
lib/SPVM/Builder/include/spvm_implement.h:  env->assign_object(env, stack, out, object);
lib/SPVM/Builder/include/spvm_implement.h:  void* basic_type = env->api->runtime->get_basic_type_by_id(env->runtime, SPVM_NATIVE_C_BASIC_TYPE_ID_INT_CLASS);
lib/SPVM/Builder/include/spvm_implement.h:  void* object = env->new_object_no_mortal(env, stack, basic_type);
lib/SPVM/Builder/include/spvm_implement.h:  env->assign_object(env, stack, out, object);
lib/SPVM/Builder/include/spvm_implement.h:  void* basic_type = env->api->runtime->get_basic_type_by_id(env->runtime, SPVM_NATIVE_C_BASIC_TYPE_ID_LONG_CLASS);
lib/SPVM/Builder/include/spvm_implement.h:  void* object = env->new_object_no_mortal(env, stack, basic_type);
lib/SPVM/Builder/include/spvm_implement.h:  env->assign_object(env, stack, out, object);
lib/SPVM/Builder/include/spvm_implement.h:  void* basic_type = env->api->runtime->get_basic_type_by_id(env->runtime, SPVM_NATIVE_C_BASIC_TYPE_ID_FLOAT_CLASS);
lib/SPVM/Builder/include/spvm_implement.h:  void* object = env->new_object_no_mortal(env, stack, basic_type);
lib/SPVM/Builder/include/spvm_implement.h:  env->assign_object(env, stack, out, object);
lib/SPVM/Builder/include/spvm_implement.h:  void* basic_type = env->api->runtime->get_basic_type_by_id(env->runtime, SPVM_NATIVE_C_BASIC_TYPE_ID_DOUBLE_CLASS);
lib/SPVM/Builder/include/spvm_implement.h:  void* object = env->new_object_no_mortal(env, stack, basic_type);
lib/SPVM/Builder/include/spvm_implement.h:  env->assign_object(env, stack, out, object);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_UNBOXING_CONVERSION_FROM_UNDEF]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    if (env->is_type_by_name(env, stack, object, "Byte", 0)) {
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_UNBOXING_CONVERSION_NON_CORRESPONDING_NUMERIC_OBJECT_TYPE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_UNBOXING_CONVERSION_FROM_UNDEF]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    if (env->is_type_by_name(env, stack, object, "Short", 0)) {
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_UNBOXING_CONVERSION_NON_CORRESPONDING_NUMERIC_OBJECT_TYPE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_UNBOXING_CONVERSION_FROM_UNDEF]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    if (env->is_type_by_name(env, stack, object, "Int", 0)) {
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_UNBOXING_CONVERSION_NON_CORRESPONDING_NUMERIC_OBJECT_TYPE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_UNBOXING_CONVERSION_FROM_UNDEF]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    if (env->is_type_by_name(env, stack, object, "Long", 0)) {
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_UNBOXING_CONVERSION_NON_CORRESPONDING_NUMERIC_OBJECT_TYPE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_UNBOXING_CONVERSION_FROM_UNDEF]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    if (env->is_type_by_name(env, stack, object, "Float", 0)) {
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_UNBOXING_CONVERSION_NON_CORRESPONDING_NUMERIC_OBJECT_TYPE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_UNBOXING_CONVERSION_FROM_UNDEF]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    if (env->is_type_by_name(env, stack, object, "Double", 0)) {
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_UNBOXING_CONVERSION_NON_CORRESPONDING_NUMERIC_OBJECT_TYPE]);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:  env->assign_object(env, stack, out, *(void**)&stack[stack_index]);
lib/SPVM/Builder/include/spvm_implement.h:  int32_t args_width = env->args_width(env, stack);
lib/SPVM/Builder/include/spvm_implement.h:  int32_t args_width = env->args_width(env, stack);
lib/SPVM/Builder/include/spvm_implement.h:  int32_t args_width = env->args_width(env, stack);
lib/SPVM/Builder/include/spvm_implement.h:  int32_t args_width = env->args_width(env, stack);
lib/SPVM/Builder/include/spvm_implement.h:  int32_t args_width = env->args_width(env, stack);
lib/SPVM/Builder/include/spvm_implement.h:  int32_t args_width = env->args_width(env, stack);
lib/SPVM/Builder/include/spvm_implement.h:  int32_t args_width = env->args_width(env, stack);
lib/SPVM/Builder/include/spvm_implement.h:    env->assign_object(env, stack, out, NULL);
lib/SPVM/Builder/include/spvm_implement.h:    env->assign_object(env, stack, out, *(void**)&stack[stack_index]);
lib/SPVM/Builder/include/spvm_implement.h:    env->api->internal->inc_ref_count(env, stack, in);
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_CALL_CLASS_METHOD(env, stack, error_id, method, args_width) (error_id = env->call_method_no_mortal(env, stack, method, args_width))
lib/SPVM/Builder/include/spvm_implement.h:#define SPVM_IMPLEMENT_CALL_INSTANCE_METHOD_STATIC(env, stack, error_id, method, args_width) (error_id = env->call_method_no_mortal(env, stack, method, args_width))
lib/SPVM/Builder/include/spvm_implement.h:    void* exception = env->new_string_nolen_no_mortal(env, stack, SPVM_IMPLEMENT_STRING_LITERALS[SPVM_IMPLEMENT_C_STRING_CALL_INSTANCE_METHOD_INVOCANT_UNDEF]);
lib/SPVM/Builder/include/spvm_implement.h:    env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    method = env->get_instance_method(env, stack, object, method_name);
lib/SPVM/Builder/include/spvm_implement.h:      void* exception = env->new_string_nolen_no_mortal(env, stack, tmp_buffer);
lib/SPVM/Builder/include/spvm_implement.h:      env->set_exception(env, stack, exception);
lib/SPVM/Builder/include/spvm_implement.h:    *error_id = env->call_method_no_mortal(env, stack, method, args_width);
lib/SPVM/Native.c:  void* obj_env = env->new_pointer_object_by_name(env, stack, "Native::Env", env, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native.c:  void* obj_runtime = env->new_pointer_object_by_name(env, stack, "Native::Runtime", env->runtime, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native.c:  env->set_field_object_by_name(env, stack, obj_env, "runtime", obj_runtime, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native.c:  void* obj_compiler = env->new_pointer_object_by_name(env, stack, "Native::Compiler", env->api->runtime->get_compiler(env->runtime), &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native.c:  env->set_field_object_by_name(env, stack, obj_runtime, "compiler", obj_compiler, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native.c:  env->set_field_object_by_name(env, stack, obj_compiler, "runtime", obj_runtime, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native.c:  void** obj_runtime_ref = env->get_field_object_ref_by_name(env, stack, obj_compiler, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native.c:  env->weaken(env, stack, obj_runtime_ref);
lib/SPVM/Native.c:  env->set_field_byte_by_name(env, stack, obj_env, "no_destroy", 1, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native.c:  void* obj_stack = env->new_pointer_object_by_name(env, stack, "Native::Stack", stack, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native.c:  env->set_field_byte_by_name(env, stack, obj_stack, "no_destroy", 1, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native.c:    return env->die(env, stack, "$basic_type_name must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native.c:  const char* basic_type_name = env->get_chars(env, stack, obj_basic_type_name);
lib/SPVM/Native.c:  error_id = env->check_bootstrap_method(env, stack, basic_type_name);
lib/SPVM/Native.c:    return env->die(env, stack, env->get_chars(env, stack, env->get_exception(env, stack)), __func__, FILE_NAME, __LINE__);
lib/SPVM/Native.spvm:    my $current_runtime = $current_env->runtime;
lib/SPVM/Format.c:  stack[0].oval = env->new_string(env, stack, formatted_string, length);
lib/SPVM/Format.c:  void* obj_formatted_string = env->new_string(env, stack, NULL, max_length);
lib/SPVM/Format.c:  char* formatted_string = (char*)env->get_chars(env, stack, obj_formatted_string);
lib/SPVM/Format.c:  stack[0].oval = env->new_string(env, stack, formatted_string, length);
lib/SPVM/Format.c:  void* obj_formatted_string = env->new_string(env, stack, NULL, max_length);
lib/SPVM/Format.c:  char* formatted_string = (char*)env->get_chars(env, stack, obj_formatted_string);
lib/SPVM/Format.c:  stack[0].oval = env->new_string(env, stack, formatted_string, length);
lib/SPVM/Format.c:  stack[0].oval = env->new_string(env, stack, formatted_string, length);
lib/SPVM/Format.c:  stack[0].oval = env->new_string(env, stack, formatted_string, length);
lib/SPVM/Format.c:  stack[0].oval = env->new_string(env, stack, formatted_string, length);
lib/SPVM/Format.c:  void* obj_formatted_string = env->new_string(env, stack, NULL, max_length);
lib/SPVM/Format.c:  char* formatted_string = (char*)env->get_chars(env, stack, obj_formatted_string);
lib/SPVM/Format.c:  stack[0].oval = env->new_string(env, stack, formatted_string, length);
lib/SPVM/Format.c:  stack[0].oval = env->new_string(env, stack, formatted_string, length);
lib/SPVM/Format.c:  stack[0].oval = env->new_string(env, stack, formatted_string, length);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$length must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:  int8_t* dest = env->get_elems_byte(env, stack, obj_dest);
lib/SPVM/Array.c:  int32_t dest_length = env->length(env, stack, obj_dest);
lib/SPVM/Array.c:  int8_t* source = env->get_elems_byte(env, stack, obj_source);
lib/SPVM/Array.c:  int32_t source_length = env->length(env, stack, obj_source);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset + $length must be less than or equal to the length of $dest.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset + $length must be less than or equal to the length of $source.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$length must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:  double* dest = env->get_elems_double(env, stack, obj_dest);
lib/SPVM/Array.c:  int32_t dest_length = env->length(env, stack, obj_dest);
lib/SPVM/Array.c:  double* source = env->get_elems_double(env, stack, obj_source);
lib/SPVM/Array.c:  int32_t source_length = env->length(env, stack, obj_source);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset + $length must be less than or equal to the length of $dest.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset + $length must be less than or equal to the length of $source.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$length must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:  float* dest = env->get_elems_float(env, stack, obj_dest);
lib/SPVM/Array.c:  int32_t dest_length = env->length(env, stack, obj_dest);
lib/SPVM/Array.c:  float* source = env->get_elems_float(env, stack, obj_source);
lib/SPVM/Array.c:  int32_t source_length = env->length(env, stack, obj_source);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset + $length must be less than or equal to the length of $dest.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset + $length must be less than or equal to the length of $source.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$length must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:  int32_t* dest = env->get_elems_int(env, stack, obj_dest);
lib/SPVM/Array.c:  int32_t dest_length = env->length(env, stack, obj_dest);
lib/SPVM/Array.c:  int32_t* source = env->get_elems_int(env, stack, obj_source);
lib/SPVM/Array.c:  int32_t source_length = env->length(env, stack, obj_source);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset + $length must be less than or equal to the length of $dest.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset + $length must be less than or equal to the length of $source.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$length must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:  int64_t* dest = env->get_elems_long(env, stack, obj_dest);
lib/SPVM/Array.c:  int32_t dest_length = env->length(env, stack, obj_dest);
lib/SPVM/Array.c:  int64_t* source = env->get_elems_long(env, stack, obj_source);
lib/SPVM/Array.c:  int32_t source_length = env->length(env, stack, obj_source);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset + $length must be less than or equal to the length of $dest.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset + $length must be less than or equal to the length of $source.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$length must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:  int16_t* dest = env->get_elems_short(env, stack, obj_dest);
lib/SPVM/Array.c:  int32_t dest_length = env->length(env, stack, obj_dest);
lib/SPVM/Array.c:  int16_t* source = env->get_elems_short(env, stack, obj_source);
lib/SPVM/Array.c:  int32_t source_length = env->length(env, stack, obj_source);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset + $length must be less than or equal to the length of $dest.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset + $length must be less than or equal to the length of $source.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$length must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:  int8_t* dest = env->get_elems_byte(env, stack, obj_dest);
lib/SPVM/Array.c:  int32_t dest_length = env->length(env, stack, obj_dest);
lib/SPVM/Array.c:  int8_t* source = env->get_elems_byte(env, stack, obj_source);
lib/SPVM/Array.c:  int32_t source_length = env->length(env, stack, obj_source);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset + $length must be less than or equal to the length of $dest.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset + $length must be less than or equal to the length of $source.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$length must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:  double* dest = env->get_elems_double(env, stack, obj_dest);
lib/SPVM/Array.c:  int32_t dest_length = env->length(env, stack, obj_dest);
lib/SPVM/Array.c:  double* source = env->get_elems_double(env, stack, obj_source);
lib/SPVM/Array.c:  int32_t source_length = env->length(env, stack, obj_source);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset + $length must be less than or equal to the length of $dest.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset + $length must be less than or equal to the length of $source.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$length must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:  float* dest = env->get_elems_float(env, stack, obj_dest);
lib/SPVM/Array.c:  int32_t dest_length = env->length(env, stack, obj_dest);
lib/SPVM/Array.c:  float* source = env->get_elems_float(env, stack, obj_source);
lib/SPVM/Array.c:  int32_t source_length = env->length(env, stack, obj_source);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset + $length must be less than or equal to the length of $dest.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset + $length must be less than or equal to the length of $source.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$length must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:  int32_t* dest = env->get_elems_int(env, stack, obj_dest);
lib/SPVM/Array.c:  int32_t dest_length = env->length(env, stack, obj_dest);
lib/SPVM/Array.c:  int32_t* source = env->get_elems_int(env, stack, obj_source);
lib/SPVM/Array.c:  int32_t source_length = env->length(env, stack, obj_source);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset + $length must be less than or equal to the length of $dest.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset + $length must be less than or equal to the length of $source.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$length must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:  int64_t* dest = env->get_elems_long(env, stack, obj_dest);
lib/SPVM/Array.c:  int32_t dest_length = env->length(env, stack, obj_dest);
lib/SPVM/Array.c:  int64_t* source = env->get_elems_long(env, stack, obj_source);
lib/SPVM/Array.c:  int32_t source_length = env->length(env, stack, obj_source);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset + $length must be less than or equal to the length of $dest.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset + $length must be less than or equal to the length of $source.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$length must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:  int16_t* dest = env->get_elems_short(env, stack, obj_dest);
lib/SPVM/Array.c:  int32_t dest_length = env->length(env, stack, obj_dest);
lib/SPVM/Array.c:  int16_t* source = env->get_elems_short(env, stack, obj_source);
lib/SPVM/Array.c:  int32_t source_length = env->length(env, stack, obj_source);
lib/SPVM/Array.c:    return env->die(env, stack, "$dest_offset + $length must be less than or equal to the length of $dest.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$source_offset + $length must be less than or equal to the length of $source.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$prototype array must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "$length must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:  void* new_object_array = env->new_array_proto(env, stack, array, length);
lib/SPVM/Array.c:    return env->die(env, stack, "The prototype element $prototype_element must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:    return env->die(env, stack, "The length $length must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Array.c:  void* new_object_array = env->new_array_proto_element(env, stack, element, length);
lib/SPVM/Fn.c:  void* utf8_string = env->new_string(env, stack, (char*)utf8_bytes, utf8_bytes_length);
lib/SPVM/Fn.c:    return env->die(env, stack, "$string must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "$offset must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  const char* string = env->get_chars(env, stack, obj_string);
lib/SPVM/Fn.c:  int32_t string_len = env->length(env, stack, obj_string);
lib/SPVM/Fn.c:    return env->die(env, stack, "The value of $offset must be less than the length of $string.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    env->die(env, stack, "An invalid UTF-8 is gotten.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    int32_t error_id_unicode_invalid_utf8 = env->get_basic_type_id_by_name(env, stack, "Error::Unicode::InvalidUTF8", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  if (env->is_array(env, stack, object)) {
lib/SPVM/Fn.c:  if (env->is_class(env, stack, object)) {
lib/SPVM/Fn.c:  if (env->is_mulnum_array(env, stack, object)) {
lib/SPVM/Fn.c:  if (env->is_numeric_array(env, stack, object)) {
lib/SPVM/Fn.c:  if (env->is_object_array(env, stack, object)) {
lib/SPVM/Fn.c:  if (env->is_pointer_class(env, stack, object)) {
lib/SPVM/Fn.c:    return env->die(env, stack, "$dest must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  if (!(env->is_string(env, stack, obj_dest) || env->is_numeric_array(env, stack, obj_dest) || env->is_mulnum_array(env, stack, obj_dest))) {
lib/SPVM/Fn.c:    return env->die(env, stack, "$type of $dest must be $string type, $numeric array type, or $multi numeric array type.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "$source must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  if (!(env->is_string(env, stack, obj_source) || env->is_numeric_array(env, stack, obj_source) || env->is_mulnum_array(env, stack, obj_source))) {
lib/SPVM/Fn.c:    return env->die(env, stack, "$type of $source must be $string type, $numeric array type, or $multi numeric array type.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  if (env->is_read_only(env, stack, obj_dest)) {
lib/SPVM/Fn.c:    return env->die(env, stack, "$dest cannnot be be a read-only string.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "$length must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  char* dest = (char*)env->get_chars(env, stack, obj_dest);
lib/SPVM/Fn.c:  int32_t dest_length = env->length(env, stack, obj_dest);
lib/SPVM/Fn.c:  int32_t dest_elem_size = env->get_elem_size(env, stack, obj_dest);
lib/SPVM/Fn.c:    return env->die(env, stack, "$offset of $obj_dest + $length must be less than or equal to the length of $obj_dest.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  const char* source = env->get_chars(env, stack, obj_source);
lib/SPVM/Fn.c:  int32_t source_length = env->length(env, stack, obj_source);
lib/SPVM/Fn.c:  int32_t source_elem_size = env->get_elem_size(env, stack, obj_source);
lib/SPVM/Fn.c:    return env->die(env, stack, "$offset of $obj_source + $length must be less than or equal to the length of $obj_source.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "$dest must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  if (!(env->is_string(env, stack, obj_dest) || env->is_numeric_array(env, stack, obj_dest) || env->is_mulnum_array(env, stack, obj_dest))) {
lib/SPVM/Fn.c:    return env->die(env, stack, "$type of $dest must be $string type, $numeric array type, or $multi numeric array type.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "$source must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  if (!(env->is_string(env, stack, obj_source) || env->is_numeric_array(env, stack, obj_source) || env->is_mulnum_array(env, stack, obj_source))) {
lib/SPVM/Fn.c:    return env->die(env, stack, "$type of $source must be $string type, $numeric array type, or $multi numeric array type.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  if (env->is_read_only(env, stack, obj_dest)) {
lib/SPVM/Fn.c:    return env->die(env, stack, "$dest must not be a read-only string.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "$length must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  char* dest = (char*)env->get_chars(env, stack, obj_dest);
lib/SPVM/Fn.c:  int32_t dest_length = env->length(env, stack, obj_dest);
lib/SPVM/Fn.c:  int32_t dest_elem_size = env->get_elem_size(env, stack, obj_dest);
lib/SPVM/Fn.c:    return env->die(env, stack, "$offset of $obj_dest + $length must be less than or equal to the length of $obj_dest.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  const char* source = env->get_chars(env, stack, obj_source);
lib/SPVM/Fn.c:  int32_t source_length = env->length(env, stack, obj_source);
lib/SPVM/Fn.c:  int32_t source_elem_size = env->get_elem_size(env, stack, obj_source);
lib/SPVM/Fn.c:    return env->die(env, stack, "$offset of $obj_source + $length must be less than or equal to the length of $obj_source.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "$string must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "$length must be greater than or equal to 0.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  env->shorten(env, stack, string, length);
lib/SPVM/Fn.c:    return env->die(env, stack, "$string must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  const char* string = env->get_chars(env, stack, obj_string);
lib/SPVM/Fn.c:    return env->die(env, stack, "$string must be the string that can be parsed as a double number.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "$string must be a double number in $correct range.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "$string must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  const char* string = env->get_chars(env, stack, obj_string);
lib/SPVM/Fn.c:    return env->die(env, stack, "$string must be the string that can be parsed as a float number.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "$string must be a float number in $correct range.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "$string must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "$digit must be one of 2, 8, 10, or 16.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  const char* string = env->get_chars(env, stack, obj_string);
lib/SPVM/Fn.c:    return env->die(env, stack, "$string must be the string that can be parsed as a %d-digit 32-bit integer", digit, __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "$string must be a 32-bit integer in $correct range.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "$string must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "$digit must be one of 2, 8, 10, or 16.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  const char* string = env->get_chars(env, stack, obj_string);
lib/SPVM/Fn.c:    return env->die(env, stack, "$string must be the string that can be parsed as a %d-digit 64-bit integer", digit, __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "$string must be a 64-bit integer in $correct range.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "$basic_type_name must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  const char* basic_type_name = env->get_chars(env, stack, obj_basic_type_name);
lib/SPVM/Fn.c:  void* basic_type = env->api->runtime->get_basic_type_by_name(env->runtime, basic_type_name);
lib/SPVM/Fn.c:    return env->die(env, stack, "The class specified by $basic_type_name must be loaded.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  const char* version_string = env->get_version_string(env, stack, basic_type);
lib/SPVM/Fn.c:    obj_version_string = env->new_string(env, stack, version_string, strlen(version_string));
lib/SPVM/Fn.c:  double spvm_version_number = env->get_spvm_version_number(env, stack);
lib/SPVM/Fn.c:    return env->die(env, stack, "$basic_type_name must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  const char* basic_type_name = env->get_chars(env, stack, obj_basic_type_name);
lib/SPVM/Fn.c:  void* basic_type = env->api->runtime->get_basic_type_by_name(env->runtime, basic_type_name);
lib/SPVM/Fn.c:    return env->die(env, stack, "The class specified by $basic_type_name must be loaded.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  double version_number = env->get_version_number(env, stack, basic_type);
lib/SPVM/Fn.c:  const char* spvm_version = env->get_spvm_version_string(env, stack);
lib/SPVM/Fn.c:  void* obj_spvm_version = env->new_string(env, stack, spvm_version, strlen(spvm_version));
lib/SPVM/Fn.c:  int32_t memory_blocks_count = env->get_memory_blocks_count(env, stack);
lib/SPVM/Fn.c:    return env->die(env, stack, "$basic_type_name must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  const char* basic_type_name = env->get_chars(env, stack, obj_basic_type_name);
lib/SPVM/Fn.c:  int32_t basic_type_id = env->get_basic_type_id(env, stack, basic_type_name);
lib/SPVM/Fn.c:    return env->die(env, stack, "The basic type \"%s\" is not found.", basic_type_name, __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:    return env->die(env, stack, "The basic type name $basic_type_name must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  const char* basic_type_name = env->get_chars(env, stack, obj_basic_type_name);
lib/SPVM/Fn.c:    return env->die(env, stack, "The type dimension $type_dimension must be grether than or equal to 0 and less than or equal to 255.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Fn.c:  void* obj_compile_type_name = env->get_compile_type_name(env, stack, basic_type_name, type_dimension, type_flag);
lib/SPVM/Sync/Mutex.c:  void* mutex = env->api->mutex->new_instance(env, stack);
lib/SPVM/Sync/Mutex.c:  void* obj_mutex = env->new_pointer_object_by_name(env, stack, "Sync::Mutex", mutex, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Sync/Mutex.c:  void* mutex = env->get_pointer(env, stack, obj_mutex);
lib/SPVM/Sync/Mutex.c:  env->api->mutex->free_instance(env, stack, mutex);
lib/SPVM/Sync/Mutex.c:  void* mutex = env->get_pointer(env, stack, obj_mutex);
lib/SPVM/Sync/Mutex.c:  env->api->mutex->lock(env, stack, mutex);
lib/SPVM/Sync/Mutex.c:  void* mutex = env->get_pointer(env, stack, obj_mutex);
lib/SPVM/Sync/Mutex.c:  env->api->mutex->unlock(env, stack, mutex);
lib/SPVM/Sync/Mutex.c:  void* mutex = env->get_pointer(env, stack, obj_mutex);
lib/SPVM/Sync/Mutex.c:  env->api->mutex->reader_lock(env, stack, mutex);
lib/SPVM/Sync/Mutex.c:  void* mutex = env->get_pointer(env, stack, obj_mutex);
lib/SPVM/Sync/Mutex.c:  env->api->mutex->reader_unlock(env, stack, mutex);
lib/SPVM/Native/Stack.c:  int32_t no_destroy = env->get_field_byte_by_name(env, stack, obj_self, "no_destroy", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Stack.c:    void* obj_my_env = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "env", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Stack.c:    SPVM_ENV* my_env = env->get_pointer(env, stack, obj_my_env);
lib/SPVM/Native/Stack.c:    void* my_stack= env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Stack.c:    my_env->free_stack(my_env, my_stack);
lib/SPVM/Native/Method.c:  void* obj_runtime = env->get_field_object_by_name(env, stack, object, field_name, error_id, func_name, file_name, line);
lib/SPVM/Native/Method.c:    *error_id = env->die(env, stack, "The %s cannot be got.", field_name, func_name, file_name, line);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:    *error_id = env->die(env, stack, "The pointer to the native %s cannot be got.", field_name, func_name, file_name, line);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  int32_t index = env->api->method->get_index(runtime, method);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  const char* name = env->api->method->get_name(runtime, method);
lib/SPVM/Native/Method.c:  void* obj_name = env->new_string_nolen(env, stack, name);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  void* basic_type = env->api->method->get_return_basic_type(runtime, method);
lib/SPVM/Native/Method.c:  void* obj_basic_type = env->new_pointer_object_by_name(env, stack, "Native::BasicType", basic_type, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Method.c:  env->set_field_object_by_name(env, stack, obj_basic_type, "runtime", obj_self, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  int32_t type_dimension = env->api->method->get_return_type_dimension(runtime, method);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  int32_t type_flag = env->api->method->get_return_type_flag(runtime, method);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  void* current_basic_type = env->api->method->get_current_basic_type(runtime, method);
lib/SPVM/Native/Method.c:  void* obj_current_basic_type = env->new_pointer_object_by_name(env, stack, "Native::BasicType", current_basic_type, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Method.c:  env->set_field_object_by_name(env, stack, obj_current_basic_type, "runtime", obj_self, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  void* arg = env->api->method->get_arg_by_index(runtime, method, arg_index);
lib/SPVM/Native/Method.c:    return env->die(env, stack, "The argument is not found.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Method.c:  void* obj_arg = env->new_pointer_object_by_name(env, stack, "Native::Arg", arg, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Method.c:  env->set_field_object_by_name(env, stack, obj_arg, "runtime", obj_self, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  int32_t get_args_length = env->api->method->get_args_length(runtime, method);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  int32_t get_required_args_length = env->api->method->get_required_args_length(runtime, method);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  int32_t is_class_method = env->api->method->is_class_method(runtime, method);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  int32_t is_anon = env->api->method->is_anon(runtime, method);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  int32_t is_native = env->api->method->is_native(runtime, method);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  int32_t is_precompile = env->api->method->is_precompile(runtime, method);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  int32_t is_enum = env->api->method->is_enum(runtime, method);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  void* native_address = env->api->method->get_native_address(runtime, method);
lib/SPVM/Native/Method.c:  void* obj_native_address = env->new_pointer_object_by_name(env, stack, "Address", native_address, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* native_address = env->get_pointer(env, stack, obj_native_address);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  env->api->method->set_native_address(runtime, method, native_address);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  void* Precompile_address = env->api->method->get_precompile_address(runtime, method);
lib/SPVM/Native/Method.c:  void* obj_precompile_address = env->new_pointer_object_by_name(env, stack, "Address", Precompile_address, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* precompile_address = env->get_pointer(env, stack, obj_precompile_address);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  env->api->method->set_precompile_address(runtime, method, precompile_address);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  int32_t is_precompile = env->api->method->is_precompile_fallback(runtime, method);
lib/SPVM/Native/Method.c:  void* method = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Method.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Method.c:  env->api->method->set_is_precompile_fallback(runtime, method, is_precompile_fallback);
lib/SPVM/Native/ClassVar.c:  void* class_var = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/ClassVar.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassVar.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/ClassVar.c:  int32_t index = env->api->class_var->get_index(runtime, class_var);
lib/SPVM/Native/ClassVar.c:  void* class_var = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/ClassVar.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassVar.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/ClassVar.c:  const char* name = env->api->class_var->get_name(runtime, class_var);
lib/SPVM/Native/ClassVar.c:  void* obj_name = env->new_string_nolen(env, stack, name);
lib/SPVM/Native/ClassVar.c:  void* class_var = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/ClassVar.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassVar.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/ClassVar.c:  void* basic_type = env->api->class_var->get_basic_type(runtime, class_var);
lib/SPVM/Native/ClassVar.c:  void* obj_basic_type = env->new_pointer_object_by_name(env, stack, "Native::BasicType", basic_type, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassVar.c:  env->set_field_object_by_name(env, stack, obj_basic_type, "runtime", obj_self, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassVar.c:  void* class_var = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/ClassVar.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassVar.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/ClassVar.c:  int32_t type_dimension = env->api->class_var->get_type_dimension(runtime, class_var);
lib/SPVM/Native/ClassVar.c:  void* class_var = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/ClassVar.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassVar.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/ClassVar.c:  int32_t type_flag = env->api->class_var->get_type_flag(runtime, class_var);
lib/SPVM/Native/ClassVar.c:  void* class_var = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/ClassVar.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassVar.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/ClassVar.c:  void* current_basic_type = env->api->class_var->get_current_basic_type(runtime, class_var);
lib/SPVM/Native/ClassVar.c:  void* obj_current_basic_type = env->new_pointer_object_by_name(env, stack, "Native::BasicType", current_basic_type, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassVar.c:  env->set_field_object_by_name(env, stack, obj_current_basic_type, "runtime", obj_self, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassFile.c:  void* class_file = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/ClassFile.c:  void* obj_compiler = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "compiler", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassFile.c:  void* compiler = env->get_pointer(env, stack, obj_compiler);
lib/SPVM/Native/ClassFile.c:  const char* class_name = env->api->class_file->get_class_name(compiler, class_file);
lib/SPVM/Native/ClassFile.c:  void* obj_class_name = env->new_string_nolen(env, stack, class_name);
lib/SPVM/Native/ClassFile.c:  void* class_file = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/ClassFile.c:  void* obj_compiler = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "compiler", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassFile.c:  void* compiler = env->get_pointer(env, stack, obj_compiler);
lib/SPVM/Native/ClassFile.c:  const char* file = env->api->class_file->get_file(compiler, class_file);
lib/SPVM/Native/ClassFile.c:  void* obj_file = env->new_string_nolen(env, stack, file);
lib/SPVM/Native/ClassFile.c:  void* class_file = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/ClassFile.c:  void* obj_compiler = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "compiler", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassFile.c:  void* compiler = env->get_pointer(env, stack, obj_compiler);
lib/SPVM/Native/ClassFile.c:    file = env->get_chars(env, stack, obj_file);
lib/SPVM/Native/ClassFile.c:  env->api->class_file->set_file(compiler, class_file, file);
lib/SPVM/Native/ClassFile.c:  void* class_file = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/ClassFile.c:  void* obj_compiler = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "compiler", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassFile.c:  void* compiler = env->get_pointer(env, stack, obj_compiler);
lib/SPVM/Native/ClassFile.c:  const char* dir = env->api->class_file->get_dir(compiler, class_file);
lib/SPVM/Native/ClassFile.c:  void* obj_dir = env->new_string_nolen(env, stack, dir);
lib/SPVM/Native/ClassFile.c:  void* class_file = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/ClassFile.c:  void* obj_compiler = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "compiler", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassFile.c:  void* compiler = env->get_pointer(env, stack, obj_compiler);
lib/SPVM/Native/ClassFile.c:    dir = env->get_chars(env, stack, obj_dir);
lib/SPVM/Native/ClassFile.c:  env->api->class_file->set_dir(compiler, class_file, dir);
lib/SPVM/Native/ClassFile.c:  void* class_file = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/ClassFile.c:  void* obj_compiler = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "compiler", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassFile.c:  void* compiler = env->get_pointer(env, stack, obj_compiler);
lib/SPVM/Native/ClassFile.c:  const char* rel_file = env->api->class_file->get_rel_file(compiler, class_file);
lib/SPVM/Native/ClassFile.c:  void* obj_rel_file = env->new_string_nolen(env, stack, rel_file);
lib/SPVM/Native/ClassFile.c:  void* class_file = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/ClassFile.c:  void* obj_compiler = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "compiler", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassFile.c:  void* compiler = env->get_pointer(env, stack, obj_compiler);
lib/SPVM/Native/ClassFile.c:    rel_file = env->get_chars(env, stack, obj_rel_file);
lib/SPVM/Native/ClassFile.c:  env->api->class_file->set_rel_file(compiler, class_file, rel_file);
lib/SPVM/Native/ClassFile.c:  void* class_file = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/ClassFile.c:  void* obj_compiler = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "compiler", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassFile.c:  void* compiler = env->get_pointer(env, stack, obj_compiler);
lib/SPVM/Native/ClassFile.c:  const char* content = env->api->class_file->get_content(compiler, class_file);
lib/SPVM/Native/ClassFile.c:  void* obj_content = env->new_string_nolen(env, stack, content);
lib/SPVM/Native/ClassFile.c:  void* class_file = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/ClassFile.c:  void* obj_compiler = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "compiler", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassFile.c:  void* compiler = env->get_pointer(env, stack, obj_compiler);
lib/SPVM/Native/ClassFile.c:    content = env->get_chars(env, stack, obj_content);
lib/SPVM/Native/ClassFile.c:  env->api->class_file->set_content(compiler, class_file, content);
lib/SPVM/Native/ClassFile.c:  void* class_file = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/ClassFile.c:  void* obj_compiler = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "compiler", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassFile.c:  void* compiler = env->get_pointer(env, stack, obj_compiler);
lib/SPVM/Native/ClassFile.c:  int32_t content_length = env->api->class_file->get_content_length(compiler, class_file);
lib/SPVM/Native/ClassFile.c:  void* class_file = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/ClassFile.c:  void* obj_compiler = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "compiler", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/ClassFile.c:  void* compiler = env->get_pointer(env, stack, obj_compiler);
lib/SPVM/Native/ClassFile.c:  env->api->class_file->set_content_length(compiler, class_file, content_length);
lib/SPVM/Native/Field.c:  void* field = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Field.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Field.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Field.c:  int32_t index = env->api->field->get_index(runtime, field);
lib/SPVM/Native/Field.c:  void* field = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Field.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Field.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Field.c:  const char* name = env->api->field->get_name(runtime, field);
lib/SPVM/Native/Field.c:  void* obj_name = env->new_string_nolen(env, stack, name);
lib/SPVM/Native/Field.c:  void* field = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Field.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Field.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Field.c:  void* basic_type = env->api->field->get_basic_type(runtime, field);
lib/SPVM/Native/Field.c:  void* obj_basic_type = env->new_pointer_object_by_name(env, stack, "Native::BasicType", basic_type, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Field.c:  env->set_field_object_by_name(env, stack, obj_basic_type, "runtime", obj_self, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Field.c:  void* field = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Field.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Field.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Field.c:  int32_t type_dimension = env->api->field->get_type_dimension(runtime, field);
lib/SPVM/Native/Field.c:  void* field = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Field.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Field.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Field.c:  int32_t type_flag = env->api->field->get_type_flag(runtime, field);
lib/SPVM/Native/Field.c:  void* field = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Field.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Field.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Field.c:  void* current_basic_type = env->api->field->get_current_basic_type(runtime, field);
lib/SPVM/Native/Field.c:  void* obj_current_basic_type = env->new_pointer_object_by_name(env, stack, "Native::BasicType", current_basic_type, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Field.c:  env->set_field_object_by_name(env, stack, obj_current_basic_type, "runtime", obj_self, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Env.pm:  my $stack = $env->new_stack;
lib/SPVM/Native/Arg.c:  void* arg = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Arg.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Arg.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Arg.c:  int32_t index = env->api->arg->get_index(runtime, arg);
lib/SPVM/Native/Arg.c:  void* arg = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Arg.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Arg.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Arg.c:  void* basic_type = env->api->arg->get_basic_type(runtime, arg);
lib/SPVM/Native/Arg.c:  void* obj_basic_type = env->new_pointer_object_by_name(env, stack, "Native::BasicType", basic_type, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Arg.c:  env->set_field_object_by_name(env, stack, obj_basic_type, "runtime", obj_self, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Arg.c:  void* arg = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Arg.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Arg.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Arg.c:  int32_t type_dimension = env->api->arg->get_type_dimension(runtime, arg);
lib/SPVM/Native/Arg.c:  void* arg = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Arg.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Arg.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/Arg.c:  int32_t type_flag = env->api->arg->get_type_flag(runtime, arg);
lib/SPVM/Native/API.c:  void* obj_self= env->new_object_by_name(env, stack, "Native::API", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/API.c:    return env->die(env, stack, "The runtime environemnt $env must be defined.", __func__, __FILE__, __LINE__);
lib/SPVM/Native/API.c:  SPVM_ENV* api_env = env->get_pointer(env, stack, obj_api_env);
lib/SPVM/Native/API.c:  env->set_field_object_by_name(env, stack, obj_self, "env", obj_api_env, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/API.c:    return env->die(env, stack, "The runtime stack $stack must be defined.", __func__, __FILE__, __LINE__);
lib/SPVM/Native/API.c:  SPVM_VALUE* api_stack = env->get_pointer(env, stack, obj_api_stack);
lib/SPVM/Native/API.c:  env->set_field_object_by_name(env, stack, obj_self, "stack", obj_api_stack, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/API.c:  int32_t check_ok = env->check_stack_env(api_env, api_stack);
lib/SPVM/Native/API.c:    return env->die(env, stack, "The runtime stack $stack must be created by the runtime environemnt $env.", __func__, __FILE__, __LINE__);
lib/SPVM/Native/API.c:  void* obj_api_env = env->get_field_object_by_name(env, stack, obj_self, "env", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/API.c:  SPVM_ENV* api_env = env->get_pointer(env, stack, obj_api_env);
lib/SPVM/Native/API.c:  void* obj_api_stack = env->get_field_object_by_name(env, stack, obj_self, "stack", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/API.c:  SPVM_VALUE* api_stack = env->get_pointer(env, stack, obj_api_stack);
lib/SPVM/Native/API.c:  api_env->call_init_methods(api_env, api_stack);
lib/SPVM/Native/API.c:  void* obj_api_env = env->get_field_object_by_name(env, stack, obj_self, "env", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/API.c:  SPVM_ENV* api_env = env->get_pointer(env, stack, obj_api_env);
lib/SPVM/Native/API.c:  void* obj_api_stack = env->get_field_object_by_name(env, stack, obj_self, "stack", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/API.c:  SPVM_VALUE* api_stack = env->get_pointer(env, stack, obj_api_stack);
lib/SPVM/Native/API.c:  api_env->destroy_class_vars(api_env, api_stack);
lib/SPVM/Native/API.c:  void* obj_api_env = env->get_field_object_by_name(env, stack, obj_self, "env", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/API.c:  SPVM_ENV* api_env = env->get_pointer(env, stack, obj_api_env);
lib/SPVM/Native/API.c:  void* obj_api_stack = env->get_field_object_by_name(env, stack, obj_self, "stack", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/API.c:  SPVM_VALUE* api_stack = env->get_pointer(env, stack, obj_api_stack);
lib/SPVM/Native/API.c:  error_id = api_env->set_command_info_program_name(api_env, api_stack, obj_program_name);
lib/SPVM/Native/API.c:  void* obj_api_env = env->get_field_object_by_name(env, stack, obj_self, "env", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/API.c:  SPVM_ENV* api_env = env->get_pointer(env, stack, obj_api_env);
lib/SPVM/Native/API.c:  void* obj_api_stack = env->get_field_object_by_name(env, stack, obj_self, "stack", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/API.c:  SPVM_VALUE* api_stack = env->get_pointer(env, stack, obj_api_stack);
lib/SPVM/Native/API.c:  error_id = api_env->set_command_info_argv(api_env, api_stack, obj_argv);
lib/SPVM/Native/API.c:  void* obj_api_env = env->get_field_object_by_name(env, stack, obj_self, "env", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/API.c:  SPVM_ENV* api_env = env->get_pointer(env, stack, obj_api_env);
lib/SPVM/Native/API.c:  void* obj_api_stack = env->get_field_object_by_name(env, stack, obj_self, "stack", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/API.c:  SPVM_VALUE* api_stack = env->get_pointer(env, stack, obj_api_stack);
lib/SPVM/Native/API.c:  error_id = api_env->set_command_info_base_time(api_env, api_stack, base_time);
lib/SPVM/Native/API.c:  void* obj_api_env = env->get_field_object_by_name(env, stack, obj_self, "env", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/API.c:  SPVM_ENV* api_env = env->get_pointer(env, stack, obj_api_env);
lib/SPVM/Native/API.c:  void* obj_api_stack = env->get_field_object_by_name(env, stack, obj_self, "stack", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/API.c:  SPVM_VALUE* api_stack = env->get_pointer(env, stack, obj_api_stack);
lib/SPVM/Native/API.c:  void* obj_exception = api_env->get_exception(api_env, api_stack);
lib/SPVM/Native/API.c:  env->set_exception(env, stack, obj_exception);
lib/SPVM/Native/Stack.pm:  my $stack = $env->new_stack;
lib/SPVM/Native/Runtime.pm:  my $stack = $env->new_stack;
lib/SPVM/Native/Env.c:  SPVM_ENV* my_env = env->get_pointer(my_env, stack, obj_my_env);
lib/SPVM/Native/Env.c:  SPVM_VALUE* my_stack = my_env->new_stack(my_env);
lib/SPVM/Native/Env.c:  void* obj_self= env->new_pointer_object_by_name(env, stack, "Native::Stack", my_stack, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Env.c:  env->set_field_object_by_name(env, stack, obj_self, "env", obj_my_env, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Env.c:  int32_t no_destroy = env->get_field_byte_by_name(env, stack, obj_self, "no_destroy", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Env.c:    SPVM_ENV* my_env = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Env.c:    my_env->free_env(my_env);
lib/SPVM/Native/Runtime.c:  void* runtime = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Runtime.c:  void* basic_type = env->get_pointer(env, stack, obj_basic_type);
lib/SPVM/Native/Runtime.c:  void* allocator = env->api->allocator->new_instance();
lib/SPVM/Native/Runtime.c:  void* string_buffer = env->api->string_buffer->new_instance(allocator, 0);
lib/SPVM/Native/Runtime.c:  env->api->runtime->build_precompile_class_source(runtime, string_buffer, basic_type);
lib/SPVM/Native/Runtime.c:  const char* string_buffer_value = env->api->string_buffer->get_string(string_buffer);
lib/SPVM/Native/Runtime.c:  int32_t string_buffer_length = env->api->string_buffer->get_length(string_buffer);
lib/SPVM/Native/Runtime.c:  void* obj_precompile_source = env->new_string(env, stack, string_buffer_value, string_buffer_length);
lib/SPVM/Native/Runtime.c:  env->api->string_buffer->free_instance(string_buffer);
lib/SPVM/Native/Runtime.c:  env->api->allocator->free_instance(allocator);
lib/SPVM/Native/Runtime.c:  void* runtime = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Runtime.c:  void* method = env->get_pointer(env, stack, obj_method);
lib/SPVM/Native/Runtime.c:  void* allocator = env->api->allocator->new_instance();
lib/SPVM/Native/Runtime.c:  void* string_buffer = env->api->string_buffer->new_instance(allocator, 0);
lib/SPVM/Native/Runtime.c:  env->api->runtime->build_precompile_method_source(runtime, string_buffer, method);
lib/SPVM/Native/Runtime.c:  const char* string_buffer_value = env->api->string_buffer->get_string(string_buffer);
lib/SPVM/Native/Runtime.c:  int32_t string_buffer_length = env->api->string_buffer->get_length(string_buffer);
lib/SPVM/Native/Runtime.c:  void* obj_precompile_method_source = env->new_string(env, stack, string_buffer_value, string_buffer_length);
lib/SPVM/Native/Runtime.c:  env->api->string_buffer->free_instance(string_buffer);
lib/SPVM/Native/Runtime.c:  env->api->allocator->free_instance(allocator);
lib/SPVM/Native/Runtime.c:  const char* basic_type_name = env->get_chars(env, stack, obj_basic_type_name);
lib/SPVM/Native/Runtime.c:  const char* method_name = env->get_chars(env, stack, obj_method_name);
lib/SPVM/Native/Runtime.c:  void* runtime = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Runtime.c:  void* basic_type = env->api->runtime->get_basic_type_by_name(runtime, basic_type_name);
lib/SPVM/Native/Runtime.c:  void* method = env->api->basic_type->get_method_by_name(runtime, basic_type, method_name);
lib/SPVM/Native/Runtime.c:  void* address = env->get_pointer(env, stack, obj_address);
lib/SPVM/Native/Runtime.c:  env->api->method->set_native_address(runtime, method, address);
lib/SPVM/Native/Runtime.c:  void* runtime = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Runtime.c:  const char* basic_type_name = env->get_chars(env, stack, obj_basic_type_name);
lib/SPVM/Native/Runtime.c:  const char* method_name = env->get_chars(env, stack, obj_method_name);
lib/SPVM/Native/Runtime.c:  void* basic_type = env->api->runtime->get_basic_type_by_name(runtime, basic_type_name);
lib/SPVM/Native/Runtime.c:  void* method = env->api->basic_type->get_method_by_name(runtime, basic_type, method_name);
lib/SPVM/Native/Runtime.c:  void* address = env->api->method->get_native_address(runtime, method);
lib/SPVM/Native/Runtime.c:  void* obj_address = env->new_pointer_object_by_name(env, stack, "Native::Address", address, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Runtime.c:  void* runtime = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Runtime.c:  const char* basic_type_name = env->get_chars(env, stack, obj_basic_type_name);
lib/SPVM/Native/Runtime.c:  const char* method_name = env->get_chars(env, stack, obj_method_name);
lib/SPVM/Native/Runtime.c:  void* basic_type = env->api->runtime->get_basic_type_by_name(runtime, basic_type_name);
lib/SPVM/Native/Runtime.c:  void* method = env->api->basic_type->get_method_by_name(runtime, basic_type, method_name);
lib/SPVM/Native/Runtime.c:  int32_t is_class_method = env->api->method->is_class_method(runtime, method);
lib/SPVM/Native/Runtime.c:  void* runtime = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Runtime.c:  const char* basic_type_name = env->get_chars(env, stack, obj_basic_type_name);
lib/SPVM/Native/Runtime.c:  const char* method_name = env->get_chars(env, stack, obj_method_name);
lib/SPVM/Native/Runtime.c:  void* basic_type = env->api->runtime->get_basic_type_by_name(runtime, basic_type_name);
lib/SPVM/Native/Runtime.c:  void* method = env->api->basic_type->get_method_by_name(runtime, basic_type, method_name);
lib/SPVM/Native/Runtime.c:  void* address = env->api->method->get_precompile_address(runtime, method);
lib/SPVM/Native/Runtime.c:  void* obj_address = env->new_pointer_object_by_name(env, stack, "Native::Address", address, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Runtime.c:  const char* basic_type_name = env->get_chars(env, stack, obj_basic_type_name);
lib/SPVM/Native/Runtime.c:  const char* method_name = env->get_chars(env, stack, obj_method_name);
lib/SPVM/Native/Runtime.c:  void* runtime = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Runtime.c:  void* basic_type = env->api->runtime->get_basic_type_by_name(runtime, basic_type_name);
lib/SPVM/Native/Runtime.c:  void* method = env->api->basic_type->get_method_by_name(runtime, basic_type, method_name);
lib/SPVM/Native/Runtime.c:  void* address = env->get_pointer(env, stack, obj_address);
lib/SPVM/Native/Runtime.c:  env->api->method->set_precompile_address(runtime, method, address);
lib/SPVM/Native/Runtime.c:  void* runtime = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Runtime.c:  int32_t basic_types_length = env->api->runtime->get_basic_types_length(runtime);
lib/SPVM/Native/Runtime.c:  void* runtime = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Runtime.c:  void* basic_type = env->api->runtime->get_basic_type_by_id(runtime, index);
lib/SPVM/Native/Runtime.c:    return env->die(env, stack, "The basic type cannot be found.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Runtime.c:  void* obj_basic_type = env->new_pointer_object_by_name(env, stack, "Native::BasicType", basic_type, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Runtime.c:  env->set_field_object_by_name(env, stack, obj_basic_type, "runtime", obj_self, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Runtime.c:    return env->die(env, stack, "The basic type cannot be found.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Runtime.c:  const char* name = env->get_chars(env, stack, obj_name);
lib/SPVM/Native/Runtime.c:  void* runtime = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Runtime.c:  void* basic_type = env->api->runtime->get_basic_type_by_name(runtime, name);
lib/SPVM/Native/Runtime.c:    return env->die(env, stack, "The basic type cannot be found.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Runtime.c:  void* obj_basic_type = env->new_pointer_object_by_name(env, stack, "Native::BasicType", basic_type, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Runtime.c:  env->set_field_object_by_name(env, stack, obj_basic_type, "runtime", obj_self, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Runtime.c:  const char* basic_type_name = env->get_chars(env, stack, obj_basic_type_name);
lib/SPVM/Native/Runtime.c:  void* runtime = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Runtime.c:  void* basic_type = env->api->runtime->get_basic_type_by_name(runtime, basic_type_name);
lib/SPVM/Native/Runtime.c:  void* parent_basic_type = env->api->basic_type->get_parent(runtime, basic_type);
lib/SPVM/Native/Runtime.c:    const char* parent_basic_type_name = env->api->basic_type->get_name(runtime, parent_basic_type);
lib/SPVM/Native/Runtime.c:    obj_parent_basic_type_name = env->new_string_nolen(env, stack, parent_basic_type_name);
lib/SPVM/Native/Runtime.c:  const char* basic_type_name = env->get_chars(env, stack, obj_basic_type_name);
lib/SPVM/Native/Runtime.c:  void* runtime = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Runtime.c:  void* basic_type = env->api->runtime->get_basic_type_by_name(runtime, basic_type_name);
lib/SPVM/Native/Runtime.c:  int32_t methods_length = env->api->basic_type->get_methods_length(runtime, basic_type);
lib/SPVM/Native/Runtime.c:    void* method = env->api->basic_type->get_method_by_index(runtime, basic_type, method_index);
lib/SPVM/Native/Runtime.c:      if (env->api->method->is_native(runtime, method)) {
lib/SPVM/Native/Runtime.c:      if (env->api->method->is_precompile(runtime, method)) {
lib/SPVM/Native/Runtime.c:      if (env->api->method->is_enum(runtime, method)) {
lib/SPVM/Native/Runtime.c:  void* obj_method_names = env->new_string_array(env, stack, match_methodes_length);
lib/SPVM/Native/Runtime.c:    void* method = env->api->basic_type->get_method_by_index(runtime, basic_type, method_index);
lib/SPVM/Native/Runtime.c:      if (env->api->method->is_native(runtime, method)) {
lib/SPVM/Native/Runtime.c:      if (env->api->method->is_precompile(runtime, method)) {
lib/SPVM/Native/Runtime.c:      if (env->api->method->is_enum(runtime, method)) {
lib/SPVM/Native/Runtime.c:      const char* method_name = env->api->method->get_name(runtime, method);
lib/SPVM/Native/Runtime.c:      void* obj_method_name = env->new_string_nolen(env, stack, method_name);
lib/SPVM/Native/Runtime.c:      env->set_elem_object(env, stack, obj_method_names, match_method_index, obj_method_name);
lib/SPVM/Native/Runtime.c:  void* runtime = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Runtime.c:  void* obj_compiler = env->get_field_object_by_name(env, stack, obj_self, "compiler", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Runtime.c:  SPVM_ENV* new_env = env->new_env();
lib/SPVM/Native/Runtime.c:  void* obj_env= env->new_pointer_object_by_name(env, stack, "Native::Env", new_env, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Runtime.c:  void* runtime = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Runtime.c:  env->set_field_object_by_name(env, stack, obj_env, "runtime", obj_self, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Runtime.c:  new_env->runtime = runtime;
lib/SPVM/Native/MethodCall.c:    return env->die(env, stack, "$basic_type_name must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  const char* basic_type_name = env->get_chars(env, stack, obj_basic_type_name);
lib/SPVM/Native/MethodCall.c:    return env->die(env, stack, "$method_name must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  const char* method_name = env->get_chars(env, stack, obj_method_name);
lib/SPVM/Native/MethodCall.c:  void* method = env->get_class_method(env, stack, basic_type_name, method_name);
lib/SPVM/Native/MethodCall.c:    return env->die(env, stack, "The \"%s\" class method in the \"%s\" class cannot be found.", method_name, basic_type_name, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  void* obj_method = env->new_pointer_object_by_name(env, stack, "Native::Method", method, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  void* obj_self = env->new_pointer_object_by_name(env, stack, "Native::MethodCall", method, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  env->set_field_object_by_name(env, stack, obj_self, "method", obj_method, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:    return env->die(env, stack, "$basic_type_name must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  const char* basic_type_name = env->get_chars(env, stack, obj_basic_type_name);
lib/SPVM/Native/MethodCall.c:    return env->die(env, stack, "$method_name must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  const char* method_name = env->get_chars(env, stack, obj_method_name);
lib/SPVM/Native/MethodCall.c:  void* method = env->get_instance_method_static(env, stack, basic_type_name, method_name);
lib/SPVM/Native/MethodCall.c:    return env->die(env, stack, "The \"%s\" instance method in the \"%s\" class cannot be found.", method_name, basic_type_name, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  void* obj_method = env->new_pointer_object_by_name(env, stack, "Native::Method", method, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  void* obj_self = env->new_pointer_object_by_name(env, stack, "Native::MethodCall", method, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  env->set_field_object_by_name(env, stack, obj_self, "method", obj_method, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:    return env->die(env, stack, "$instance must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:    return env->die(env, stack, "$method_name must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  const char* method_name = env->get_chars(env, stack, obj_method_name);
lib/SPVM/Native/MethodCall.c:  void* method = env->get_instance_method(env, stack, obj_instance, method_name);
lib/SPVM/Native/MethodCall.c:    return env->die(env, stack, "The \"%s\" instance method cannot be found.", method_name, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  void* obj_method = env->new_pointer_object_by_name(env, stack, "Native::Method", method, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  void* obj_self = env->new_pointer_object_by_name(env, stack, "Native::MethodCall", method, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  env->set_field_object_by_name(env, stack, obj_self, "method", obj_method, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:    obj_args = env->new_object_array_by_name(env, stack, "object", 0, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  int32_t args_length = env->length(env, stack, obj_args);
lib/SPVM/Native/MethodCall.c:  void* obj_method = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "method", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  void* method = env->get_pointer(env, stack, obj_method);
lib/SPVM/Native/MethodCall.c:  void* runtime = env->runtime;
lib/SPVM/Native/MethodCall.c:  int32_t method_required_args_length = env->api->method->get_required_args_length(runtime, method);
lib/SPVM/Native/MethodCall.c:    return env->die(env, stack, "Too few arguments.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  int32_t method_args_length = env->api->method->get_args_length(runtime, method);
lib/SPVM/Native/MethodCall.c:    return env->die(env, stack, "Too many arguments.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:    void* obj_arg = env->get_elem_object(env, stack, obj_args, arg_index);
lib/SPVM/Native/MethodCall.c:    void* method_arg = env->api->method->get_arg_by_index(runtime, method, arg_index);
lib/SPVM/Native/MethodCall.c:    void* method_arg_basic_type = env->api->arg->get_basic_type(runtime, method_arg);
lib/SPVM/Native/MethodCall.c:    int32_t method_arg_basic_type_id = env->api->basic_type->get_id(runtime, method_arg_basic_type);
lib/SPVM/Native/MethodCall.c:    int32_t method_arg_type_dimension = env->api->arg->get_type_dimension(runtime, method_arg);
lib/SPVM/Native/MethodCall.c:    int32_t method_arg_type_flag = env->api->arg->get_type_flag(runtime, method_arg);
lib/SPVM/Native/MethodCall.c:    int32_t method_arg_basic_type_category = env->api->basic_type->get_category(runtime, method_arg_basic_type);
lib/SPVM/Native/MethodCall.c:    int32_t method_arg_is_object_type = env->api->type->is_object_type(runtime, method_arg_basic_type, method_arg_type_dimension, method_arg_type_flag);
lib/SPVM/Native/MethodCall.c:        void* arg_basic_type = env->get_object_basic_type(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:        const char* arg_basic_type_name = env->api->basic_type->get_name(runtime, arg_basic_type);
lib/SPVM/Native/MethodCall.c:        int32_t arg_type_dimension = env->get_object_type_dimension(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:        int32_t can_assign = env->api->type->can_assign(
lib/SPVM/Native/MethodCall.c:          return env->die(env, stack, "The %dth argument cannot be assigned.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:        return env->die(env, stack, "The %dth argument must be defined.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "Byte", 0)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the Byte class.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              int8_t value = env->get_field_byte_by_name(env, stack, obj_arg, "value", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "Short", 0)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the Short class.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              int16_t value = env->get_field_short_by_name(env, stack, obj_arg, "value", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "Int", 0)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the Int class.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              int32_t value = env->get_field_int_by_name(env, stack, obj_arg, "value", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "Long", 0)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the Long class.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              int64_t value = env->get_field_long_by_name(env, stack, obj_arg, "value", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "Float", 0)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the Float class.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              float value = env->get_field_float_by_name(env, stack, obj_arg, "value", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "Double", 0)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the Double class.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              double value = env->get_field_double_by_name(env, stack, obj_arg, "value", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:          int32_t method_arg_width = env->api->type->get_type_width(runtime, method_arg_basic_type, method_arg_type_dimension, method_arg_type_flag);
lib/SPVM/Native/MethodCall.c:          int32_t arg_array_length = env->length(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:            return env->die(env, stack, "The array length of the %dth argument must be %d.", arg_index + 1, method_arg_width, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:          void* method_arg_mulnum_field = env->api->basic_type->get_field_by_index(runtime, method_arg_basic_type, 0);
lib/SPVM/Native/MethodCall.c:          void* method_arg_mulnum_field_basic_type = env->api->field->get_basic_type(runtime, method_arg_mulnum_field);
lib/SPVM/Native/MethodCall.c:          int32_t method_arg_mulnum_field_basic_type_id = env->api->basic_type->get_id(runtime, method_arg_mulnum_field_basic_type);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "byte", 1)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the byte[] type.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              int8_t* value_ref = env->get_elems_byte(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "short", 1)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the short[] type.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              int16_t* value_ref = env->get_elems_short(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "int", 1)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the int[] type.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              int32_t* value_ref = env->get_elems_int(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "long", 1)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the long[] type.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              int64_t* value_ref = env->get_elems_long(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "float", 1)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the float[] type.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              float* value_ref = env->get_elems_float(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "double", 1)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the double[] type.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              double* value_ref = env->get_elems_double(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:          int32_t arg_array_length = env->length(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:            return env->die(env, stack, "The array length of the %dth argument must be 1.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "byte", 1)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the byte[] type.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              int8_t* value_ref = env->get_elems_byte(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "short", 1)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the short[] type.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              int16_t* value_ref = env->get_elems_short(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "int", 1)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the int[] type.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              int32_t* value_ref = env->get_elems_int(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "long", 1)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the long[] type.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              int64_t* value_ref = env->get_elems_long(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "float", 1)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the float[] type.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              float* value_ref = env->get_elems_float(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "double", 1)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the double[] type.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              double* value_ref = env->get_elems_double(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:          int32_t method_arg_width = env->api->type->get_type_width(runtime, method_arg_basic_type, method_arg_type_dimension, method_arg_type_flag);
lib/SPVM/Native/MethodCall.c:          int32_t arg_array_length = env->length(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:            return env->die(env, stack, "The array length of the %dth argument must be %d.", arg_index + 1, method_arg_width, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:          void* method_arg_mulnum_field = env->api->basic_type->get_field_by_index(runtime, method_arg_basic_type, 0);
lib/SPVM/Native/MethodCall.c:          void* method_arg_mulnum_field_basic_type = env->api->field->get_basic_type(runtime, method_arg_mulnum_field);
lib/SPVM/Native/MethodCall.c:          int32_t method_arg_mulnum_field_basic_type_id = env->api->basic_type->get_id(runtime, method_arg_mulnum_field_basic_type);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "byte", 1)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the byte[] type.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              int8_t* value_ref = env->get_elems_byte(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "short", 1)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the short[] type.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              int16_t* value_ref = env->get_elems_short(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "int", 1)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the int[] type.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              int32_t* value_ref = env->get_elems_int(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "long", 1)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the long[] type.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              int64_t* value_ref = env->get_elems_long(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "float", 1)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the float[] type.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              float* value_ref = env->get_elems_float(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:              if (!env->is_type_by_name(env, stack, obj_arg, "double", 1)) {
lib/SPVM/Native/MethodCall.c:                return env->die(env, stack, "The type of the %dth argument must be the double[] type.", arg_index + 1, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:              double* value_ref = env->get_elems_double(env, stack, obj_arg);
lib/SPVM/Native/MethodCall.c:  error_id = env->call_method(env, stack, method, stack_length);
lib/SPVM/Native/MethodCall.c:  void* method_return_basic_type = env->api->method->get_return_basic_type(runtime, method);
lib/SPVM/Native/MethodCall.c:  int32_t method_return_basic_type_id = env->api->basic_type->get_id(runtime, method_return_basic_type);
lib/SPVM/Native/MethodCall.c:  int32_t method_return_type_dimension = env->api->method->get_return_type_dimension(runtime, method);
lib/SPVM/Native/MethodCall.c:  int32_t method_return_type_flag = env->api->method->get_return_type_flag(runtime, method);
lib/SPVM/Native/MethodCall.c:  int32_t method_return_basic_type_category = env->api->basic_type->get_category(runtime, method_return_basic_type);
lib/SPVM/Native/MethodCall.c:  int32_t method_return_is_object_type = env->api->type->is_object_type(runtime, method_return_basic_type, method_return_type_dimension, method_return_type_flag);
lib/SPVM/Native/MethodCall.c:          env->call_class_method_by_name(env, stack, "Byte", "new", 1, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:          env->call_class_method_by_name(env, stack, "Short", "new", 1, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:          env->call_class_method_by_name(env, stack, "Int", "new", 1, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:          env->call_class_method_by_name(env, stack, "Long", "new", 1, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:          env->call_class_method_by_name(env, stack, "Float", "new", 1, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:          env->call_class_method_by_name(env, stack, "Double", "new", 1, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:      int32_t method_return_width = env->api->type->get_type_width(runtime, method_return_basic_type, method_return_type_dimension, method_return_type_flag);
lib/SPVM/Native/MethodCall.c:      void* method_return_mulnum_field = env->api->basic_type->get_field_by_index(runtime, method_return_basic_type, 0);
lib/SPVM/Native/MethodCall.c:      void* method_return_mulnum_field_basic_type = env->api->field->get_basic_type(runtime, method_return_mulnum_field);
lib/SPVM/Native/MethodCall.c:      int32_t method_return_mulnum_field_basic_type_id = env->api->basic_type->get_id(runtime, method_return_mulnum_field_basic_type);
lib/SPVM/Native/MethodCall.c:          void* obj_return_value = env->new_byte_array(env, stack, method_return_width);
lib/SPVM/Native/MethodCall.c:          int8_t* return_value_ref = env->get_elems_byte(env, stack, obj_return_value);
lib/SPVM/Native/MethodCall.c:          void* obj_return_value = env->new_short_array(env, stack, method_return_width);
lib/SPVM/Native/MethodCall.c:          int16_t* return_value_ref = env->get_elems_short(env, stack, obj_return_value);
lib/SPVM/Native/MethodCall.c:          void* obj_return_value = env->new_int_array(env, stack, method_return_width);
lib/SPVM/Native/MethodCall.c:          int32_t* return_value_ref = env->get_elems_int(env, stack, obj_return_value);
lib/SPVM/Native/MethodCall.c:          void* obj_return_value = env->new_long_array(env, stack, method_return_width);
lib/SPVM/Native/MethodCall.c:          int64_t* return_value_ref = env->get_elems_long(env, stack, obj_return_value);
lib/SPVM/Native/MethodCall.c:          void* obj_return_value = env->new_float_array(env, stack, method_return_width);
lib/SPVM/Native/MethodCall.c:          float* return_value_ref = env->get_elems_float(env, stack, obj_return_value);
lib/SPVM/Native/MethodCall.c:          void* obj_return_value = env->new_double_array(env, stack, method_return_width);
lib/SPVM/Native/MethodCall.c:          double* return_value_ref = env->get_elems_double(env, stack, obj_return_value);
lib/SPVM/Native/MethodCall.c:    return current_env->die(current_env, current_stack, "$callback must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:    stack = current_env->get_pointer(current_env, current_stack, obj_stack);
lib/SPVM/Native/MethodCall.c:  int32_t is_valid_env = env->check_stack_env(env, stack);
lib/SPVM/Native/MethodCall.c:    return current_env->die(current_env, current_stack, "The environment of $stack is not equal to the current environment.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  env->call_instance_method_by_name(env, stack, "", 0, error_id_ref, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:    return current_env->die(current_env, current_stack, "$basic_type_name must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  const char* basic_type_name = current_env->get_chars(current_env, current_stack, obj_basic_type_name);
lib/SPVM/Native/MethodCall.c:    return current_env->die(current_env, current_stack, "$method_name must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  const char* method_name = current_env->get_chars(current_env, current_stack, obj_method_name);
lib/SPVM/Native/MethodCall.c:    stack = current_env->get_pointer(current_env, current_stack, obj_stack);
lib/SPVM/Native/MethodCall.c:    env = current_env->get_pointer(current_env, current_stack, obj_env);
lib/SPVM/Native/MethodCall.c:  int32_t is_valid_env = env->check_stack_env(env, stack);
lib/SPVM/Native/MethodCall.c:    return current_env->die(current_env, current_stack, "The environment of $stack is not equal to the environment.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  void* method = env->get_class_method(env, stack, basic_type_name, method_name);
lib/SPVM/Native/MethodCall.c:    return current_env->die(current_env, current_stack, "The \"%s\" method in the \"%s\" class cannot be found.", method_name, basic_type_name, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  void* obj_method = env->new_pointer_object_by_name(env, stack, "Native::Method", method, error_id_ref, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:    void* obj_exception = env->get_exception(env, stack);
lib/SPVM/Native/MethodCall.c:    const char* exception = env->get_chars(env, stack, obj_exception);
lib/SPVM/Native/MethodCall.c:    return current_env->die(current_env, current_stack, "%s", method_name, basic_type_name, exception, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  int32_t method_required_args_length = env->api->method->get_required_args_length(env->runtime, method);
lib/SPVM/Native/MethodCall.c:    return current_env->die(current_env, current_stack, "The length of the required arguments of the \"%s\" method in the \"%s\" class must be 0.", method_name, basic_type_name, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  void* return_basic_type = env->api->method->get_return_basic_type(env->runtime, method);
lib/SPVM/Native/MethodCall.c:  int32_t return_basic_type_id = env->api->basic_type->get_id(env->runtime, return_basic_type);
lib/SPVM/Native/MethodCall.c:    return current_env->die(current_env, current_stack, "The return type of the \"%s\" method in the \"%s\" must be the void type.", method_name, basic_type_name, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  *error_id_ref = env->call_method(env, stack, method, 0);
lib/SPVM/Native/MethodCall.c:    void* obj_exception = env->get_exception(env, stack);
lib/SPVM/Native/MethodCall.c:    const char* exception = env->get_chars(env, stack, obj_exception);
lib/SPVM/Native/MethodCall.c:    return current_env->die(current_env, current_stack, "The method call of the \"%s\" method in the \"%s\" failed:%s", method_name, basic_type_name, exception, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:    stack = current_env->get_pointer(current_env, current_stack, obj_stack);
lib/SPVM/Native/MethodCall.c:    env = current_env->get_pointer(current_env, current_stack, obj_env);
lib/SPVM/Native/MethodCall.c:  int32_t is_valid_env = env->check_stack_env(env, stack);
lib/SPVM/Native/MethodCall.c:    return current_env->die(current_env, current_stack, "The environment of $stack is not equal to the environment.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:  void* obj_exception = env->get_exception(env, stack);
lib/SPVM/Native/MethodCall.c:    const char* exception = env->get_chars(env, stack, obj_exception);
lib/SPVM/Native/MethodCall.c:    int32_t exception_length = env->length(env, stack, obj_exception);
lib/SPVM/Native/MethodCall.c:    obj_exception_clone = current_env->new_string(current_env, current_stack, exception, exception_length);
lib/SPVM/Native/MethodCall.c:    stack = current_env->get_pointer(current_env, current_stack, obj_stack);
lib/SPVM/Native/MethodCall.c:    env = current_env->get_pointer(current_env, current_stack, obj_env);
lib/SPVM/Native/MethodCall.c:  int32_t is_valid_env = env->check_stack_env(env, stack);
lib/SPVM/Native/MethodCall.c:    return current_env->die(current_env, current_stack, "The environment of $stack is not equal to the environment.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/MethodCall.c:    const char* exception = current_env->get_chars(current_env, current_stack, obj_exception);
lib/SPVM/Native/MethodCall.c:    int32_t exception_length = current_env->length(current_env, current_stack, obj_exception);
lib/SPVM/Native/MethodCall.c:    obj_exception_clone = env->new_string(env, stack, exception, exception_length);
lib/SPVM/Native/MethodCall.c:  env->set_exception(env, stack, obj_exception_clone);
lib/SPVM/Native/Compiler.c:  void* compiler = env->api->compiler->new_instance();
lib/SPVM/Native/Compiler.c:  void* obj_self = env->new_pointer_object_by_name(env, stack, "Native::Compiler", compiler, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Compiler.c:  void* runtime = env->api->compiler->get_runtime(compiler);
lib/SPVM/Native/Compiler.c:  void* obj_runtime = env->new_pointer_object_by_name(env, stack, "Native::Runtime", runtime, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Compiler.c:  env->set_field_object_by_name(env, stack, obj_runtime, "compiler", obj_self, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Compiler.c:  void** obj_compiler_address = env->get_field_object_ref_by_name(env, stack, obj_runtime, "compiler", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Compiler.c:  env->weaken(env, stack, obj_compiler_address);
lib/SPVM/Native/Compiler.c:  env->set_field_object_by_name(env, stack, obj_self, "runtime", obj_runtime, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Compiler.c:  env->set_field_object_by_name(env, stack, obj_self, "runtime", NULL, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Compiler.c:  void* compiler = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Compiler.c:  env->api->compiler->free_instance(compiler);
lib/SPVM/Native/Compiler.c:    basic_type_name = env->get_chars(env, stack, obj_basic_type_name);
lib/SPVM/Native/Compiler.c:  void* compiler = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Compiler.c:  int32_t status = env->api->compiler->compile(compiler, basic_type_name);
lib/SPVM/Native/Compiler.c:    void* obj_prefix = env->new_string_nolen(env, stack, "[Compile Error]");
lib/SPVM/Native/Compiler.c:    void* obj_error_messages_string = env->new_string(env, stack, NULL, 0);
lib/SPVM/Native/Compiler.c:    void* obj_lf = env->new_string_nolen(env, stack, "\n");
lib/SPVM/Native/Compiler.c:    int32_t error_messages_length = env->api->compiler->get_error_messages_length(compiler);
lib/SPVM/Native/Compiler.c:    void* obj_error_messages = env->new_string_array(env, stack, error_messages_length);
lib/SPVM/Native/Compiler.c:      const char* error_message = env->api->compiler->get_error_message(compiler, i);
lib/SPVM/Native/Compiler.c:      void* obj_error_message = env->new_string_nolen(env, stack, error_message);
lib/SPVM/Native/Compiler.c:      obj_error_messages_string = env->concat(env, stack, obj_error_messages_string, obj_prefix);
lib/SPVM/Native/Compiler.c:      obj_error_messages_string = env->concat(env, stack, obj_error_messages_string, obj_error_message);
lib/SPVM/Native/Compiler.c:      obj_error_messages_string = env->concat(env, stack, obj_error_messages_string, obj_lf);
lib/SPVM/Native/Compiler.c:    env->die(env, stack, env->get_chars(env, stack, obj_error_messages_string), __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Compiler.c:  void* obj_runtime = env->get_field_object_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Compiler.c:  void* compiler = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Compiler.c:    start_file = env->get_chars(env, stack, obj_start_file);
lib/SPVM/Native/Compiler.c:  env->api->compiler->set_start_file(compiler, start_file);
lib/SPVM/Native/Compiler.c:  void* compiler = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Compiler.c:  env->api->compiler->set_start_line(compiler, start_line);
lib/SPVM/Native/Compiler.c:  void* compiler = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Compiler.c:  int32_t error_messages_length = env->api->compiler->get_error_messages_length(compiler);
lib/SPVM/Native/Compiler.c:  void* obj_error_messages = env->new_string_array(env, stack, error_messages_length);
lib/SPVM/Native/Compiler.c:    const char* error_message = env->api->compiler->get_error_message(compiler, i);
lib/SPVM/Native/Compiler.c:    void* obj_error_message = env->new_string_nolen(env, stack, error_message);
lib/SPVM/Native/Compiler.c:    env->set_elem_object(env, stack, obj_error_messages, i, obj_error_message);
lib/SPVM/Native/Compiler.c:  void* compiler = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Compiler.c:    include_dir = env->get_chars(env, stack, obj_include_dir);
lib/SPVM/Native/Compiler.c:  env->api->compiler->add_include_dir(compiler, include_dir);
lib/SPVM/Native/Compiler.c:  void* compiler = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Compiler.c:    include_dir = env->get_chars(env, stack, obj_include_dir);
lib/SPVM/Native/Compiler.c:  env->api->compiler->prepend_include_dir(compiler, include_dir);
lib/SPVM/Native/Compiler.c:    return env->die(env, stack, "$class_name must be defined.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Compiler.c:  const char* class_name = env->get_chars(env, stack, obj_class_name);
lib/SPVM/Native/Compiler.c:  void* compiler = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Compiler.c:  void* class_file = env->api->compiler->get_class_file(compiler, class_name);
lib/SPVM/Native/Compiler.c:    obj_class_file = env->new_pointer_object_by_name(env, stack, "Native::ClassFile", class_file, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Compiler.c:    env->set_field_object_by_name(env, stack, obj_class_file, "compiler", obj_self, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Compiler.c:    source = env->get_chars(env, stack, obj_source);
lib/SPVM/Native/Compiler.c:  void* compiler = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/Compiler.c:  int32_t status = env->api->compiler->compile_anon_class(compiler, source, &anon_basic_type_name);
lib/SPVM/Native/Compiler.c:    void* obj_prefix = env->new_string_nolen(env, stack, "[Compile Error]");
lib/SPVM/Native/Compiler.c:    void* obj_error_messages_string = env->new_string(env, stack, NULL, 0);
lib/SPVM/Native/Compiler.c:    void* obj_lf = env->new_string_nolen(env, stack, "\n");
lib/SPVM/Native/Compiler.c:    int32_t error_messages_length = env->api->compiler->get_error_messages_length(compiler);
lib/SPVM/Native/Compiler.c:    void* obj_error_messages = env->new_string_array(env, stack, error_messages_length);
lib/SPVM/Native/Compiler.c:      const char* error_message = env->api->compiler->get_error_message(compiler, i);
lib/SPVM/Native/Compiler.c:      void* obj_error_message = env->new_string_nolen(env, stack, error_message);
lib/SPVM/Native/Compiler.c:      obj_error_messages_string = env->concat(env, stack, obj_error_messages_string, obj_prefix);
lib/SPVM/Native/Compiler.c:      obj_error_messages_string = env->concat(env, stack, obj_error_messages_string, obj_error_message);
lib/SPVM/Native/Compiler.c:      obj_error_messages_string = env->concat(env, stack, obj_error_messages_string, obj_lf);
lib/SPVM/Native/Compiler.c:    env->die(env, stack, env->get_chars(env, stack, obj_error_messages_string), __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/Compiler.c:  void* obj_anon_basic_type_name = env->new_string(env, stack, anon_basic_type_name, strlen(anon_basic_type_name));
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  int32_t id = env->api->basic_type->get_id(runtime, basic_type);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  const char* name = env->api->basic_type->get_name(runtime, basic_type);
lib/SPVM/Native/BasicType.c:  void* obj_name = env->new_string_nolen(env, stack, name);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  const char* class_dir = env->api->basic_type->get_class_dir(runtime, basic_type);
lib/SPVM/Native/BasicType.c:    obj_class_dir = env->new_string_nolen(env, stack, class_dir);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  const char* class_rel_file = env->api->basic_type->get_class_rel_file(runtime, basic_type);
lib/SPVM/Native/BasicType.c:    obj_class_rel_file = env->new_string_nolen(env, stack, class_rel_file);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  void* parent = env->api->basic_type->get_parent(runtime, basic_type);
lib/SPVM/Native/BasicType.c:    void* obj_parent = env->new_pointer_object_by_name(env, stack, "Native::BasicType", parent, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:    env->set_field_object_by_name(env, stack, obj_parent, "runtime", obj_runtime, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  int32_t category = env->api->basic_type->get_category(runtime, basic_type);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  const char* version_string = env->api->basic_type->get_version_string(runtime, basic_type);
lib/SPVM/Native/BasicType.c:  void* obj_version_string = env->new_string_nolen(env, stack, version_string);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  int32_t is_pointer = env->api->basic_type->is_pointer(runtime, basic_type);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  int32_t is_anon = env->api->basic_type->is_anon(runtime, basic_type);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  void* class_var = env->api->basic_type->get_class_var_by_index(runtime, basic_type, class_var_index);
lib/SPVM/Native/BasicType.c:    return env->die(env, stack, "The class variable is not found.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* obj_class_var = env->new_pointer_object_by_name(env, stack, "Native::ClassVar", class_var, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  env->set_field_object_by_name(env, stack, obj_class_var, "runtime", obj_self, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:    return env->die(env, stack, "The class variable name must be specified.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  const char* class_var_name = env->get_chars(env, stack, obj_class_var_name);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  void* class_var = env->api->basic_type->get_class_var_by_name(runtime, basic_type, class_var_name);
lib/SPVM/Native/BasicType.c:    return env->die(env, stack, "The class variable is not found.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* obj_class_var = env->new_pointer_object_by_name(env, stack, "Native::ClassVar", class_var, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  env->set_field_object_by_name(env, stack, obj_class_var, "runtime", obj_self, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  int32_t class_vars_length = env->api->basic_type->get_class_vars_length(runtime, basic_type);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  void* field = env->api->basic_type->get_field_by_index(runtime, basic_type, field_index);
lib/SPVM/Native/BasicType.c:    return env->die(env, stack, "The class variable is not found.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* obj_field = env->new_pointer_object_by_name(env, stack, "Native::Field", field, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  env->set_field_object_by_name(env, stack, obj_field, "runtime", obj_self, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:    return env->die(env, stack, "The field name must be specified.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  const char* field_name = env->get_chars(env, stack, obj_field_name);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  void* field = env->api->basic_type->get_field_by_name(runtime, basic_type, field_name);
lib/SPVM/Native/BasicType.c:    return env->die(env, stack, "The field is not found.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* obj_field = env->new_pointer_object_by_name(env, stack, "Native::Field", field, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  env->set_field_object_by_name(env, stack, obj_field, "runtime", obj_self, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  int32_t get_fields_length = env->api->basic_type->get_fields_length(runtime, basic_type);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  void* method = env->api->basic_type->get_method_by_index(runtime, basic_type, method_index);
lib/SPVM/Native/BasicType.c:    return env->die(env, stack, "The method is not found.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* obj_method = env->new_pointer_object_by_name(env, stack, "Native::Method", method, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  env->set_field_object_by_name(env, stack, obj_method, "runtime", obj_runtime, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:    return env->die(env, stack, "The method name must be specified.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  const char* method_name = env->get_chars(env, stack, obj_method_name);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  void* method = env->api->basic_type->get_method_by_name(runtime, basic_type, method_name);
lib/SPVM/Native/BasicType.c:    return env->die(env, stack, "The method is not found.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* obj_method = env->new_pointer_object_by_name(env, stack, "Native::Method", method, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  env->set_field_object_by_name(env, stack, obj_method, "runtime", obj_runtime, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  int32_t get_methods_length = env->api->basic_type->get_methods_length(runtime, basic_type);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  void* anon_basic_type = env->api->basic_type->get_anon_basic_type_by_index(runtime, basic_type, anon_basic_type_index);
lib/SPVM/Native/BasicType.c:    return env->die(env, stack, "The basic type is not found.", __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* obj_anon_basic_type = env->new_pointer_object_by_name(env, stack, "Native::BasicType", anon_basic_type, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  env->set_field_object_by_name(env, stack, obj_anon_basic_type, "runtime", obj_runtime, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* basic_type = env->get_pointer(env, stack, obj_self);
lib/SPVM/Native/BasicType.c:  void* obj_runtime = env->get_field_object_defined_and_has_pointer_by_name(env, stack, obj_self, "runtime", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Native/BasicType.c:  void* runtime = env->get_pointer(env, stack, obj_runtime);
lib/SPVM/Native/BasicType.c:  int32_t anon_basic_types_length = env->api->basic_type->get_anon_basic_types_length(runtime, basic_type);
lib/SPVM/Document/NativeAPI/Method.pm:  SPVM_API_METHOD* api_method = env->api->method;
lib/SPVM/Document/NativeAPI/Method.pm:  void* basic_type = env->get_basic_type(env, stack, "Foo");
lib/SPVM/Document/NativeAPI/Method.pm:  void* method = env->api->basic_type->get_method_by_name(env->runtime, basic_type, "get");
lib/SPVM/Document/NativeAPI/Method.pm:  const char* method_name = api_method->get_name(env->runtime, method);
lib/SPVM/Document/NativeAPI/ClassVariable.pm:  SPVM_API_CLASS_VAR* api_class_var = env->api->class_var;
lib/SPVM/Document/NativeAPI/ClassVariable.pm:  void* basic_type = env->get_basic_type(env, stack, "Foo");
lib/SPVM/Document/NativeAPI/ClassVariable.pm:  void* class_var = env->api->basic_type->get_class_var_by_name(env->runtime, basic_type, "$VAR");
lib/SPVM/Document/NativeAPI/ClassVariable.pm:  const char* class_var_name = api_class_var->get_name(env->runtime, class_var);
lib/SPVM/Document/NativeAPI/Allocator.pm:  SPVM_API_ALLOCATOR* api_allocator = env->api->allocator;
lib/SPVM/Document/NativeAPI/Compiler.pm:  SPVM_API_COMPILER* api_compiler = env->api->compiler;
lib/SPVM/Document/NativeAPI/Internal.pm:  SPVM_API_INTERNAL* api_internal = env->api->internal;
lib/SPVM/Document/NativeAPI/Mutex.pm:  SPVM_API_MUTEX* api_mutex = env->api->mutex;
lib/SPVM/Document/NativeAPI/Field.pm:  SPVM_API_FIELD* api_field = env->api->field;
lib/SPVM/Document/NativeAPI/Field.pm:  void* basic_type = env->get_basic_type(env, stack, "Foo");
lib/SPVM/Document/NativeAPI/Field.pm:  void* field = env->api->basic_type->get_field_by_name(env->runtime, basic_type, "value");
lib/SPVM/Document/NativeAPI/Field.pm:  const char* field_name = api_field->get_name(env->runtime, field);
lib/SPVM/Document/NativeAPI/BasicType.pm:  SPVM_API_BASIC_TYPE* api_basic_type = env->api->basic_type;
lib/SPVM/Document/NativeAPI/BasicType.pm:  void* basic_type = env->get_basic_type(env, stack, "Int");
lib/SPVM/Document/NativeAPI/BasicType.pm:  const char* basic_type_name = api_basic_type->get_name(env->runtime, basic_type);
lib/SPVM/Document/NativeAPI/Runtime.pm:  SPVM_API_RUNTIME* api_runtime = env->api->runtime;
lib/SPVM/Document/NativeAPI/Runtime.pm:  int32_t basic_types_length = api_runtime->get_basic_types_length(env->runtime);
lib/SPVM/Document/NativeAPI/Type.pm:  SPVM_API_TYPE* api_type = env->api->type;
lib/SPVM/Document/NativeAPI/StringBuffer.pm:  SPVM_API_STRING_BUFFER* string_buffer_api = env->api->string_buffer;
lib/SPVM/Document/NativeAPI/StringBuffer.pm:  SPVM_API_ALLOCATOR* api_allocator = env->api->allocator;
lib/SPVM/Document/NativeAPI/ClassFile.pm:  SPVM_API_CLASS_FILE* api_class_file = env->api->class_file;
lib/SPVM/Document/NativeAPI/ClassFile.pm:  void* class_file = env->api->compiler->get_class_file(compiler, "MyClass");
lib/SPVM/Document/NativeAPI/Argument.pm:  SPVM_API_ARG* api_arg = env->api->arg;
lib/SPVM/Document/NativeAPI/Argument.pm:  SPVM_API_METHOD* api_method = env->api->method;
lib/SPVM/Document/NativeAPI/Argument.pm:  void* basic_type = env->get_basic_type(env, stack, "Foo");
lib/SPVM/Document/NativeAPI/Argument.pm:  void* method = env->api->basic_type->get_method_by_name(env->runtime, basic_type, "get");
lib/SPVM/Document/NativeAPI/Argument.pm:  void* arg = api_method->get_arg_by_index(env->runtime, method, 0);
lib/SPVM/Document/NativeAPI/Argument.pm:  void* arg_basic_type = api_arg->get_basic_type(env->runtime, arg);
lib/SPVM/Document/NativeClass.pm:  void* obj_point = env->new_object_by_name(env, stack, "Point", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeClass.pm:    env->call_class_method_by_name(env, stack, "MyClass", "sum", args_width, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeClass.pm:  const char* chars = env->get_chars(env, stack, obj_string);
lib/SPVM/Document/NativeClass.pm:  int32_t* values = env->get_elems_int(env, stack, obj_array);
lib/SPVM/Document/NativeClass.pm:  env->set_exception(env, stack, env->new_string_nolen(env, stack, "An exception is thrown."));
lib/SPVM/Document/NativeClass.pm:  return env->die("The value must be %d.", 3, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeClass.pm:    strcut tm* st_tm = (struct tm*)env->new_memory_block(env, stack, sizeof (struct tm));
lib/SPVM/Document/NativeClass.pm:    void* obj_tm = env->new_object_by_name(env, stack, "MyTm", error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeClass.pm:    env->set_pointer(env, stack, obj_tm, st_tm);
lib/SPVM/Document/NativeClass.pm:    strcut tm* st_tm = (struct tm*)env->get_pointer(env, stack, obj_tm);
lib/SPVM/Document/NativeClass.pm:    strcut tm* st_tm = (struct tm*)env->get_pointer(env, stack, obj_tm);
lib/SPVM/Document/NativeClass.pm:    env->free_memory_block(env, stack, st_tm);
lib/SPVM/Document/NativeClass.pm:  int32_t mortal_stack_top = env->enter_scope(env, stack);
lib/SPVM/Document/NativeClass.pm:  env->push_mortal(env, stack, object);
lib/SPVM/Document/NativeClass.pm:  env->leave_scope(env, stack, mortal_stack_top);
lib/SPVM/Document/NativeAPI.pm:  void* runtime = env->runtime;
lib/SPVM/Document/NativeAPI.pm:  SPVM_API_BASIC_TYPE* api_basic_type = env->api->basic_type;
lib/SPVM/Document/NativeAPI.pm:  int32_t args_width = env->args_width(env, stack);
lib/SPVM/Document/NativeAPI.pm:  int32_t basic_type_id = env->get_basic_type_id(env, stack, "Int");
lib/SPVM/Document/NativeAPI.pm:  void* class_var = env->get_class_var(env, stack, "MyClass", "$VAR");
lib/SPVM/Document/NativeAPI.pm:  int8_t value = env->get_class_var_byte_by_name(env, stack, "TestCase::NativeAPI", "$BYTE_VALUE", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  int16_t value = env->get_class_var_short_by_name(env, stack, "TestCase::NativeAPI", "$SHORT_VALUE", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  int8_t value = env->get_class_var_int_by_name(env, stack, "TestCase::NativeAPI", "$BYTE_VALUE", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  int64_t value = env->get_class_var_long_by_name(env, stack, "TestCase::NativeAPI", "$LONG_VALUE", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  float value = env->get_class_var_float_by_name(env, stack, "TestCase::NativeAPI", "$FLOAT_VALUE", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  double value = env->get_class_var_double_by_name(env, stack, "TestCase::NativeAPI", "$DOUBLE_VALUE", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  void* value = env->get_class_var_object_by_name(env, stack, "TestCase::NativeAPI", "$MINIMAL_VALUE", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  env->set_class_var_byte_by_name(env, stack, "TestCase::NativeAPI", "$BYTE_VALUE", 15, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  env->set_class_var_short_by_name(env, stack, "TestCase::NativeAPI", "$SHORT_VALUE", 15, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  env->set_class_var_int_by_name(env, stack, "TestCase::NativeAPI", "$INT_VALUE", 15, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  env->set_class_var_long_by_name(env, stack, "TestCase::NativeAPI", "$LONG_VALUE", 15, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  env->set_class_var_float_by_name(env, stack, "TestCase::NativeAPI", "$FLOAT_VALUE", 15, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  env->set_class_var_double_by_name(env, stack, "TestCase::NativeAPI", "$DOUBLE_VALUE", 15, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  env->set_class_var_object_by_name(env, stack, "TestCase::NativeAPI", "$MINIMAL_VALUE", minimal, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  void* field = env->get_field(env, stack, object, "x");
lib/SPVM/Document/NativeAPI.pm:  void* field = env->get_field_static(env, stack, "Point", "x");
lib/SPVM/Document/NativeAPI.pm:  int8_t byte_value = env->get_field_byte_by_name(env, stack, object, "byte_value", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  int8_t short_value = env->get_field_short_by_name(env, stack, object, "short_value", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  int8_t int_value = env->get_field_int_by_name(env, stack, object, "int_value", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  int8_t long_value = env->get_field_long_by_name(env, stack, object, "long_value", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  int8_t float_value = env->get_field_float_by_name(env, stack, object, "float_value", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  int8_t double_value = env->get_field_double_by_name(env, stack, object, "double_value", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  void* object_minimal = env->get_field_object_by_name(env, stack, object_simple, "object_value", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  env->set_field_byte_by_name(env, stack, object, "byte_value", 13, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  env->set_field_short_by_name(env, stack, object, "short_value", 13, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  env->set_field_int_by_name(env, stack, object, "int_value", 13, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  env->set_field_long_by_name(env, stack, object, "long_value", 13, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  env->set_field_float_by_name(env, stack, object, "float_value", 13, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  env->set_field_double_by_name(env, stack, object, "double_value", 13, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  env->set_field_object_by_name(env, stack, object_simple, "object_value", object_minimal, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  void* method = env->get_method(env, stack, "Foo", "get");
lib/SPVM/Document/NativeAPI.pm:  void* method = env->get_class_method(env, stack, "Foo", "get");
lib/SPVM/Document/NativeAPI.pm:  void* method = env->get_instance_method_static(env, stack, "Foo", "get");
lib/SPVM/Document/NativeAPI.pm:  void* method = env->get_instance_method(env, stack, object, "get");
lib/SPVM/Document/NativeAPI.pm:    env->call_class_method_by_name(env, stack, "MyClass", "sum", args_width, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:    env->call_instance_method_static_by_name(env, stack, "Point", "x", args_width, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  void* basic_type = env->get_basic_type(env, stack, "Int");
lib/SPVM/Document/NativeAPI.pm:  void* object = env->new_object(env, stack, basic_type);
lib/SPVM/Document/NativeAPI.pm:  void* obj_point = env->new_object_by_name(env, stack, "Point", &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  void* basic_type = env->get_basic_type(env, stack, "MyTm");
lib/SPVM/Document/NativeAPI.pm:  void* st_tm = env->new_memory_block(env, stack, sizeof (struct tm));
lib/SPVM/Document/NativeAPI.pm:  void* obj_st_tm = env->new_pointer(env, stack, basic_type, st_tm);
lib/SPVM/Document/NativeAPI.pm:  void* minimal = env->new_pointer_object_by_name(env, stack, "TestCase::Pointer", pointer, &error_id, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  strcut tm* tm = (struct tm*)env->get_pointer(env, stack, obj_tm);
lib/SPVM/Document/NativeAPI.pm:  void* str_obj = env->new_string_nolen(env, stack, "Hello World");
lib/SPVM/Document/NativeAPI.pm:  void* str_obj = env->new_string(env, stack, "Hello \0World", 11);
lib/SPVM/Document/NativeAPI.pm:  void* byte_array = env->new_byte_array(env, stack, 100);
lib/SPVM/Document/NativeAPI.pm:  void* short_array = env->new_short_array(env, stack, 100);
lib/SPVM/Document/NativeAPI.pm:  void* int_array = env->new_int_array(env, stack, 100);
lib/SPVM/Document/NativeAPI.pm:  void* long_array = env->new_long_array(env, stack, 100);
lib/SPVM/Document/NativeAPI.pm:  void* float_array = env->new_float_array(env, stack, 100);
lib/SPVM/Document/NativeAPI.pm:  void* double_array = env->new_double_array(env, stack, 100);
lib/SPVM/Document/NativeAPI.pm:  int32_t basic_type_id = env->get_basic_type_id(env, stack, "Int");
lib/SPVM/Document/NativeAPI.pm:  void* object_array = env->new_object_array(env, stack, basic_type_id, 100);
lib/SPVM/Document/NativeAPI.pm:  int32_t basic_type_id = env->get_basic_type_id(env, stack, "Int");
lib/SPVM/Document/NativeAPI.pm:  void* multi_array = env->new_muldim_array(env, stack, basic_type_id, 2, 100);
lib/SPVM/Document/NativeAPI.pm:  int32_t basic_type_id = env->get_basic_type_id(env, stack, "Complex_2d");
lib/SPVM/Document/NativeAPI.pm:  void* value_array = env->new_mulnum_array(env, stack, basic_type_id, 100);
lib/SPVM/Document/NativeAPI.pm:  int32_t length = env->length(env, stack, array);
lib/SPVM/Document/NativeAPI.pm:  int8_t* values = env->get_elems_byte(env, stack, array);
lib/SPVM/Document/NativeAPI.pm:  int16_t* values = env->get_elems_short(env, stack, array);
lib/SPVM/Document/NativeAPI.pm:  int32_t* values = env->get_elems_int(env, stack, array);
lib/SPVM/Document/NativeAPI.pm:  int64_t* values = env->get_elems_long(env, stack, array);
lib/SPVM/Document/NativeAPI.pm:  float* values = env->get_elems_float(env, stack, array);
lib/SPVM/Document/NativeAPI.pm:  double* values = env->get_elems_double(env, stack, array);
lib/SPVM/Document/NativeAPI.pm:  void* object = env->get_elem_object(env, stack, array, 3);
lib/SPVM/Document/NativeAPI.pm:  env->get_elem_object(env, stack, array, 3, object);
lib/SPVM/Document/NativeAPI.pm:  const char* chars = env->get_chars(env, stack, obj_string);
lib/SPVM/Document/NativeAPI.pm:  int32_t bool_value = env->get_bool_object_value(env, stack, bool_object);
lib/SPVM/Document/NativeAPI.pm:  return env->die(env, stack, "The value must be %d.", 3, __func__, FILE_NAME, __LINE__);
lib/SPVM/Document/NativeAPI.pm:  spvm_warnf(env->spvm_stderr(env, stack), "Hello");
lib/SPVM/Document/NativeAPI.pm:  spvm_warnf(env->spvm_stderr(env, stack), "Hello %s%d", "Foo", 3);
