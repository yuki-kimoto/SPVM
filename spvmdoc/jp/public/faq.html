<html>
  <head>
    <title>SPVM FAQ</title>
    <meta charset="UTF-8">
    <link rel="shortcut icon" href="/images/spvm-logo.png">
    <link rel="stylesheet" type="text/css" href="/css/common.css">
    <script type="text/javascript" src="/js/jquery-1.9.0.min.js"></script>
    <script type="text/javascript" src="/js/google-code-prettify/prettify.js"></script>
    <link  type="text/css" rel="stylesheet" href="/js/google-code-prettify/prettify.css"/>
    <script>
      $(function(){
        // google code prettifyの有効化
        $("pre").addClass("prettyprint");
        function init(event){
          prettyPrint();
        }
        if(window.addEventListener)window.addEventListener("load",init,false);
        else if(window.attachEvent)window.attachEvent("onload",init);
        
        $(".to-top").click(function() {
          // ページの一番上までスクロールさせます。
          $('body, html').animate({scrollTop: 0}, 300, 'linear');;
        });
      });
    </script>
  </head>
  <body>
    <div class="header">
      <div class="container">
        <h1>
          <a style="color:#333;text-decoration:none;" href="/"><img src="/images/spvm-logo.png">SPVMドキュメント 1.0 ベータ</a>
        </h1>
      </div>
    </div>
    
    <div class="container">

      <h2 id="faq">FAQ</h2>
      <div>
        最終更新日 2019年7月16日
        <br><b>現在この日本語の翻訳ドキュメントは、SPVMの最新のドキュメントに追随していません。</b>
        <br>最新のドキュメントは<a href="https://yuki-kimoto.github.io/spvmdoc-public/">SPVM Document</a>を参照してください。
        <br>SPVMは1.0のリリースに向けて、活発に試験と開発が行われています。
      </div>

      <h3>サブルーチン呼び出しの絶対名呼び出しができないのはなぜですか</h3>
      <p>
        SPVMでは以下のようにサブルーチンを呼び出すことができません。
      </p>
<pre>
Foo::bar();
</pre>
      <p>
        常に、アロー演算子を使う必要があります。
      </p>
<pre>
Foo->bar();
</pre>
      <p>
        SPVMの世界に閉じるのであれば、この二つを同じものとして扱うことができるのですが、Perlの世界においては、二つの表現は意味が異なります。
      </p>
      <p>
        SPVMのひとつの目標は、SPVMにおける呼び出しとPerlにおける呼び出しを完全に一致させることです。
      </p>
      <p>
        SPVMの世界でアロー演算子で呼び出せるものが、Perlの世界でもアロー演算子で呼び出せるという単純な規則を設けることで、呼び出しを完全に一致させています。
      </p>
      
      <h3>加算演算子・減算演算子・乗算演算子の整数演算でオーバーフローした場合の動作はどうなりますか</h3>
      <p>
        C99は、加算演算子・減算演算子・乗算演算子における整数演算のオーバーフロー時の動作について定義していないので、処理系依存になります。
      </p>
      <p>
        ほぼすべての環境においては、2の補数表現を使って、整数を表現し、加算と減算を行いますので、2の補数表現で演算を行った場合の結果になることが期待されます。
      </p>
      <h3>C99以外で書かれたライブラリは利用できますか</h3>
      <p>
        はい。ライブラリがC89、C11、C++の各仕様で書かれていても利用できます。C99準拠というのは、SPVM自体のソースコード自体において適用されるだけです。
      </p>
      <h3>定数畳み込み最適化は行われますか。</h3>
      <p>
        通常は、定数畳み込みの最適化は、行われませんが、プリコンパイルされたサブルーチンでは、定数畳み込みがCコンパイラによって試みらるでしょう。
      </p>
      <h3>演算子の優先順位でPerlと異なる点を教えてください</h3>
      <p>
        演算子の優先順位はPerlをベースにして作成されており、ほぼPerlの優先順位だと考えて大丈夫です。
      </p>
      <p>
        ひとつの違いは、SPVMには型キャストがあることです。型キャストは「単項演算子」の優先順位よりもひとつ低く、「乗算演算子」の優先順位よりも一つ高くなっています。
      </p>
      <p>
        以下の例ではキャストが先に行われます。
      </p>
<pre>
(long)3 + 1;
</pre>
      <h3>「比較演算子」と「論理演算子」が戻り値を返せないのはなぜですか?</h3>
      <p>
        これを、戻り値にすることは可能なはずですが、現在は実装されていません。
      </p>
      <p>
        実装されていない理由は、一時変数の増加とオペレーションコードの増加が見込まれ、最適な形で実装することが、現在の作者の実力では困難であることです。
      </p>
      <p>
        現在の内部実装では、条件判定した結果は、内部的な条件フラグに保存されます。
      </p>
      <p>
        戻り値が欲しい場合は、次のように記述してください。
      </p>
<pre>
my $flag : int;
if ($num > 3) {
  $flag = 1;
}
else {
  $flag = 0;
}
</pre>
      <h3>
        SPVMの1.0はいつリリースされますか。
      </h3>
      <h3>
        SPVMの1.0はいつリリースされますか。
      </h3>
      <p>
        SPVMは柔軟で、十分な後方互換性を保つことを目標に現在、設計しています。
      </p>
      <p>
        いくつかの分野で、プログラムが正しく記述できること、パフォーマンスの要件を満たすことが必要です。1.0のリリースは、この要件が満たされた後になります。
      </p>
      <p>
        デバイスドライバや、Open CV、Open GL、SIMD、 Open MP、GPUなどのC/C++ライブラリとの連携の確認。
      </p>
      <p>
        HTTPSのリクエストを処理できるHTTPクライアント/サーバーライブラリ。
      </p>
      <p>
        Windows APIを利用したネイティブWindowsアプリケーションの作成。
      </p>
      <p>
       少なくとも<b>デバイスドライバやC/C++ライブラリと連携でき、WebにHTTPSで接続できる、ネイティブアプリケーション</b>が作成できることの確認が必要です。
      </p>
      
      <h3>
        SPVMを開発するにあたって参考にした言語を教えてください。
      </h3>
      <p>
        言語仕様と文法についてはPerlを主に参考にしています。
      </p>
      <p>
        Perl 6の文法・キーワードを部分的に採用しています。「has」「native」「ro」「rw」「wo」など。
      </p>
      <p>
        SPVMのバーチャルマシンの初期実装は、JavaVMを参考にして、可変長バイト命令を解釈するスタック型VMとして作成されました。現在のSPVMは、64bitの固定長命令を解釈するレジスター型VMとなっています。
      </p>
      <p>
        数値型と数値計算においては、Javaの計算規則を参考にしました。
      </p>
      <p>
        ボクシング、アンボクシング、可変長引数については、Javaを参考にしました。
      </p>
      <p>
        コールバックについては、C言語の関数ポインタを参考にしました。
      </p>
      
      <h3>なぜレジスタ型VMを採用していますか</h3>
      <p>
        レジスタ型VMを採用している最も大きな理由は、SPVMのオペレーションコードを、C言語のソースコードに変換するときに、1対1で対応させることができるためです。gccの最適化が適用できます。
      </p>
      <h3>列挙にint型以外の型を利用することはできますか</h3>
      <p>
        残念なことですが、列挙に利用できるるのはint型だけです。
      <p>
      <p>
        他の型の定数を利用したい場合は、定数を返すサブルーチンを定義してください。
      </p>
<pre>
sub FOO : double () {
  return 3.14;
}
</pre>
      <p>
        一つの定数を返すサブルーチンは、定数としてインライン展開されることが仕様上で保証されているので、パフォーマンスを気にせず利用できます。
      </p>
      <h3>
        SPVMのサブルーチン呼び出しでかっこを省略できないのはなぜですか。
      </h3>
      <p>
        SPVMにおいては、メソッドの呼び出し、クラスメソッドの呼び出しについては、かっこの省略が可能です。サブルーチン名だけを指定した場合においては、かっこの省略ができません。
      </p>
      <p>
        これは、サブルーチン名だけでは、識別子名がサブルーチンであることを、ソースコードの中で、決定できないためです。パッケージ名やフィールド名との区別ができません。
      </p>
      <p>
        他のソースファイルを解析することによって、かっこを省略する構文は、理論的には可能ですが、SPVMでは、単一ファイルの中で、静的な構文解析を完了できるということを重要視しました。
      </p>
      <h3>サポートされるGCCのバージョンを教えてください</h3>
      <p>
        gcc 4.3で確認しており、保証される最低のバージョンはgcc 4.3です。C99がサポートされている必要があります。
      </p>
      <h3>符号なし整数型はありませんか</h3>
      <p>
        残念ながら、SPVMには、符号なし整数型はありません。
      </p>
      <h3>対応しているOSを教えてください。</h3>

      <p>
      Unix、Linux、macOS、Windowsに対応しています。
      </p>

      <h3>Perlと異なる点を教えてください。</h3>

      <p>
        コンテキストは存在しません。関数の呼び出しには括弧が必要です。三項演算子はありません。シングルクォートは、文字定数です。
      </p>
      <p>
        標準関数や標準モジュールは、Perlとは完全に異なっています。
      </p>
      <p>
        サブルーチンは、必ずメソッドか、クラスメソッドになります。サブルーチンの絶対名での呼び出しはできません。
      </p>
      <p>
        モジュールの拡張子は「spvm」です。
      </p>
      <p>
        型はすべて静的型です。サブルーチン呼び出しは、コンパイル時に解決されます。配列は静的です。動的配列とハッシュは、モジュールとして提供されます。
      </p>

      <h3>スレッドは利用できますか</h3>
      <p>
        スレッドは、コアではサポートされていませんが、エクステンションを使ったユーザーモジュールを作成することで、間接的に利用できます。
      </p>
      <p>
        SPVMはシングルスレッドで動くように設計されています。シングルスレッドは、利用者にとって簡単で安全な設計です。
      </p>
      <p>
        スレッドの機能はSPVMのコアにはありませんが、CやC++のスレッドライブラリを利用して、エクステンションから利用することはできます。
      </p>
      <p>
        エクステンションでは、スレッド用のSPVMの実行環境を生成して、スレッド上で、利用できます。
      </p>
      <p>
        SPVMのモジュールとして作成すれば、SPVMからサブルーチンを通して、間接的にスレッドを利用できます。
      </p>

      <h3>エクステンションとは何ですか</h3>
      <p>
        エクステンションとは、SPVMからC/C++の関数を呼び出すための仕組みのことです。
      </p>

      <h3>プリコンパイルとは何ですか</h3>
      <p>
        プリコンパイルとは、SPVMのサブルーチンを、コンパイル時に機械語に変換する仕組みのことです。機械語に変換されたサブルーチンは、高速に実行できます。</p>
      <p>
        precompileが指定されたサブルーチンを含むモジュールファイルは、コンパイル時に、Cのソースコードに変換されます。
      </p>
<pre>
precompile sub sum : int ($num1 : int, $num2 : int) {
  return $num1 + $num2;
}
</pre>
      <p>
        Cのソースコードは、ビルドディレクトリの中に作成されます。
      </p>
      <p>
        生成されたCのソースコードは、Perlをコンパイルしたコンパイラ(通常はgccかclang)によって、機械語(.oの拡張子を持つオブジェクトファイル)にコンパイルされます。
      </p>
      <p>
        機械語に変換された後、各OSで呼び出すことのできる共有ライブラリ(.soや.dll)にリンクされます。
      </p>

      <h3>ビルドディレクトリとは何ですか</h3>
      <p>
        プリコンパイルする場合に、必要となるディレクトリのことです。
      </p>
      <p>
        ビルドディレクトリを利用することをSPVMに教えるにはSPVM::BuildDirモジュールを使用する必要があります。
      </p>
<pre>
use SPVM::BuildDir;
</pre>
      <p>
        スクリプトがあるディレクトリの「spvm_build」というディレクトリがデフォルトのビルドディレクトリ名になります。
      </p>
      <p>
        ビルドディレクトリ名を自分で指定したい場合は、次のようにします。
      </p>
<pre>
use FindBin;
use SPVM::BuildDir "$FindBin::Bin/mydir;
</pre>

      <h3>コールバック型とは何ですか</h3>
      <p>
        SPVMでは、コールバック型とは、実装を持たないメソッドが一つだけ定義されているパッケージのことをいいます。
      </p>
      <p>
        コールバック型のひとつの例は、標準モジュールである「SPVM::Comparable」です。
      </p>
<pre>
package SPVM::Comparable : callback_t {
  sub compare : int ($self : self, $object1 : object, $object2 : object);
}
</pre>
      <p>
        機能としては、C言語の関数ポインタに似ています。
      </p>

      <h3>ジェネリクスはありますか</h3>
      <p>
        残念なことですが、SPVMにはジェネリクスはありません。SPVMは、コンパイル時の型決定性よりも、型の簡単さを選択しました。
      </p>
      <p>
        コンテナの要素は、汎用オブジェクト型で定義してください。汎用オブジェクトから実際のオブジェクトを取得するためには、型キャストが必要です。
      </p>
<pre>
sub add : void ($self : self, $object : ojbect) { ... }
sub get : object ($self : self, $index : int) { ... }
</pre>

<pre>
my $list = SPVM::ObjectList->new;
$list->add("hello!");
my $str = (string)$list->get(0);
</pre>

      <h3>継承はありますか</h3>
      <p>
        残念ですが、継承はありません。SPVMでは「汎用オブジェクト型」「汎用オブジェクト配列型」「コールバック型」を使って、ポリモーフィズムを実現します。
      </p>
      
      <h3>サブルーチンのオーバーロードはありますか。</h3>
      <p>
        サブルーチンのオーバーロードはありません。サブルーチンは、サブルーチン名で一意的に識別されます。
      </p>
      <p>
        採用されていない最も大きな理由は、Perl自体が型を持たないために、PerlからSPVMのサブルーチンへ渡す値の型が決定できないためです。
      </p>
      <p>
        このためSPVMでは、サブルーチン名によって、戻り値と引数の型がわかるように設計されています。
      </p>
      
      <h3>浮動小数点の演算は処理系依存ですか</h3>
      <p>
        はい、浮動小数点の表現方法、および演算は、処理系に依存します。
      </p>
      
      <h3>パッケージ名、フィールド名、サブルーチン名などの識別子に連続したアンダーラインが使えないのはなぜですか</h3>
      <p>
        二つの連続したアンダーラインは、エクステンションにおいて、パッケージ名とサブルーチン名の区切りとして利用されるためです。
      </p>
      <p>
        エクステンションはC言語で書かれます。
      </p>
<pre>
# SPVMのサブルーチン
package Foo::Bar {
  sub baz : void () { }
}
</pre>

<pre>
// エクステンションにおける関数名
SPNATIVE__Foo__Bar__baz(SPVM_ENV* env, SPVM_VALUE* stack) {

}
</pre>
      <p>
        SPVMの「Foo::Barパッケージのbazサブルーチン」はエクステンションの「SPNATIVE__Foo__Bar__baz」に対応します。これは1対1に対応し、相互に名前の変換が可能です。
      </p>
      
      <h3>SPVMからPerlのサブルーチンを呼び出すことはできますか</h3>
      <p>
        残念ながら、SPVMからPerlのサブルーチンを呼び出すことはできません。
      </p>
      <h3>C言語のconstやJavaのfinalのような機能はありますか。</h3>
      <p>
        一度代入した値を変更できなくする機能はありませんが、他の機能の組み合わせで実現することができます。
      </p>
      <p>
        <b>コンパイル時定数で数値型の場合</b>
      </p>
      <p>
        定数サブルーチンを使用します。
      </p>
<pre>
package Foo {
  sub VAL : double () {
    return 5.1234;
  }
}
</pre>
      
      <p>
        <b>コンパイル時定数でオブジェクト型の場合</b>
      </p>
      <p>
        パッケージ変数を定義します。パッケージ変数に読み込み用のアクセッサを定義します。BEGINブロックを使って、パッケージ変数を初期化します。
      </p>
<pre>
package Foo {
  our $POINT : ro int;
  
  BEGIN {
    $POINT = Point->new;
  }
}
</pre>
      <h3>シングルトンを生成することはできますか。</h3>
      <p>
        はいできます。
      </p>
      <p>
        パッケージ変数を定義します。BEGINブロックを使って、パッケージ変数を初期化します。singletonメソッドで、オブジェクトを返します。
      </p>
<pre>
package Foo {
  our $SINGLETON : Foo;
  BEGIN {
    $SINGLETON = new Foo;
  }
  
  sub singleton : Foo () {
    return $SINGLETON;
  }
}
</pre>
      <h3>SPVMの開発に参加することはできますか。</h3>

      <p>
        コア機能、標準関数、標準モジュールについては、作者が決定を行っています。その範囲の中であれば、開発への参加が可能です。
      </p>
      
      <p>
        バグ報告、ベンチマーク、言語評価、ブログなどでの紹介は歓迎です。
      </p>
      <h2 id="developer">開発情報</h2>
      <h3>SPVMの開発に参加</h3>
      <p>
        「README」の中に開発手順が記載されています。
      </p>
      <h3>著者</h3>
      <p>
        木本裕紀(kimoto.yuki@gmail.com)
      </p>
      <p>
        <img src="https://www.gravatar.com/avatar/0475497bcea869ee3d091edc3d06ced7?s=130&d=identicon">
      </p>
      <h3>コアデベロッパー</h3>
      <p>
        moti(motohiko.ave@gmail.com)
      </p>
      <h3>リポジトリ</h3>
      <p>
        <a href="https://github.com/yuki-kimoto/SPVM">SPVM(GitHub)</a>
      </p>
      <h3>CPAN</h3>
      <p>
        <a href="https://metacpan.org/pod/distribution/SPVM/lib/SPVM.pm">SPVM(CPAN)</a>
      </p>
      </p>
      <h3>バグ報告</h3>
      <p>
        バグ報告はGitHubのIssueで行うことができます。
      </p>
      <p>
        <a href="https://github.com/yuki-kimoto/SPVM/issues">GitHub Issue</a>
      </p>
    </div>
    <div class="footer">
      <div><a href="javascript:void(0)" class="to-top">▲</a></div>
      <a href="https://github.com/yuki-kimoto/SPVM">SPVMプロジェクト</a>
    </div>
  </body>
</html>
