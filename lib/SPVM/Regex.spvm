class Regex : precompile {
  use Unicode;
  use List;
  use IntList;
  use Hash;
  use StringBuffer;
  use Regex::Replacer;
  use Regex::Pattern;
  use Fn;
  has patterns : List;
  has string_start : byte;
  has string_end : byte;
  has single_line_mode : byte;
  has ascii_mode : byte;
  has ignore_case : byte;
  
  has captures : ro string[];
  
  has match_start : ro int;
  has match_length : ro int;
  
  has replace_count : ro int;
  
  private enum {
    STATUS_START,
    STATUS_CONTINUE,
    STATUS_QUANTIFIER_MIN,
    STATUS_QUANTIFIER_MAX,
  }

  static method new : Regex ($re_str_and_options : string[]...) {
    
    my $re_str = $re_str_and_options->[0];
    my $options = (string)undef;
    if (@$re_str_and_options > 1) {
      $options = $re_str_and_options->[1];
    }
    
    my $self = Regex->new_with_options($re_str, $options);
    
    return $self;
  }

  static method new_with_options : Regex ($re_str : string, $option_chars : string) {
    my $self = Regex->_new_without_compile();
    
    if ($option_chars) {
      my $options_h = Hash->new({});
      
      my $option_chars_length = length $option_chars;
      for (my $i = 0; $i < $option_chars_length; $i++) {
        my $option_char = $option_chars->[$i];
        if ($option_char == 's') {
          my $found = $options_h->get("s");
          if ($found) {
            die "s option must be used once";
          }
          $self->{single_line_mode} = 1;
          $options_h->set_int("s" => 1);
        }
        elsif ($option_char == 'a') {
          my $found = $options_h->get("a");
          if ($found) {
            die "a option must be used once";
          }
          $self->{ascii_mode} = 1;
          $options_h->set_int("a" => 1);
        }
        elsif ($option_char == 'i') {
          my $found = $options_h->get("i");
          if ($found) {
            die "a option must be used once";
          }
          $self->{ignore_case} = 1;
          $options_h->set_int("i" => 1);
        }
      }
    }
    
    $self->compile($re_str);
    
    return $self;
  }
  
  private static method _new_without_compile : Regex () {
    my $self = new Regex;
    
    $self->{patterns} = List->new_len(new Regex::Pattern[0], 0);

    $self->{captures} = new string[256];
    
    return $self;
  }
  
  private method compile : void ($re_str : string) {
    
    unless ($re_str) {
      die "Regex string must be defined";
    }
    
    my $re_str_length = length $re_str;
    
    if ($re_str_length == 0) {
      die "Regex string must have length";
    }
    
    my $pos = 0;
    my $patterns = $self->{patterns};
    
    my $quantifier_min_str = "";
    my $quantifier_max_str = "";
    
    my $status = Regex->STATUS_START();
    
    my $char_class_negate = 0;
    
    my $before_is_char_class_hyphen = 0;
    
    my $is_capture = 0;
    my $pattern_capture_begin = 0;
    
    my $cur_code_point_ranges_list = IntList->new;
    
    my $char_class_parsing = 0;
    while ((my $code_point = Unicode->uchar($re_str, \$pos)) >= 0) {
      my $finish_code_point_ranges = 0;
      
      switch ($code_point) {
        case '\\': {
          my $next_code_point = Unicode->uchar($re_str, \$pos);
          if ($code_point < 0) {
            die "Invalid regex. Last is \\ ";
          }
          
          switch ($next_code_point) {
            case 'd': {
              if ($self->{ascii_mode}) {
                unless ($char_class_parsing) {
                  $finish_code_point_ranges = 1;
                }
                my $cur_code_point_range = [(int)'0', '9'];
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
              else {
                die "\d must be used with ascii option";
              }
              break;
            }
            case 'D': {
              if ($self->{ascii_mode}) {
                unless ($char_class_parsing) {
                  $finish_code_point_ranges = 1;
                }
                my $cur_code_point_range = $self->negate_code_point_ranges([(int)'0', '9']);
                
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
              else {
                die "\D must be used with ascii option";
              }
              break;
            }
            case 'w': {
              if ($self->{ascii_mode}) {
                unless ($char_class_parsing) {
                  $finish_code_point_ranges = 1;
                }
                my $cur_code_point_range = [(int)'0', '9', 'A', 'Z', '_', '_', 'a', 'z'];
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
              else {
                die "\w  must be used with ascii option";
              }
              break;
            }
            case 'W': {
              if ($self->{ascii_mode}) {
                unless ($char_class_parsing) {
                  $finish_code_point_ranges = 1;
                }
                my $cur_code_point_range = $self->negate_code_point_ranges([(int)'0', '9', 'A', 'Z', '_', '_', 'a', 'z']);
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
              else {
                die "\W must be used with ascii option";
              }
              break;
            }
            case 's': {
              if ($self->{ascii_mode}) {
                unless ($char_class_parsing) {
                  $finish_code_point_ranges = 1;
                }
                my $cur_code_point_range = [(int)'\t', '\t', '\n', '\n', '\f', '\f', '\r', '\r', ' ', ' '];
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
              else {
                die "\s must be used with ascii option";
              }
              break;
            }
            case 'S': {
              if ($self->{ascii_mode}) {
                unless ($char_class_parsing) {
                  $finish_code_point_ranges = 1;
                }
                my $cur_code_point_range = $self->negate_code_point_ranges([(int)'\t', '\t', '\n', '\n', '\f', '\f', '\r', '\r', ' ', ' ']);
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
              else {
                die "\S must be used with ascii option";
              }
              break;
            }
            default: {
              if (Fn->is_perl_word($next_code_point)) {
                die "Invalid regex escape character";
              }
              # \: \- etc
              else {
                unless ($char_class_parsing) {
                  $finish_code_point_ranges = 1;
                }
                my $cur_code_point_range = [(int)$next_code_point, $next_code_point];
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
            }
          }
          
          break;
        }
        default: {
          if ($char_class_parsing) {
            if ($code_point == ']') {
              $char_class_parsing = 0;
              $status = Regex->STATUS_CONTINUE;
              $finish_code_point_ranges = 1;
            }
            elsif ($code_point == '-') {
              if ($before_is_char_class_hyphen) {
                die "- must not be repeat";
              }
              else {
                $before_is_char_class_hyphen = 1;
              }
            }
            else {
              if ($code_point == '^' && $cur_code_point_ranges_list->length == 0) {
                $char_class_negate = 1;
              }
              else {
                if ($before_is_char_class_hyphen) {
                  if ($cur_code_point_ranges_list->length == 0) {
                    die "- start not found";
                  }
                  else {
                    $cur_code_point_ranges_list->set($cur_code_point_ranges_list->length - 1, $code_point);
                    $before_is_char_class_hyphen = 0;
                  }
                }
                else {
                  my $cur_code_point_range = [$code_point, $code_point];
                  for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                    $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                  }
                }
              }
            }
          }
          else {
            switch ($code_point) {
              case '^': {
                if ($char_class_parsing) {
                  die "Unexpected";
                }
                elsif ($status != Regex->STATUS_START()) {
                  die "Regex compile error";
                }
                
                $self->{string_start} = 1;
                
                break;
              }
              case '.': {
                unless ($char_class_parsing) {
                  $finish_code_point_ranges = 1;
                }
                my $cur_code_point_range = (int[])undef;
                if ($self->{single_line_mode}) {
                  $cur_code_point_range = [(int)0, 0xDFFF];
                }
                else {
                  $cur_code_point_range = $self->negate_code_point_ranges([(int)'\n', '\n']);
                }
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
                break;
              }
              case '$': {
                $self->{string_end} = 1;
                break;
              }
              case '|': {
                die "| is not supported";
                break;
              }
              case '(': {
                if ($is_capture) {
                  die "Invalid capture start";
                }
                else {
                  $is_capture = 1;
                  $pattern_capture_begin = 1;
                }
                break;
              }
              case ')': {
                if ($is_capture) {
                  $is_capture = 0;
                  my $before_pattern = (Regex::Pattern)$patterns->get($patterns->length - 1);
                  $before_pattern->{capture_end} = 1;
                }
                else {
                  die "Invalid capture end";
                }
                break;
              }
              case '[': {
                $char_class_parsing = 1;
                $before_is_char_class_hyphen = 0;
                break;
              }
              case ']': {
                die "] must be end of character class";
                break;
              }
              case '*': {
                my $before_pattern = (Regex::Pattern)$patterns->get($patterns->length - 1);
                $before_pattern->{min_repeat} = 0;
                $before_pattern->{max_repeat} = Fn->INT32_MAX();
                break;
              }
              case '+': {
                my $before_pattern = (Regex::Pattern)$patterns->get($patterns->length - 1);
                $before_pattern->{min_repeat} = 1;
                $before_pattern->{max_repeat} = Fn->INT32_MAX();
                break;
              }
              case '?': {
                my $before_pattern = (Regex::Pattern)$patterns->get($patterns->length - 1);
                $before_pattern->{min_repeat} = 0;
                $before_pattern->{max_repeat} = 1;
                break;
              }
              case '{': {
                $status = Regex->STATUS_QUANTIFIER_MIN();
                break;
              }
              case '}': {
                unless ($status == Regex->STATUS_QUANTIFIER_MAX()) {
                  die "Regex compile error";
                }
                my $quantifier_max = Fn->to_int_with_base($quantifier_max_str, 10);
                my $last_pattern = (Regex::Pattern)$patterns->get($patterns->length - 1);
                $last_pattern->{max_repeat} = $quantifier_max;
                
                $status = Regex->STATUS_CONTINUE();
                $quantifier_max_str = "";
                break;
              }
              default: {
                if ($status == Regex->STATUS_QUANTIFIER_MIN()) {
                  if (Fn->is_digit($code_point)) {
                    $quantifier_min_str .= $code_point - '0';
                  }
                  elsif ($code_point == ',') {
                    my $quantifier_min = Fn->to_int_with_base($quantifier_min_str, 10);
                    my $last_pattern = (Regex::Pattern)$patterns->get($patterns->length - 1);
                    $last_pattern->{min_repeat} = $quantifier_min;
                    
                    $status = Regex->STATUS_QUANTIFIER_MAX();
                    $quantifier_min_str .= "";
                  }
                  else {
                    die "Quantifier min must be non-fractional number";
                  }
                }
                elsif ($status == Regex->STATUS_QUANTIFIER_MAX()) {
                  if (Fn->is_digit($code_point)) {
                    $quantifier_max_str .= $code_point - '0';
                  }
                  else {
                    die "Quantifier max must be non-fractional number";
                  }
                }
                else {
                  unless ($char_class_parsing) {
                    $finish_code_point_ranges = 1;
                  }
                  my $cur_code_point_range = [$code_point, $code_point];
                  for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                    $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                  }
                }
              }
            }
          }
        }
      }

      if ($finish_code_point_ranges) {
        my $pattern = new Regex::Pattern;

        $pattern->{negate} = (byte)$char_class_negate;
        $pattern->{code_point_ranges} = $cur_code_point_ranges_list->to_array;
        
        $pattern->{max_repeat} = 1;
        $pattern->{min_repeat} = 1;

        if ($pattern_capture_begin) {
          $pattern->{capture_begin} = 1;
          $pattern_capture_begin = 0;
        }
        
        $patterns->push($pattern);
        
        $cur_code_point_ranges_list = IntList->new;
      }
    }
  }
  
  method match : int ($target : string, $target_base_index : int) {
    
    unless ($target) {
      die "Target string must be defined";
    }
    
    my $patterns = $self->{patterns};
    my $patterns_length = $patterns->length;
    
    my $match_all = 0;
    my $target_index = 0;
    my $target_base_index_before : int;
    my $ignore_case = $self->{ignore_case};
    while (1) {
      $target_base_index_before = $target_base_index;
      my $target_base_uchar = Unicode->uchar($target, \$target_base_index);
      unless ($target_base_uchar >= 0) {
        last;
      }
      
      $target_index =  $target_base_index_before;
      
      my $pattern_index = 0;
      
      my $pattern_capture_begin_index = -1;
      my $capture_count = 0;
      while (1) {
        my $pattern = (Regex::Pattern)$patterns->get($pattern_index);
        my $max_repeat = $pattern->{max_repeat};
        my $min_repeat = $pattern->{min_repeat};
        my $code_point_range = $pattern->{code_point_ranges};
        my $negate = $pattern->{negate};
        
        if ($pattern->{capture_begin}) {
          $pattern_capture_begin_index = $target_index;
        }
        
        my $target_before_index = $target_index;
        my $target_uchar = Unicode->uchar($target, \$target_index);
        unless ($target_uchar >= 0) {
          last;
        }
        
        
        my $match_repeat = 0;
        my $repeat_count = 0;
        my $repeat_before_target_index = $target_before_index;
        
        # Match uchar repeat
        for (my $repeat_index = 0; $repeat_index < $max_repeat; $repeat_index++) {
          # Match uchar
          my $match_char = 0;
          
          # Match a character
          for (my $min_max_index = 0; $min_max_index < @$code_point_range; $min_max_index += 2) {
            my $code_point_min = $code_point_range->[$min_max_index];
            my $code_point_max = $code_point_range->[$min_max_index + 1];
            
            # Match a code point
            if ($target_uchar >= $code_point_min && $target_uchar <= $code_point_max) {
              $match_char = 1;
            }
            
            unless ($match_char) {
              # Try ignore case
              if ($ignore_case) {
                my $target_uchar_reverse_case = -1;
                # a-z
                if ($target_uchar >= 0x61 && $target_uchar <= 0x7A) {
                  $target_uchar_reverse_case = $target_uchar - 32;
                }
                # A-Z
                elsif ($target_uchar >= 0x41 && $target_uchar <= 0x5A) {
                  $target_uchar_reverse_case = $target_uchar + 32;
                }
                
                if ($target_uchar_reverse_case >= 0) {
                  if ($target_uchar_reverse_case >= $code_point_min && $target_uchar_reverse_case <= $code_point_max) {
                    $match_char = 1;
                  }
                }
              }
            }
            
            if ($match_char) {
              last;
            }
          }
          
          # Negate
          if ($negate) {
            $match_char = !$match_char;
          }
          
          # Increment repeat count
          if ($match_char) {
            $repeat_count++;
            $repeat_before_target_index = $target_index;

            if ($target_index == length $target) {
              last;
            }
            
            $target_uchar = Unicode->uchar($target, \$target_index);
            
            $target_before_index = $target_index;
          }
          else {
            last;
          }
        }
        if ($repeat_count >= $min_repeat) {
          $match_repeat = 1;
        }
        
        if ($match_repeat) {
          if ($pattern->{capture_end}) {
            $self->{captures}[$capture_count] = Fn->substr($target, $pattern_capture_begin_index, $repeat_before_target_index - $pattern_capture_begin_index);
            $capture_count++;
            if ($capture_count > 255) {
              die "Too many captures";
            }
          }
          $pattern_index++;
          $target_index = $repeat_before_target_index;
          if ($pattern_index == $patterns_length) {
            last;
          }
        }
        else {
          last;
        }
      }
      
      if ($pattern_index == $patterns_length) {
        $match_all = 1;
        last;
      }
      else {
        if ($self->{string_start}) {
          last;
        }
      }
    }
    
    my $really_match = 0;
    if ($match_all) {
      if ($self->{string_end}) {
        if ($target_index == length $target) {
          $really_match = 1;
        }
      }
      else {
        $really_match = 1;
      }
    }
    
    if ($really_match) {
      $self->{match_start} = $target_base_index_before;
      $self->{match_length} = $target_index - $self->{match_start};
    }
    
    return $really_match;
  }
  
  method replace  : string ($target : string, $target_offset : int, $replace : string) {
    return $self->replace_opt($target, $target_offset, $replace, {replace_all => 0});
  }

  method replace_cb  : string ($target : string, $target_offset : int, $replace_cb : Regex::Replacer) {
    return $self->replace_opt($target, $target_offset, $replace_cb, {replace_all => 0});
  }

  method replace_all  : string ($target : string, $target_offset : int, $replace : string) {
    return $self->replace_opt($target, $target_offset, $replace, {replace_all => 1});
  }

  method replace_all_cb  : string ($target : string, $target_offset : int, $replace_cb : Regex::Replacer) {
    return $self->replace_opt($target, $target_offset, $replace_cb, {replace_all => 1});
  }
  
  private method replace_opt  : string ($target : string, $target_base_index : int, $replace_object : object, $options : object[]) {
    
    my $opt = Hash->new($options);
    
    my $original_target_base_index = $target_base_index;
    
    my $replace_all = 0;
    if (my $replace_all_obj = $opt->get("replace_all")) {
      $replace_all = (int)$replace_all_obj;
    }
    $self->{replace_count} = 0;
    
    unless ($target) {
      return $target;
    }
    
    my $result : string;
    my $replace_count = 0;
    my $result_buffer = StringBuffer->new;
    my $tarlength = length $target;
    
    if ($target_base_index > 0) {
      my $first_string = Fn->substr($target, 0, $target_base_index);
      $result_buffer->push($first_string);
    }
    
    while (my $match = $self->match($target, $target_base_index)) {
      
      my $match_start = $self->match_start;
      my $match_end = $match_start + $self->match_length;
      
      my $replace : string;
      if ($replace_object isa string) {
        $replace = (string)$replace_object;
      }
      elsif ($replace_object isa object[]) {
        
        my $replace_objects = (object[])$replace_object;
        
        my $replace_buffer = StringBuffer->new;
        for (my $i = 0; $i < @$replace_objects; $i++) {
          my $replace_elem_object = $replace_objects->[$i];
          
          if ($replace_elem_object isa string) {
            $replace_buffer->push((string)$replace_elem_object);
          }
          elsif ($replace_elem_object isa Int) {
            my $capture = $self->captures->[(int)$replace_elem_object];
            $replace_buffer->push($capture);
          }
          else {
            die "Invalid replace argument element";
          }
        }
        
        $replace = $replace_buffer->to_string;
      }
      elsif ($replace_object isa Regex::Replacer) {
        my $replace_buffer = StringBuffer->new;
        my $replacer = (Regex::Replacer)$replace_object;
        my $cb_result = $replacer->($self);
        $replace_buffer->push($cb_result);
        $replace = $replace_buffer->to_string;
      }
      else {
        die "Invalid replace argument";
      }
      
      my $match_length = $self->match_length;
      my $replace_length = length $replace;
      
      my $result_length = $tarlength + $replace_length - $match_length;
      
      $result = (mutable string)new_string_len($result_length);
      
      my $rest_length = $tarlength - $match_end;
      
      my $before_result = (mutable string)Fn->substr($target, $target_base_index, $match_start - $target_base_index);
      $result_buffer->push($before_result);
      $result_buffer->push($replace);
      
      $replace_count++;
      
      unless ($replace_all) {
        last;
      }
      $target_base_index = $match_end;
    }
    
    
    if ($replace_count == 0) {
      $result = Fn->copy_string($target);
    }
    else {
      my $match_end = $self->match_start + $self->match_length;
      my $rest_length = $tarlength - $match_end;
      
      if ($rest_length > 0) {
        my $rest_string = Fn->substr($target, $match_end, $rest_length);
        $result_buffer->push($rest_string);
      }
      
      $result = $result_buffer->to_string;
    }
    
    $self->{replace_count} = $replace_count;
    
    return $result;
  }
  
  method cap1 : string () { return $self->captures->[0]; }
  method cap2 : string () { return $self->captures->[1]; }
  method cap3 : string () { return $self->captures->[2]; }
  method cap4 : string () { return $self->captures->[3]; }
  method cap5 : string () { return $self->captures->[4]; }
  method cap6 : string () { return $self->captures->[5]; }
  method cap7 : string () { return $self->captures->[6]; }
  method cap8 : string () { return $self->captures->[7]; }
  method cap9 : string () { return $self->captures->[8]; }
  method cap10 : string () { return $self->captures->[9]; }

  private method culcurate_code_point_ranges : int[] ($code_point_raw_ranges_list : IntList) {
    my $code_point_ranges_list = IntList->new;
    for (my $i = 0; $i < $code_point_raw_ranges_list->length; $i++) {
      my $value = $code_point_raw_ranges_list->get($i);
      if ($value >= 0) {
        $code_point_ranges_list->push($value);
      }
    }
    
    return $code_point_ranges_list->to_array;
  }

  private method negate_code_point_ranges : int[] ($code_point_ranges : int[]) {
    
    if (@$code_point_ranges < 2) {
      die "The length of the code point rainges must be more than 2";
    }

    my $negate_code_point_rainges_raw_list = IntList->new;
    $negate_code_point_rainges_raw_list->push(0);
    for (my $i = 0; $i < @$code_point_ranges; $i += 2) {
      my $min = $code_point_ranges->[$i];
      my $max = $code_point_ranges->[$i + 1];
      $negate_code_point_rainges_raw_list->push($min - 1);
      $negate_code_point_rainges_raw_list->push($max + 1);
    }
    $negate_code_point_rainges_raw_list->push(0x10FFFF);

    my $cur_max = 0;
    my $negate_code_point_rainges_list = IntList->new;
    for (my $i = 0; $i < $negate_code_point_rainges_raw_list->length; $i += 2) {
      my $min = $negate_code_point_rainges_raw_list->get($i);
      my $max = $negate_code_point_rainges_raw_list->get($i + 1);
      unless ($min > $max) {
        $negate_code_point_rainges_list->push($min);
        $negate_code_point_rainges_list->push($max);
      }
    }
    
    my $negate_code_point_rainges = $negate_code_point_rainges_list->to_array;

    return $negate_code_point_rainges;
  }
}

