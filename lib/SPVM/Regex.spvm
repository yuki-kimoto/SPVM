class Regex : precompile {
  use Unicode;
  use List;
  use IntList;
  use Hash;
  use StringBuffer;
  use Regex::Replacer;
  use Regex::Opcode;
  use Fn;
  has opcodes : List;
  has line_end : byte;
  has single_line_mode : byte;
  has ascii_mode : byte;
  has ignore_case : byte;
  
  has captures : ro string[];
  
  has match_begin : ro int;
  has match_length : ro int;
  
  has replace_count : ro int;
  has before_is_hyphen : byte;
  has before_is_open_bracket : byte;
  
  private enum {
    QUANTIFIER_STATUS_NOT_STARTED,
    QUANTIFIER_STATUS_MIN,
    QUANTIFIER_STATUS_MAX,
  }

  static method new : Regex ($re_str_and_options : string[]...) {
    
    my $re_str = $re_str_and_options->[0];
    my $options = (string)undef;
    if (@$re_str_and_options > 1) {
      $options = $re_str_and_options->[1];
    }
    
    my $self = Regex->new_with_options($re_str, $options);
    
    return $self;
  }

  static method new_with_options : Regex ($re_str : string, $option_chars : string) {
    my $self = Regex->_new_without_compile();
    
    if ($option_chars) {
      my $options_h = Hash->new({});
      
      my $option_chars_length = length $option_chars;
      for (my $i = 0; $i < $option_chars_length; $i++) {
        my $option_char = $option_chars->[$i];
        if ($option_char == 's') {
          my $found = $options_h->get("s");
          if ($found) {
            die "s option must be used once";
          }
          $self->{single_line_mode} = 1;
          $options_h->set_int("s" => 1);
        }
        elsif ($option_char == 'a') {
          my $found = $options_h->get("a");
          if ($found) {
            die "a option must be used once";
          }
          $self->{ascii_mode} = 1;
          $options_h->set_int("a" => 1);
        }
        elsif ($option_char == 'i') {
          my $found = $options_h->get("i");
          if ($found) {
            die "a option must be used once";
          }
          $self->{ignore_case} = 1;
          $options_h->set_int("i" => 1);
        }
      }
    }
    
    $self->compile($re_str);
    
    return $self;
  }
  
  private static method _new_without_compile : Regex () {
    my $self = new Regex;
    
    $self->{opcodes} = List->new_len(new Regex::Opcode[0], 0);

    $self->{captures} = new string[256];
    
    return $self;
  }
  
  private method compile : void ($re_str : string) {
    
    unless ($re_str) {
      die "Regex string must be defined";
    }
    
    my $re_str_length = length $re_str;
    
    if ($re_str_length == 0) {
      die "Regex string must have length";
    }
    
    my $pos = 0;
    my $opcodes = $self->{opcodes};
    
    my $quantifier_min_str = "";
    my $quantifier_max_str = "";
    
    my $quantifier_status = &QUANTIFIER_STATUS_NOT_STARTED;
    
    my $char_class_negate = 0;
    
    my $is_capture = 0;
    my $opcode_capture_begin = 0;
    
    my $cur_code_point_ranges_list = IntList->new;
    
    my $char_class_parsing = 0;
    my $quantifier_parsing = 0;
    while ((my $code_point = Unicode->uchar($re_str, \$pos)) >= 0) {
      
      my $before_is_hyphen = $self->{before_is_hyphen};
      $self->{before_is_hyphen} = 0;

      my $before_is_open_bracket = $self->{before_is_open_bracket};
      $self->{before_is_open_bracket} = 0;
      
      my $create_opcode = 0;
      
      my $line_begin = 0;
      switch ($code_point) {
        case '\\': {
          my $next_code_point = Unicode->uchar($re_str, \$pos);
          if ($code_point < 0) {
            die "Invalid regex. Last is \\ ";
          }
          
          switch ($next_code_point) {
            case 'd': {
              if ($self->{ascii_mode}) {
                unless ($char_class_parsing) {
                  $create_opcode = 1;
                }
                my $cur_code_point_range = [(int)'0', '9'];
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
              else {
                die "\d must be used with ascii option";
              }
              break;
            }
            case 'D': {
              if ($self->{ascii_mode}) {
                unless ($char_class_parsing) {
                  $create_opcode = 1;
                }
                my $cur_code_point_range = $self->negate_code_point_ranges([(int)'0', '9']);
                
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
              else {
                die "\D must be used with ascii option";
              }
              break;
            }
            case 'w': {
              if ($self->{ascii_mode}) {
                unless ($char_class_parsing) {
                  $create_opcode = 1;
                }
                my $cur_code_point_range = [(int)'0', '9', 'A', 'Z', '_', '_', 'a', 'z'];
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
              else {
                die "\w  must be used with ascii option";
              }
              break;
            }
            case 'W': {
              if ($self->{ascii_mode}) {
                unless ($char_class_parsing) {
                  $create_opcode = 1;
                }
                my $cur_code_point_range = $self->negate_code_point_ranges([(int)'0', '9', 'A', 'Z', '_', '_', 'a', 'z']);
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
              else {
                die "\W must be used with ascii option";
              }
              break;
            }
            case 's': {
              if ($self->{ascii_mode}) {
                unless ($char_class_parsing) {
                  $create_opcode = 1;
                }
                my $cur_code_point_range = [(int)'\t', '\t', '\n', '\n', '\f', '\f', '\r', '\r', ' ', ' '];
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
              else {
                die "\s must be used with ascii option";
              }
              break;
            }
            case 'S': {
              if ($self->{ascii_mode}) {
                unless ($char_class_parsing) {
                  $create_opcode = 1;
                }
                my $cur_code_point_range = $self->negate_code_point_ranges([(int)'\t', '\t', '\n', '\n', '\f', '\f', '\r', '\r', ' ', ' ']);
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
              else {
                die "\S must be used with ascii option";
              }
              break;
            }
            default: {
              if (Fn->is_perl_word($next_code_point)) {
                die "Invalid regex escape character";
              }
              # \: \- etc
              else {
                unless ($char_class_parsing) {
                  $create_opcode = 1;
                }
                my $cur_code_point_range = [(int)$next_code_point, $next_code_point];
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
            }
          }
          
          break;
        }
        default: {
          # Charcter class
          if ($char_class_parsing) {
            if ($code_point == ']') {
              $char_class_parsing = 0;
              $create_opcode = 1;
            }
            elsif ($code_point == '-') {
              my $cur_code_point_range = ['-', '-'];
              for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
              }
              $self->{before_is_hyphen} = 1;
            }
            else {
              # Charcater class negate
              if ($before_is_open_bracket && $code_point == '^') {
                $char_class_negate = 1;
              }
              else {
                if ($before_is_hyphen) {
                  # Pop '-'
                  $cur_code_point_ranges_list->pop;
                  $cur_code_point_ranges_list->pop;
                  
                  # Set max code point
                  $cur_code_point_ranges_list->set($cur_code_point_ranges_list->length - 1, $code_point);
                  
                  # Check min-max range
                  my $min = $cur_code_point_ranges_list->get($cur_code_point_ranges_list->length - 2);
                  my $max = $cur_code_point_ranges_list->get($cur_code_point_ranges_list->length - 1);
                  if ($min > $max) {
                    die "Invalid [] range";
                  }
                }
                else {
                  my $cur_code_point_range = [$code_point, $code_point];
                  for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                    $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                  }
                }
              }
            }
          }
          # Quantifier "{m,n}"
          elsif ($quantifier_parsing) {
            if ($code_point == '}') {
              unless ($quantifier_status == &QUANTIFIER_STATUS_MAX) {
                die "Invalid quantifier";
              }
              my $last_opcode = (Regex::Opcode)$opcodes->get($opcodes->length - 1);
              if (length $quantifier_max_str == 0) {
                $last_opcode->{max_repeat} = Fn->INT32_MAX;
              }
              else {
                my $quantifier_max = Fn->to_int($quantifier_max_str);
                $last_opcode->{max_repeat} = $quantifier_max;
              }
              
              $quantifier_status = &QUANTIFIER_STATUS_NOT_STARTED;
              $quantifier_max_str = "";
              
              $quantifier_parsing = 0;
              break;
            }
            else {
              if ($quantifier_status == &QUANTIFIER_STATUS_MIN) {
                if (Fn->is_digit($code_point)) {
                  $quantifier_min_str .= $code_point - '0';
                }
                elsif ($code_point == ',') {
                  my $last_opcode = (Regex::Opcode)$opcodes->get($opcodes->length - 1);
                  if (length $quantifier_min_str == 0) {
                    $last_opcode->{min_repeat} = 0;
                  }
                  else {
                    my $quantifier_min = Fn->to_int($quantifier_min_str);
                    $last_opcode->{min_repeat} = $quantifier_min;
                  }
                  $quantifier_status = &QUANTIFIER_STATUS_MAX();
                  $quantifier_min_str .= "";
                }
                else {
                  die "Invalid quantifier";
                }
              }
              elsif ($quantifier_status == &QUANTIFIER_STATUS_MAX) {
                if (Fn->is_digit($code_point)) {
                  $quantifier_max_str .= $code_point - '0';
                }
                else {
                  die "Invalid quantifier";
                }
              }
            }
          }
          else {
            switch ($code_point) {
              case '^': {
                $line_begin = 1;
                $create_opcode = 1;
                break;
              }
              case '$': {
                $self->{line_end} = 1;
                break;
              }
              case '.': {
                unless ($char_class_parsing) {
                  $create_opcode = 1;
                }
                my $cur_code_point_range = (int[])undef;
                if ($self->{single_line_mode}) {
                  $cur_code_point_range = [(int)0, 0xDFFF];
                }
                else {
                  $cur_code_point_range = $self->negate_code_point_ranges([(int)'\n', '\n']);
                }
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
                break;
              }
              case '|': {
                die "| is not supported";
                break;
              }
              case '(': {
                if ($is_capture) {
                  die "Invalid capture start";
                }
                else {
                  $is_capture = 1;
                  $opcode_capture_begin = 1;
                }
                break;
              }
              case ')': {
                if ($is_capture) {
                  $is_capture = 0;
                  my $before_opcode = (Regex::Opcode)$opcodes->get($opcodes->length - 1);
                  $before_opcode->{capture_end} = 1;
                }
                else {
                  die "Invalid capture end";
                }
                break;
              }
              case '[': {
                $char_class_parsing = 1;
                $self->{before_is_open_bracket} = 1;
                break;
              }
              case '*': {
                my $before_opcode = (Regex::Opcode)$opcodes->get($opcodes->length - 1);
                $before_opcode->{min_repeat} = 0;
                $before_opcode->{max_repeat} = Fn->INT32_MAX();
                break;
              }
              case '+': {
                my $before_opcode = (Regex::Opcode)$opcodes->get($opcodes->length - 1);
                $before_opcode->{min_repeat} = 1;
                $before_opcode->{max_repeat} = Fn->INT32_MAX();
                break;
              }
              case '?': {
                my $before_opcode = (Regex::Opcode)$opcodes->get($opcodes->length - 1);
                $before_opcode->{min_repeat} = 0;
                $before_opcode->{max_repeat} = 1;
                break;
              }
              case '{': {
                $quantifier_status = &QUANTIFIER_STATUS_MIN;
                $quantifier_parsing = 1;
                break;
              }
              default: {
                unless ($char_class_parsing) {
                  $create_opcode = 1;
                }
                my $cur_code_point_range = [$code_point, $code_point];
                for (my $i = 0; $i < @$cur_code_point_range; $i++) {
                  $cur_code_point_ranges_list->push($cur_code_point_range->[$i]);
                }
              }
            }
          }
        }
      }

      if ($create_opcode) {
        my $opcode = new Regex::Opcode;
        
        # Line begin
        if ($line_begin) {
          $opcode->{id} = Regex::Opcode->ID_LINE_BEGIN;
        }
        # charcater or caracter class
        else {
          $opcode->{id} = Regex::Opcode->ID_CHAR_CLASS;;
          $opcode->{char_class_negate} = (byte)$char_class_negate;
          $opcode->{code_point_ranges} = $cur_code_point_ranges_list->to_array;
          
          $opcode->{max_repeat} = 1;
          $opcode->{min_repeat} = 1;

          if ($opcode_capture_begin) {
            $opcode->{capture_begin} = 1;
            $opcode_capture_begin = 0;
          }
          
          $cur_code_point_ranges_list = IntList->new;
        }
        $opcodes->push($opcode);
      }
    }
  }
  
  method match : int ($target : string, $target_base_index : int) {
    
    unless ($target) {
      die "Target string must be defined";
    }
    
    my $opcodes = $self->{opcodes};
    my $opcodes_length = $opcodes->length;
    
    my $match_all = 0;
    my $target_forward_index = $target_base_index;
    my $target_forward_next_index = $target_forward_index;
    my $target_match_begin_index : int;
    my $ignore_case = $self->{ignore_case};
    while (1) {
      $target_match_begin_index = $target_forward_next_index;
      $target_forward_index = $target_forward_next_index;
      my $target_base_uchar = Unicode->uchar($target, \$target_forward_next_index);
      unless ($target_base_uchar >= 0) {
        last;
      }
      
      my $opcode_index = 0;
      
      my $opcode_capture_begin_index = -1;
      my $capture_count = 1;
      my $match_line_begin = 0;
      while (1) {
        if ($opcode_index >= $opcodes->length) {
          last;
        }
        my $opcode = (Regex::Opcode)$opcodes->get($opcode_index);
        
        # Line beginning "^"
        if ($opcode->{id} == Regex::Opcode->ID_LINE_BEGIN) {
          if ($target_forward_index == $target_base_index) {
            $match_line_begin = 1;
            $opcode_index++;
            next;
          }
          else {
            last;
          }
        }

        my $max_repeat = $opcode->{max_repeat};
        my $min_repeat = $opcode->{min_repeat};
        my $code_point_range = $opcode->{code_point_ranges};
        my $negate = $opcode->{char_class_negate};
        
        if ($opcode->{capture_begin}) {
          $opcode_capture_begin_index = $target_forward_index;
        }
        
        my $match_repeat = 0;
        my $repeat_count = 0;
        
        # Match uchar repeat
        my $repeat_index = 0;
        my $repeat_target_index = $target_forward_index;
        while (1) {
          if ($repeat_index >= $max_repeat) {
            last;
          };
          
          my $target_code_point = Unicode->uchar($target, \$target_forward_index);
          unless ($target_code_point >= 0) {
            last;
          }
        
          # Match uchar
          my $match_char = 0;
          
          # Match a character
          for (my $min_max_index = 0; $min_max_index < @$code_point_range; $min_max_index += 2) {
            my $code_point_min = $code_point_range->[$min_max_index];
            my $code_point_max = $code_point_range->[$min_max_index + 1];
            
            # Match a code point
            if ($target_code_point >= $code_point_min && $target_code_point <= $code_point_max) {
              $match_char = 1;
            }
            
            unless ($match_char) {
              # Try ignore case
              if ($ignore_case) {
                my $target_code_point_reverse_case = -1;
                # a-z
                if ($target_code_point >= 0x61 && $target_code_point <= 0x7A) {
                  $target_code_point_reverse_case = $target_code_point - 32;
                }
                # A-Z
                elsif ($target_code_point >= 0x41 && $target_code_point <= 0x5A) {
                  $target_code_point_reverse_case = $target_code_point + 32;
                }
                
                if ($target_code_point_reverse_case >= 0) {
                  if ($target_code_point_reverse_case >= $code_point_min && $target_code_point_reverse_case <= $code_point_max) {
                    $match_char = 1;
                  }
                }
              }
            }
            
            if ($match_char) {
              last;
            }
          }
          
          # Negate
          if ($negate) {
            $match_char = !$match_char;
          }
          
          # Increment repeat count
          if ($match_char) {
            $repeat_count++;
            $repeat_target_index = $target_forward_index;

            if ($target_forward_index == length $target) {
              last;
            }
          }
          else {
            last;
          }
          
          $repeat_index++;
        }
        if ($repeat_count >= $min_repeat) {
          $match_repeat = 1;
        }
        
        if ($match_repeat) {
          if ($opcode->{capture_end}) {
            $self->{captures}[$capture_count] = Fn->substr($target, $opcode_capture_begin_index, $repeat_target_index - $opcode_capture_begin_index);
            $capture_count++;
            if ($capture_count > 255) {
              die "Too many captures";
            }
          }
          $opcode_index++;
          $target_forward_index = $repeat_target_index;
          if ($opcode_index == $opcodes_length) {
            last;
          }
        }
        else {
          last;
        }
      }
      
      if ($opcode_index == $opcodes_length) {
        $match_all = 1;
        last;
      }
      else {
        if ($match_line_begin) {
          last;
        }
      }
    }
    
    my $really_match = 0;
    if ($match_all) {
      if ($self->{line_end}) {
        if ($target_forward_index == length $target) {
          $really_match = 1;
        }
      }
      else {
        $really_match = 1;
      }
    }
    
    if ($really_match) {
      $self->{match_begin} = $target_match_begin_index;
      $self->{match_length} = $target_forward_index - $self->{match_begin};
      $self->{captures}[0] = Fn->substr($target, $target_match_begin_index, $self->{match_length});
    }
    
    return $really_match;
  }
  
  method replace  : string ($target : string, $target_offset : int, $replace : string) {
    return $self->replace_opt($target, $target_offset, $replace, {replace_all => 0});
  }

  method replace_cb  : string ($target : string, $target_offset : int, $replace_cb : Regex::Replacer) {
    return $self->replace_opt($target, $target_offset, $replace_cb, {replace_all => 0});
  }

  method replace_all  : string ($target : string, $target_offset : int, $replace : string) {
    return $self->replace_opt($target, $target_offset, $replace, {replace_all => 1});
  }

  method replace_all_cb  : string ($target : string, $target_offset : int, $replace_cb : Regex::Replacer) {
    return $self->replace_opt($target, $target_offset, $replace_cb, {replace_all => 1});
  }
  
  private method replace_opt  : string ($target : string, $target_next_index : int, $replace_object : object, $options : object[]) {
    
    my $opt = Hash->new($options);
    
    my $original_target_base_index = $target_next_index;
    
    my $replace_all = 0;
    if (my $replace_all_obj = $opt->get("replace_all")) {
      $replace_all = (int)$replace_all_obj;
    }
    $self->{replace_count} = 0;
    
    unless ($target) {
      return $target;
    }
    
    my $result : string;
    my $replace_count = 0;
    my $result_buffer = StringBuffer->new;
    my $tarlength = length $target;
    
    if ($target_next_index > 0) {
      my $first_string = Fn->substr($target, 0, $target_next_index);
      $result_buffer->push($first_string);
    }
    
    while (my $match = $self->match($target, $target_next_index)) {
      
      my $match_begin = $self->match_begin;
      my $match_end = $match_begin + $self->match_length;
      
      my $replace : string;
      if ($replace_object isa string) {
        $replace = (string)$replace_object;
      }
      elsif ($replace_object isa object[]) {
        
        my $replace_objects = (object[])$replace_object;
        
        my $replace_buffer = StringBuffer->new;
        for (my $i = 0; $i < @$replace_objects; $i++) {
          my $replace_elem_object = $replace_objects->[$i];
          
          if ($replace_elem_object isa string) {
            $replace_buffer->push((string)$replace_elem_object);
          }
          elsif ($replace_elem_object isa Int) {
            my $capture = $self->captures->[(int)$replace_elem_object];
            $replace_buffer->push($capture);
          }
          else {
            die "Invalid replace argument element";
          }
        }
        
        $replace = $replace_buffer->to_string;
      }
      elsif ($replace_object isa Regex::Replacer) {
        my $replace_buffer = StringBuffer->new;
        my $replacer = (Regex::Replacer)$replace_object;
        my $cb_result = $replacer->($self);
        $replace_buffer->push($cb_result);
        $replace = $replace_buffer->to_string;
      }
      else {
        die "Invalid replace argument";
      }
      
      my $match_length = $self->match_length;
      my $replace_length = length $replace;
      
      my $result_length = $tarlength + $replace_length - $match_length;
      
      $result = (mutable string)new_string_len($result_length);
      
      my $rest_length = $tarlength - $match_end;
      
      my $before_result = (mutable string)Fn->substr($target, $target_next_index, $match_begin - $target_next_index);
      $result_buffer->push($before_result);
      $result_buffer->push($replace);
      
      $replace_count++;
      
      unless ($replace_all) {
        last;
      }
      $target_next_index = $match_end;
    }
    
    
    if ($replace_count == 0) {
      $result = Fn->copy_string($target);
    }
    else {
      my $match_end = $self->match_begin + $self->match_length;
      my $rest_length = $tarlength - $match_end;
      
      if ($rest_length > 0) {
        my $rest_string = Fn->substr($target, $match_end, $rest_length);
        $result_buffer->push($rest_string);
      }
      
      $result = $result_buffer->to_string;
    }
    
    $self->{replace_count} = $replace_count;
    
    return $result;
  }
  
  method cap0 : string () { return $self->captures->[0]; }
  method cap1 : string () { return $self->captures->[1]; }
  method cap2 : string () { return $self->captures->[2]; }
  method cap3 : string () { return $self->captures->[3]; }
  method cap4 : string () { return $self->captures->[4]; }
  method cap5 : string () { return $self->captures->[5]; }
  method cap6 : string () { return $self->captures->[6]; }
  method cap7 : string () { return $self->captures->[7]; }
  method cap8 : string () { return $self->captures->[8]; }
  method cap9 : string () { return $self->captures->[9]; }
  method cap10 : string () { return $self->captures->[10]; }

  private method culcurate_code_point_ranges : int[] ($code_point_raw_ranges_list : IntList) {
    my $code_point_ranges_list = IntList->new;
    for (my $i = 0; $i < $code_point_raw_ranges_list->length; $i++) {
      my $value = $code_point_raw_ranges_list->get($i);
      if ($value >= 0) {
        $code_point_ranges_list->push($value);
      }
    }
    
    return $code_point_ranges_list->to_array;
  }

  private method negate_code_point_ranges : int[] ($code_point_ranges : int[]) {
    
    if (@$code_point_ranges < 2) {
      die "The length of the code point rainges must be more than 2";
    }

    my $negate_code_point_rainges_raw_list = IntList->new;
    $negate_code_point_rainges_raw_list->push(0);
    for (my $i = 0; $i < @$code_point_ranges; $i += 2) {
      my $min = $code_point_ranges->[$i];
      my $max = $code_point_ranges->[$i + 1];
      $negate_code_point_rainges_raw_list->push($min - 1);
      $negate_code_point_rainges_raw_list->push($max + 1);
    }
    $negate_code_point_rainges_raw_list->push(0x10FFFF);

    my $cur_max = 0;
    my $negate_code_point_rainges_list = IntList->new;
    for (my $i = 0; $i < $negate_code_point_rainges_raw_list->length; $i += 2) {
      my $min = $negate_code_point_rainges_raw_list->get($i);
      my $max = $negate_code_point_rainges_raw_list->get($i + 1);
      unless ($min > $max) {
        $negate_code_point_rainges_list->push($min);
        $negate_code_point_rainges_list->push($max);
      }
    }
    
    my $negate_code_point_rainges = $negate_code_point_rainges_list->to_array;

    return $negate_code_point_rainges;
  }
}

