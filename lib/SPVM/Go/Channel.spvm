# Copyright (c) 2023 Yuki Kimoto
# MIT License

class Go::Channel {
  
  use Hash;
  use Sync::Mutex;
  use Go::Channel::ReadCallback;
  
  private enum {
    READABLE_STATE_NONE,
    READABLE_STATE_EXISTS,
    READABLE_STATE_FINISHED,
  }
  
  # Fields
  has capacity : int;
  
  has base_offset : int;
  
  has length : int;
  
  has values_in_buffer : object[];
  
  has readable_value : object;
  
  has readable_state : int;
  
  has mutex : Sync::Mutex;
  
  has closed : int;
  
  has read_cb : rw Go::Channel::ReadCallback;
  
  # Class Methods
  static method new : Go::Channel ($options : object[] = undef) {
    
    &check_option_names($options, ["capacity"]);
    
    my $options_h = Hash->new($options);
    
    my $self = new Go::Channel;
    
    my $capacity = $options_h->delete_or_default_int("capacity", 0);
    $self->{capacity} = $capacity;
    
    unless ($capacity >= 0) {
      die "The \"capacity\" option must be greater than or equal to 0.";
    }
    
    my $values_in_buffer = new object[$capacity];
    $self->{values_in_buffer} = $values_in_buffer;
    
    my $mutex = Sync::Mutex->new;
    $self->{mutex} = $mutex;
    
    if ($capacity == 0) {
      $mutex->lock;
    }
    
    return $self;
  }
  
  static method make : Go::Channel ($capacity : int = 0) {
    my $self = &new({capacity => $capacity});
    
    return $self;
  }
  
  private static method check_option_names : void ($options : object[], $available_option_names : string[]) {
    
    unless ($options) {
      return;
    }
    
    my $available_option_names_h = Hash->new;
    for my $available_option_name (@$available_option_names) {
     $available_option_names_h->set_int($available_option_name, 1);
    }
    
    for (my $i = 0; $i < @$options; $i += 2) {
      my $option_name = (string)$options->[$i];
      
      unless ($available_option_names_h->get($option_name)) {
        die "The \"$option_name\" option is not available.";
      }
    }
  }
  
  # Instance Methods
  method read : object ($error_ref : int*) {
    
    $$error_ref = 0;
    
    my $closed = $self->{closed};
    
    if ($closed) {
      $$error_ref = 1;
      return undef;
    }
    
    while (1) {
      my $readable_state = $self->{readable_state};
      
      if ($readable_state == &READABLE_STATE_EXISTS) {
        my $object = $self->{readable_value};
        $self->{readable_state} =  &READABLE_STATE_FINISHED;
        
        return $object;
      }
      else {
        my $length = $self->{length};
        
        if ($length > 0) {
          my $base_offset = $self->{base_offset};
          my $values_in_buffer = $self->{values_in_buffer};
          
          my $object = $values_in_buffer->[$base_offset];
          $self->{readable_value} = $object;
          $self->{readable_state} = &READABLE_STATE_EXISTS;
          
          $values_in_buffer->[$base_offset] = undef;
          
          $base_offset++;
          
          if ($base_offset >= $length) {
            $base_offset = 0;
          }
          
          $length -= 1;
          
          $self->{base_offset} = $base_offset;
          $self->{length} = $length;
        }
      }
    }
  }
  
  method write : void ($object : object) {
    my $closed = $self->{closed};
    
    if ($closed) {
      die "This channel is closed.";
    }
    
    my $capacity = $self->{capacity};
    
    if ($capacity == 0) {
      
      while (1) {
        my $readable_state = $self->{readable_state};
        if ($readable_state == &READABLE_STATE_NONE) {
          $self->{readable_value} = $object;
          $self->{readable_state} = &READABLE_STATE_EXISTS;
          return;
        }
      }
    }
    else {
      while (1) {
        my $capacity = $self->{capacity};
        my $length = $self->{length};
        
        if ($length < $capacity) {
          my $values_in_buffer = $self->{values_in_buffer};
          my $base_offset = $self->{base_offset};
          my $offset = $base_offset + $length;
          if ($offset >= $length) {
            $offset -= $base_offset;
          }
          
          $values_in_buffer->[$offset] = $object;
          $length++;
          
          $self->{length} = $length;
          return;
        }
      }
    }
    
  }
  
  method close : void () {
    my $closed = $self->{closed};
    
    if ($closed) {
      die "This channel is already closed.";
    }
    
    $self->{closed} = 1;
  }
  
  method cap : int () {
    return $self->{capacity};
  }
  
  method len : int () {
    return $self->{length};
  }
  
}
