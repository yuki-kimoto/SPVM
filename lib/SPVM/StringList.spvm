# Copyright (c) 2023 Yuki Kimoto
# MIT License

class StringList extends List {
  use Fn;
  use Array;
  
  # Enumerations
  enum {
    DEFAULT_CAPACITY = 4,
  }
  
  # Class methods
  static method new : StringList ($array : string[] = undef, $capacity : int = -1) {
    my $length : int;
    if ($array) {
      $length = @$array;
    }
    else {
      $length = 0;
    }
    
    my $self = &new_len($length, $capacity);
    
    if ($array) {
      Array->memcpy_object_address($self->{array}, 0, $array, 0, $length);
    }
    
    return $self;
  }
  
  static method new_len : StringList ($length : int, $capacity : int = -1) {
    my $self = new StringList;
    
    unless ($length >= 0) {
      die "\$length must be greater than or equal to 0.";
    }
    
    if ($capacity < 0) {
      $capacity = &DEFAULT_CAPACITY;
    }
    
    if ($length > $capacity) {
      $capacity = $length;
    }
    
    $self->{capacity} = $capacity;
    $self->{length} = $length;
    $self->{array} = new string[$capacity];
    
    return $self;
  }
  
  # Instance methods
  method get : string ($index : int) {
    return (string)$self->SUPER::get($index);
  }
  
  method insert : void ($index : int, $element : string) {
    $self->SUPER::insert($index, $element);
  }
  
  method pop : string () {
    return (string)$self->SUPER::pop;
  }
  
  method push : void ($element : string) {
    $self->SUPER::push($element);
  }
  
  method remove : string ($index : int) {
    return (string)$self->SUPER::remove($index);
  }
  
  method replace : void ($offset : int, $remove_length : int, $replace : string[]) {
    $self->SUPER::replace($offset, $remove_length, $replace);
  }
  
  method reserve : void ($new_capacity : int) {
    unless ($new_capacity >= 0) {
      die "\$new_capacity must be greater than or equal to 0.";
    }
    
    my $capacity = $self->{capacity};
    
    if ($new_capacity > $capacity) {
      my $length = $self->{length};
      my $new_array = new string[$new_capacity];
      Array->memcpy_object_address($new_array, 0, $self->{array}, 0, $length);
      $self->{array} = $new_array;
      $self->{capacity} = $new_capacity;
    }
  }
  
  method resize : void ($new_length : int) {
    $self->SUPER::resize($new_length);
  }
  
  method set : void ($index : int, $element : string) {
    $self->SUPER::set($index, $element);
  }
  
  method set_array : void ($array : string[]) {
    $self->SUPER::set_array($array);
  }
  
  method shift : string () {
    return (string)$self->SUPER::shift;
  }
  
  method to_array : string[] () {
    
    my $length = $self->length;
    
    my $new_array = new string[$length];
    
    my $elements = $self->{array};
    
    Array->memcpy_object_address($new_array, 0, $elements, 0, $length);
    
    return $new_array;
  }
  
  method get_array_unsafe : string[] () {
    return (string[])$self->SUPER::get_array_unsafe;
  }
  
  method unshift : void ($element : string) {
    $self->SUPER::unshift($element);
  }
  
  private method _maybe_extend : void ($min_capacity : int) {
    my $capacity = $self->{capacity};
    
    unless ($min_capacity > $capacity) {
      return;
    }
    
    if ($capacity < $min_capacity) {
      $capacity = $min_capacity;
    }
    
    my $new_capacity = $capacity * 2;
    my $new_array = new string[$new_capacity];
    
    my $length = $self->{length};
    my $elements = $self->{array};
    Array->memcpy_object_address($new_array, 0, $elements, 0, $length);
    
    $self->{array} = $new_array;
    $self->{capacity} = $new_capacity;
  }
}
