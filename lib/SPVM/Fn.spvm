class Fn {
  use StringBuffer;
  use StringList;
  use Stringer;
  use Cloner;
  use EqualityChecker;
  use Array;
  use Format;
  
  # C-like max and minimal constants
  static method INT8_MAX : byte () { return 127; }
  static method INT8_MIN : byte () { return -128; }
  static method INT16_MAX : short () { return 32767; }
  static method INT16_MIN : short () { return -32768; }
  static method INT32_MAX : int () { return 2147483647; }
  static method INT32_MIN : int () { return -2147483648; }
  static method INT64_MAX : long () { return 9223372036854775807L; }
  static method INT64_MIN : long () { return -9223372036854775808L; }
  static method UINT8_MAX : byte () { return (byte)0xFF; }
  static method UINT16_MAX : short () { return (short)0xFFFF; }
  static method UINT32_MAX : int () { return 0xFFFFFFFF; }
  static method UINT64_MAX : long () { return 0xFFFFFFFFFFFFFFFFL; }
  native static method FLT_MAX : float ();
  native static method FLT_MIN : float();
  native static method DBL_MAX : double ();
  native static method DBL_MIN : double ();

  # SPVM-like max and minimal constants
  static method BYTE_MAX : byte () { return 127; }
  static method BYTE_MIN : byte () { return -128; }
  static method SHORT_MAX : short () { return 32767; }
  static method SHORT_MIN : short () { return -32768; }
  static method INT_MAX : int () { return 2147483647; }
  static method INT_MIN : int () { return -2147483648; }
  static method LONG_MAX : long () { return 9223372036854775807L; }
  static method LONG_MIN : long () { return -9223372036854775808L; }
  static method UBYTE_MAX : byte () { return (byte)0xFF; }
  static method USHORT_MAX : short () { return (short)0xFFFF; }
  static method UINT_MAX : int () { return 0xFFFFFFFF; }
  static method ULONG_MAX : long () { return 0xFFFFFFFFFFFFFFFFL; }
  native static method FLOAT_MAX : float ();
  native static method FLOAT_MIN : float();
  native static method DOUBLE_MAX : double ();
  native static method DOUBLE_MIN : double ();

  native static method RAND_MAX : int ();

  static method abs : int ($x : int) {
    
    my $ret = 0;
    if ($x > 0) {
      $ret = $x;
    }
    else {
      $ret = -$x;
    }
    return $ret;
  }

  static method chomp : void ($string : mutable string) {
    
    unless ($string) {
      return;
    }

    my $length = length $string;
    if ($length > 0) {
      if ($string->[$length - 1] == '\n') {
        &shorten($string, $length - 1);
      }
    }
  }

  static method chompr : string ($string : string) {
    unless ($string) {
      return undef;
    }

    my $new_string : string;
    my $length = length $string;
    if ($length == 0) {
      $new_string = copy $string;
    }
    else {
      if ($string->[$length - 1] == '\n') {
        $new_string = &substr($string, 0, $length - 1);
      }
      else {
        $new_string = copy $string;
      }
    }

    return $new_string;
  }

  private static method is_unicode_scalar_value : int ($code_point: int) {
    my $is_unicode_scalar_value = 0;
    # The range of Unicde code points
    if ($code_point >= 0 && $code_point <= 0x10FFFF) {
      # Not surrogate code points
      unless ($code_point >= 0xD800 && $code_point <= 0xDFFF) {
        $is_unicode_scalar_value = 1;
      }
    }
    
    return $is_unicode_scalar_value;
  }

  static method chr : string ($unicode_code_point : int) {
    
    my $is_unicode_scalar_value = &is_unicode_scalar_value($unicode_code_point);
    my $utf8_char = (string)undef;
    if ($is_unicode_scalar_value) {
      $utf8_char = &_chr_native($unicode_code_point);
    }

    return $utf8_char;
  }
  native static method _chr_native : string ($uchar : int);

  static method contains : int ($string : string, $sub_string : string) {
    my $contains = 0;
    if (&index($string, $sub_string, 0) >= 0) {
      $contains = 1;
    }
    return $contains;
  }
  
  static method copy_array_byte : byte[] ($nums : byte[]) {
    warn "Fn->copy_array_byte is deprecated. Use Array->copy_byte instead";
    return Array->copy_byte($nums);
  }

  static method copy_array_double : double[] ($nums : double[]) {
    warn "Fn->copy_array_double is deprecated. Use Array->copy_double instead";
    return Array->copy_double($nums);
  }

  static method copy_array_float : float[] ($nums : float[]) {
    warn "Fn->copy_array_float is deprecated. Use Array->copy_float instead";
    return Array->copy_float($nums);
  }

  static method copy_array_int : int[] ($nums : int[]) {
    warn "Fn->copy_array_int is deprecated. Use Array->copy_int instead";
    return Array->copy_int($nums);
  }

  static method copy_array_long : long[] ($nums : long[]) {
    warn "Fn->copy_array_long is deprecated. Use Array->copy_long instead";
    return Array->copy_long($nums);
  }

  static method copy_array_object : object[] ($objects : object[], $cloner : Cloner) {
    warn "Fn->copy_array_object is deprecated. Use Array->copy_object instead";
    return Array->copy_object($objects, $cloner);
  }

  static method copy_array_range_byte : byte[] ($nums : byte[], $offset : int, $length : int) {
    warn "Fn->copy_array_range_byte is deprecated. Use Array->copy_range_byte instead";
    return Array->copy_range_byte($nums, $offset, $length);
  }

  static method copy_array_range_double : double[] ($nums : double[], $offset : int, $length : int) {
    warn "Fn->copy_array_range_double is deprecated. Use Array->copy_range_double instead";
    return Array->copy_range_double($nums, $offset, $length);
  }

  static method copy_array_range_float : float[] ($nums : float[], $offset : int, $length : int) {
    warn "Fn->copy_array_range_float is deprecated. Use Array->copy_range_float instead";
    return Array->copy_range_float($nums, $offset, $length);
  }

  static method copy_array_range_int : int[] ($nums : int[], $offset : int, $length : int) {
    warn "Fn->copy_array_range_int is deprecated. Use Array->copy_range_int instead";
    return Array->copy_range_int($nums, $offset, $length);
  }

  static method copy_array_range_long : long[] ($nums : long[], $offset : int, $length : int) {
    warn "Fn->copy_array_range_long is deprecated. Use Array->copy_range_long instead";
    return Array->copy_range_long($nums, $offset, $length);
  }

  static method copy_array_range_object : object[] ($objects : object[], $offset : int, $length : int) {
    warn "Fn->copy_array_range_object is deprecated. Use Array->copy_range_object instead";
    return Array->copy_range_object($objects, $offset, $length);
  }

  static method copy_array_range_short : short[] ($nums : short[], $offset : int, $length : int) {
    warn "Fn->copy_array_range_short is deprecated. Use Array->copy_range_short instead";
    return Array->copy_range_short($nums, $offset, $length);
  }


  precompile static method copy_array_range_string : string[] ($strings : string[], $offset : int, $length : int) {
    warn "Fn->copy_array_range_string is deprecated. Use Array->copy_range_string instead";
    return Array->copy_range_string($strings, $offset, $length);
  }

  static method copy_array_short : short[] ($nums : short[]) {
    return copy $nums;
  }

  precompile static method copy_array_string : string[] ($strings : string[]) {
    warn "Fn->copy_array_string is deprecated. Use Array->copy_tring instead";
    return Array->copy_string($strings);
  }
  
  static method copy_string : string ($string : string) {
    return copy $string;
  }

  native static method crand : int ($seed : int*);

  static method dump_array_byte : string ($nums : byte[]) {
    warn "Fn->dump_array_byte is deprecated. Use Array->dump_byte instead";
    return Array->dump_byte($nums);
  }

  static method dump_array_double : string ($nums : double[]) {
    warn "Fn->dump_array_double is deprecated. Use Array->dump_double instead";
    return Array->dump_double($nums);
  }

  static method dump_array_float : string ($nums : float[]) {
    warn "Fn->dump_array_float is deprecated. Use Array->dump_float instead";
    return Array->dump_float($nums);
  }

  static method dump_array_int : string ($nums : int[]) {
    warn "Fn->dump_array_int is deprecated. Use Array->dump_int instead";
    return Array->dump_int($nums);
  }

  static method dump_array_long : string ($nums : long[]) {
    warn "Fn->dump_array_long is deprecated. Use Array->dump_long instead";
    return Array->dump_long($nums);
  }

  static method dump_array_object : string ($objects : object[], $stringer : Stringer) {
    warn "Fn->dump_array_object is deprecated. Use Array->dump_object instead";
    return Array->dump_object($objects, $stringer);
  }

  static method dump_array_short : string ($nums : short[]) {
    warn "Fn->dump_array_short is deprecated. Use Array->dump_short instead";
    return Array->dump_short($nums);
  }

  static method dump_array_string : string ($strings : string[]) {
    warn "Fn->dump_array_string is deprecated. Use Array->dump_string instead";
    return Array->dump_string($strings);
  }

  static method dump_array_unsigned_byte : string ($nums : byte[]) {
    warn "Fn->dump_array_unsigned_byte is deprecated. Use Array->dump_unsigned_byte instead";
    return Array->dump_unsigned_byte($nums);
  }

  static method dump_array_unsigned_int : string ($nums : int[]) {
    warn "Fn->dump_array_unsigned_int is deprecated. Use Array->dump_unsigned_int instead";
    return Array->dump_unsigned_int($nums);
  }

  static method dump_array_unsigned_long : string ($nums : long[]) {
    warn "Fn->dump_array_unsigned_long is deprecated. Use Array->dump_unsigned_long instead";
    return Array->dump_unsigned_long($nums);
  }

  static method dump_array_unsigned_short : string ($nums : short[]) {
    warn "Fn->dump_array_unsigned_short is deprecated. Use Array->dump_unsigned_short instead";
    return Array->dump_unsigned_short($nums);
  }

  native static method get_next_code_point : int ($str : string, $offset_ref : int*);
  
  static method equals_array_byte : int ($nums1 : byte[], $nums2 : byte[]) {
    warn "Fn->equals_array_byte is deprecated. Use Array->equals_byte instead";
    return Array->equals_byte($nums1, $nums2);
  }

  static method equals_array_double : int ($nums1 : double[], $nums2 : double[]) {
    warn "Fn->equals_array_double is deprecated. Use Array->equals_double instead";
    return Array->equals_double($nums1, $nums2);
  }

  static method equals_array_float : int ($nums1 : float[], $nums2 : float[]) {
    warn "Fn->equals_array_float is deprecated. Use Array->equals_float instead";
    return Array->equals_float($nums1, $nums2);
  }

  static method equals_array_int : int ($nums1 : int[], $nums2 : int[]) {
    warn "Fn->equals_array_int is deprecated. Use Array->equals_int instead";
    return Array->equals_int($nums1, $nums2);
  }
  static method equals_array_long : int ($nums1 : long[], $nums2 : long[]) {
    warn "Fn->equals_array_long is deprecated. Use Array->equals_long instead";
    return Array->equals_long($nums1, $nums2);
  }

  static method equals_array_object : int ($objects1 : object[], $objects2 : object[], $equality_checker : EqualityChecker) {
    warn "Fn->equals_array_object is deprecated. Use Array->equals_object instead";
    return Array->equals_object($objects1, $objects2, $equality_checker);
  }

  static method equals_array_short : int ($nums1 : short[], $nums2 : short[]) {
    warn "Fn->equals_array_short is deprecated. Use Array->equals_short instead";
    return Array->equals_short($nums1, $nums2);
  }

  static method equals_array_string : int ($strings1 : string[], $strings2 : string[]) {
    warn "Fn->equals_array_string is deprecated. Use Array->equals_string instead";
    return Array->equals_string($strings1, $strings2);
  }

  precompile static method hex : int ($hex_string : string) {
    
    unless ($hex_string) {
      die "the hex string must be defined";
    }
    
    my $hex_value = 0;
    my $digit = 0;
    my $value = 0;
    my $length = length $hex_string;
    if ($length < 1 || $length > 8) {
      die "The length of hex string must be 1 to 8";
    }
    for (my $i = $length - 1; $i >= 0; $i--) {
      my $ascii_code = $hex_string->[$i];
      
      unless (&is_hex_digit($ascii_code)) {
        die "The hex string is invalid format";
      }
      
      my $digit_value = 0;
      if ($ascii_code >= '0' && $ascii_code <= '9') {
        $digit_value = $ascii_code - 48;
      }
      elsif ($ascii_code >= 'a' && $ascii_code <= 'f') {
        $digit_value = $ascii_code - 87;
      }
      elsif ($ascii_code >= 'A' && $ascii_code <= 'F') {
        $digit_value = $ascii_code - 55;
      }
      $value += $digit_value * &powi(16, $digit);
      
      $digit += 1;
    }
    
    return $value;
  }

  static method index : int ($string : string, $sub_string : string, $start_pos : int) {
    return &index_len($string, $sub_string, $start_pos, length $string);
  }

  precompile static method index_len : int ($string : string, $sub_string : string, $start_pos : int, $max_string_length : int) {
    my $sub_string_length = length $sub_string;
    
    if ($max_string_length > length $string) {
      $max_string_length = length $string;
    }

    if ($start_pos >= $max_string_length) {
      my $ret : int;
      if ($sub_string_length == 0) {
        $ret = $max_string_length;
      }
      else {
        $ret = -1;
      }
      return $ret;
    }
    if ($start_pos < 0) {
      $start_pos = 0;
    }
    if ($sub_string_length == 0) {
      return $start_pos;
    }

    my $first : byte  = $sub_string->[0];
    my $max : int = ($max_string_length - $sub_string_length);

    for (my $i = $start_pos; $i <= $max; $i++) {
      if ($string->[$i] != $first) {
        while (++$i <= $max && $string->[$i] != $first) {}
      }

      if ($i <= $max) {
        my $j = $i + 1;
        my $end = $j + $sub_string_length - 1;
        for (my $k = 01; $j < $end && $string->[$j] == $sub_string->[$k]; ($j++, $k++)) {}

        if ($j == $end) {
          return $i;
        }
      }
    }
    return -1;
  }

  static method is_alnum : int ($code_point : int) {

    if (($code_point >= 'A' && $code_point <= 'Z') || ($code_point >= 'a' && $code_point <= 'z') || ($code_point >= '0' && $code_point <= '9')) {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_alpha : int ($code_point : int) {

    if (($code_point >= 'A' && $code_point <= 'Z') || ($code_point >= 'a' && $code_point <= 'z')) {
      return 1;
    }
    else {
      return 0;
    }
  }

  native static method is_array : int ($object : object);

  static method is_blank : int ($code_point : int) {

    if ($code_point >= ' ' ||  $code_point <= '\t') {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_cntrl : int ($code_point : int) {

    if (($code_point >= 0x00 && $code_point <= 0x1f) || $code_point == 0x7f) {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_digit : int ($code_point : int) {

    if ($code_point >= '0' && $code_point <= '9') {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_graph : int ($code_point : int) {

    if ($code_point >= 0x21 && $code_point <= 0x7e) {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_hex_digit : int ($code_point : int) {

    if (($code_point >= '0' && $code_point <= '9') || ($code_point >= 'a' && $code_point <= 'f') || ($code_point >= 'A' && $code_point <= 'F')) {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_lower : int ($code_point : int) {

    if ($code_point >= 'a' && $code_point <= 'z') {
      return 1;
    }
    else {
      return 0;
    }
  }

  native static method is_mulnum_array : int ($object : object);

  native static method is_numeric_array : int ($object : object);

  native static method is_object_array : int ($object : object);

  # This is same as Perl \s
  static method is_perl_space : int ($code_point : int) {
    my $ispspace = 0;
    switch ($code_point) {
      case ' ':
      case '\r':
      case '\n':
      case '\t':
      case '\f':
      {
        $ispspace = 1;
        break;
      }
    }
    return $ispspace;
  }

  static method is_perl_word : int ($code_point : int) {
    my $ispword = 0;

    if ($code_point >= 'a' && $code_point <= 'z') {
      $ispword = 1;
    }
    elsif ($code_point >= 'A' && $code_point <= 'Z') {
      $ispword = 1;
    }
    elsif ($code_point == '_') {
      $ispword = 1;
    }
    elsif ($code_point >= '0' && $code_point <= '9') {
      $ispword = 1;
    }
    return $ispword;
  }

  static method is_print : int ($code_point : int) {

    if ($code_point >= 0x20 && $code_point <= 0x7e) {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_punct : int ($code_point : int) {

    if (($code_point >= 0x21 && $code_point <= 0x2f) || ($code_point >= 0x3a && $code_point <= 0x40) || ($code_point >= 0x5b && $code_point <= 0x60) || ($code_point >= 0x7b && $code_point <= 0x7e)) {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_space : int ($code_point : int) {

    if (($code_point >= 0x09 && $code_point <= 0x0d) || $code_point == 0x20) {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_upper : int ($code_point : int) {

    if ($code_point >= 'A' && $code_point <= 'Z') {
      return 1;
    }
    else {
      return 0;
    }
  }

  static method is_xdigit : int ($code_point : int) {

    if (($code_point >= 'A' && $code_point <= 'F') || ($code_point >= 'a' && $code_point <= 'f') || ($code_point >= '0' && $code_point <= '9')) {
      return 1;
    }
    else {
      return 0;
    }
  }

  precompile static method join : string ($sep : string, $strings : string[]) {
    my $join = "";

    for (my $i = 0; $i < @$strings; $i++) {
      my $string = $strings->[$i];
      $join .= $string;
      if ($i != @$strings - 1) {
        $join .= $sep;
      }
    }

    return $join;
  }

  static method labs : long ($x : long) {
    
    my $ret = 0L;
    if ($x > 0) {
      $ret = $x;
    }
    else {
      $ret = -$x;
    }
    return $ret;
  }

  precompile static method lc : string ($string : string) {

    unless ($string) { die "String must be defined"; }

    my $length = length $string;
    my $new_string = (mutable string)new_string_len($length);
    for (my $i = 0; $i < $length; $i++) {
      my $char = $string->[$i];
      if ($char >= 'A' && $char <= 'Z') {
        $new_string->[$i] = (byte)($string->[$i] + 32);
      }
      else {
        $new_string->[$i] = $string->[$i];
      }
    }
    return (string)$new_string;
  }

  precompile static method lcfirst : string ($string : string) {

    unless ($string) { die "String must be defined"; }

    my $length = length $string;
    my $new_string = (mutable string)new_string_len($length);
    if ($length > 0) {
      my $char = $string->[0];
      if ($char >= 'A' && $char <= 'Z') {
        $new_string->[0] = (byte)($char + 32);
      }
      else {
        $new_string->[0] = $char;
      }
    }
    for (my $i = 1; $i < $length; ++$i) {
      $new_string->[$i] = $string->[$i];
    }
    return (string)$new_string;
  }

  static method look_next_code_point : int ($string : string, $offset_ref : int*) {
    my $save_offset = $$offset_ref;
    my $code_point = &get_next_code_point($string, $offset_ref);
    $$offset_ref = $save_offset;
    return $code_point;
  }

  static method memset_byte : void ($dest : byte[], $dest_offset : int, $value : byte, $length : int) {
    warn "Fn->memset_byte is deprecated. Use Array->memset_byte instead";
    Array->memset_byte($dest, $dest_offset, $value, $length);
  }
  static method memset_double : void ($dest : double[], $dest_offset : int, $value : double, $length : int) {
    warn "Fn->memset_double is deprecated. Use Array->memset_double instead";
    Array->memset_double($dest, $dest_offset, $value, $length);
  }
  static method memset_float : void ($dest : float[], $dest_offset : int, $value : float, $length : int) {
    warn "Fn->memset_float is deprecated. Use Array->memset_float instead";
    Array->memset_float($dest, $dest_offset, $value, $length);
  }
  static method memset_int : void ($dest : int[], $dest_offset : int, $value : int, $length : int) {
    warn "Fn->memset_int is deprecated. Use Array->memset_int instead";
    Array->memset_int($dest, $dest_offset, $value, $length);
  }
  static method memset_long : void ($dest : long[], $dest_offset : int, $value : long, $length : int) {
    warn "Fn->memset_long is deprecated. Use Array->memset_long instead";
    Array->memset_long($dest, $dest_offset, $value, $length);
  }
  static method memset_short : void ($dest : short[], $dest_offset : int, $value : short, $length : int) {
    warn "Fn->memset_short is deprecated. Use Array->memset_short instead";
    Array->memset_short($dest, $dest_offset, $value, $length);
  }
  static method memset_object : void ($dest : object[], $dest_offset : int, $value : object, $length : int) {
    warn "Fn->memset_object is deprecated. Use Array->memset_object instead";
    Array->memset_object($dest, $dest_offset, $value, $length);
  }
  
  native static method memcpy : void ($dest : object, $dest_byte_offset : int, $source : object, $source_byte_offset : int, $byte_length : int);
  
  static method memcpy_byte : void ($dest : byte[], $dest_offset : int, $source : byte[], $source_offset : int, $length : int) {
    warn "Fn->memcpy_byte is deprecated. Use Array->memcpy_byte instead";
    Array->memcpy_byte($dest, $dest_offset, $source, $source_offset, $length);
  }
  static method memcpy_double : void ($dest : double[], $dest_offset : int, $source : double[], $source_offset : int, $length : int) {
    warn "Fn->memcpy_double is deprecated. Use Array->memcpy_double instead";
    Array->memcpy_double($dest, $dest_offset, $source, $source_offset, $length);
  }
  static method memcpy_float : void ($dest : float[], $dest_offset : int, $source : float[], $source_offset : int, $length : int) {
    warn "Fn->memcpy_float is deprecated. Use Array->memcpy_float instead";
    Array->memcpy_float($dest, $dest_offset, $source, $source_offset, $length);
  }
  static method memcpy_int : void ($dest : int[], $dest_offset : int, $source : int[], $source_offset : int, $length : int) {
    warn "Fn->memcpy_int is deprecated. Use Array->memcpy_int instead";
    Array->memcpy_int($dest, $dest_offset, $source, $source_offset, $length);
  }
  static method memcpy_long : void ($dest : long[], $dest_offset : int, $source : long[], $source_offset : int, $length : int) {
    warn "Fn->memcpy_long is deprecated. Use Array->memcpy_long instead";
    Array->memcpy_long($dest, $dest_offset, $source, $source_offset, $length);
  }
  static method memcpy_short : void ($dest : short[], $dest_offset : int, $source : short[], $source_offset : int, $length : int) {
    warn "Fn->memcpy_short is deprecated. Use Array->memcpy_short instead";
    Array->memcpy_short($dest, $dest_offset, $source, $source_offset, $length);
  }
  precompile static method memcpy_object : void ($dest : object[], $dest_offset : int, $source : object[], $source_offset : int, $length : int) {
    for (my $i = 0; $i < $length; $i++) {
      my $dist_index = $dest_offset + $i;
      my $source_index = $source_offset + $i;
      $dest->[$dist_index] = $source->[$source_index];
    }
  }

  native static method memmove : void ($dest : object, $dest_byte_offset : int, $source : object, $source_byte_offset : int, $byte_length : int);

  static method memmove_byte : void ($dest : byte[], $dest_offset : int, $source : byte[], $source_offset : int, $length : int) {
    warn "Fn->memmove_byte is deprecated. Use Array->memmove_byte instead";
    Array->memmove_byte($dest, $dest_offset, $source, $source_offset, $length);
  }
  static method memmove_double : void ($dest : double[], $dest_offset : int, $source : double[], $source_offset : int, $length : int) {
    warn "Fn->memmove_double is deprecated. Use Array->memmove_double instead";
    Array->memmove_double($dest, $dest_offset, $source, $source_offset, $length);
  }
  static method memmove_float : void ($dest : float[], $dest_offset : int, $source : float[], $source_offset : int, $length : int) {
    warn "Fn->memmove_float is deprecated. Use Array->memmove_float instead";
    Array->memmove_float($dest, $dest_offset, $source, $source_offset, $length);
  }
  static method memmove_int : void ($dest : int[], $dest_offset : int, $source : int[], $source_offset : int, $length : int) {
    warn "Fn->memmove_int is deprecated. Use Array->memmove_int instead";
    Array->memmove_int($dest, $dest_offset, $source, $source_offset, $length);
  }
  static method memmove_long : void ($dest : long[], $dest_offset : int, $source : long[], $source_offset : int, $length : int) {
    warn "Fn->memmove_long is deprecated. Use Array->memmove_long instead";
    Array->memmove_long($dest, $dest_offset, $source, $source_offset, $length);
  }
  static method memmove_short : void ($dest : short[], $dest_offset : int, $source : short[], $source_offset : int, $length : int) {
    warn "Fn->memmove_short is deprecated. Use Array->memmove_short instead";
    Array->memmove_short($dest, $dest_offset, $source, $source_offset, $length);
  }
  static method memmove_object : void ($dest : object[], $dest_offset : int, $source : object[], $source_offset : int, $length : int) {
    if ($dest == $source) {
      my $source_length = @$source;
      my $source_copy = new object[$source_length];
      my $source_offset_plus_length = $source_offset + $length;
      &memcpy_object($source_copy, $source_offset, $source, $source_offset, $length);
      $source = $source_copy;
    }
    &memcpy_object($dest, $dest_offset, $source, $source_offset, $length);
  }

  static method new_array_proto : object[] ($proto_array : object[], $length : int) {
    warn "Fn->new_array_proto is deprecated. Use Array->new_proto instead";
    return Array->new_proto($proto_array, $length);
  }
  
  static method ord : int ($utf8_character : string) {
    unless ($utf8_character) {
      return -1;
    }

    if (length $utf8_character == 0) {
      return -1;
    }
    
    my $offset = 0;
    my $unicode_code_point = &get_next_code_point($utf8_character, \$offset);
    
    return $unicode_code_point;
  }

  precompile static method powi : int ($x : int, $y : int) {
    my $p = 1;
    
    for (my $i = 0; $i < $y; $i++) {
      $p = $p * $x;
    }
    
    return $p;
  }

  precompile static method powl : long ($x : long, $y : long) {
    my $p = 1L;
    
    for (my $i = 0; $i < $y; $i++) {
      $p = $p * $x;
    }
    
    return $p;
  }

  static method rand : double ($seed : int*) {
    
    # 0 <= random_number < 1
    my $random_number = (double)&crand($seed) / ((double)&RAND_MAX() + 1);
    
    return $random_number;
  }

  precompile static method repeat : string ($string : string, $count : int) {
    
    unless ($string) {
      die "The string must be defined";
    }
    
    unless ($count > 0) {
      die "The repeat count must be more than 0";
    }
    
    my $buffer = StringBuffer->new;
    for (my $i = 0; $i < $count; $i++) {
      $buffer->push($string);
    }
    my $repeat_string = $buffer->to_string;
    
    return $repeat_string;
  }

  static method rindex : int ($string : string, $sub_string : string, $start_pos : int) {
    return &rindex_len($string, $sub_string, $start_pos, length $string);
  }

  precompile static method rindex_len : int ($string : string, $sub_string : string, $start_pos : int, $max_string_length : int) {
    my $sub_string_length = length $sub_string;

    if ($max_string_length > length $string) {
      $max_string_length = length $string;
    }

    my $sub_string_len = length $sub_string;
    if ($start_pos > $max_string_length - $sub_string_length) {
      $start_pos = $max_string_length - $sub_string_len;
    }
    for (my $i = $start_pos; $i >= 0; --$i) {
      my $match = 1;
      for (my $j = 0; $j < $sub_string_len; ++$j) {
        if ($string->[$i + $j] != $sub_string->[$j]) {
          $match = 0;
          last;
        }
      }
      if ($match) {
        return $i;
      }
    }
    return -1;
  }

  native static method shorten : void ($string : mutable string, $length : int);

  precompile static method split : string[] ($sep : string, $string : string) {
    my $string_length = length $string;
    my $sep_length = length $sep;


    if ($sep_length == 0) {
      die "Separator must not be empty string";
    }

    my $separated_strings_list = StringList->new_len(0);

    my $match_start = 0;
    my $string_base = 0;
    for (my $string_index = 0; $string_index < $string_length; $string_index++) {
      if ($string->[$string_index] == $sep->[0]) {
        $match_start = 1;
      }

      if ($match_start) {
        my $match = 1;
        for (my $sep_index = 0; $sep_index < $sep_length; $sep_index++) {
          if ($string_index + $sep_index > $string_length - 1) {
            $match = 0;
            last;
          }
          else {
            unless ($string->[$string_index + $sep_index] == $sep->[$sep_index]) {
              $match = 0;
              last;
            }
          }
        }
        if ($match) {
          my $separated_string = &substr($string, $string_base, $string_index - $string_base);
          $separated_strings_list->push($separated_string);
          $string_base = $string_index + $sep_length;
          $string_index += $sep_length - 1;
        }
      }
    }
    if ($string_base == $string_length) {
      $separated_strings_list->push("");
    }
    else {
      my $separated_string = &substr($string, $string_base, $string_length - $string_base);
      $separated_strings_list->push($separated_string);
    }

    my $separated_strings = $separated_strings_list->to_array;

    return $separated_strings;
  }

  static method sprintf : string ($format : string, $args : object[]...) {
    warn "Fn->sprintf is deprecated. Use Format->sprintf instead";
    return Format->sprintf($format, $args);
  }
  
  native static method _native_snprintf_d : string ($value : int);
  native static method _native_snprintf_ld : string ($value : long);
  native static method _native_snprintf_lu : string ($value : long);
  native static method _native_snprintf_u : string ($value : int);
  native static method _native_snprintf_x : string ($value : int);
  native static method _native_snprintf_lx : string ($value : long);
  native static method _native_snprintf_f : string ($value : double, $precision : int);
  native static method _native_snprintf_g : string ($value : double, $precision : int);
  
  static method _push_formatted_string_unsigned : void($buffer : StringBuffer, $formatted_value : string, $width : int, $pad_char : byte, $left_justified : int) {
    
    # "+" sign is always ignored.
    my $plus_sign = 0;
    
    &_push_formatted_string_signed($buffer, $formatted_value, $width, $pad_char, $left_justified, $plus_sign);
  }

  precompile static method _push_formatted_string_signed : void($buffer : StringBuffer, $formatted_value : string, $width : int, $pad_char : byte, $left_justified : int, $plus_sign : int) {
    my $is_minus = 0;
    if ($formatted_value->[0] == '-') {
       $is_minus = 1;
    }
    
    my $space_count = $width - length $formatted_value;
    if (!$is_minus && $plus_sign) {
      --$space_count;
    }

    if ($left_justified) {
      if (!$is_minus && $plus_sign) {
        $buffer->push_char('+');
      }

      $buffer->push($formatted_value);

      if ($space_count > 0) {
        for (; $space_count > 0; --$space_count) {
          $buffer->push_char($pad_char);
        }
      }
    }
    else {
      if ($space_count > 0) {
        for (; $space_count > 0; --$space_count) {
          $buffer->push_char($pad_char);
        }
      }

      if (!$is_minus && $plus_sign) {
        $buffer->push_char('+');
      }

      $buffer->push($formatted_value);
    }
  }
  
  precompile static method substr : string ($string : string, $offset : int, $length : int) {

    if ($string == undef) {
      die "String must be defined";
    }

    my $string_length = length $string;

    if ($offset < 0 || $offset > $string_length - 1) {
      die "Invalid offset $offset";
    }

    if ($length < 0) {
      die "Length must be non-zero value";
    }

    if ($offset + $length > $string_length) {
      die "Offset + length must not be over array length";
    }

    my $slice = (mutable string)new_string_len($length);

    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $slice->[$pos] = $string->[$i];
      $pos++;
    }

    return $slice;
  }

  native static method to_double : double ($string : string);

  native static method to_float : float ($string : string);

  static method to_int : int ($string : string) {
    return &to_int_with_base($string, 10);
  }
  
  native static method to_int_with_base : int ($string : string, $digit : int);
  
  static method to_long : long ($string : string) {
    return &to_long_with_base($string, 10);
  }
  native static method to_long_with_base : long ($string : string, $digit : int);

  static method to_lower : int ($code_point : int) {

    if ($code_point >= 'A' && $code_point <= 'Z') {
      $code_point = $code_point + 0x20;
    }
    return $code_point;
  }

  static method to_upper : int ($code_point : int) {

    if ($code_point >= 'a' && $code_point <= 'z') {
      $code_point = $code_point - 0x20;
    }
    return $code_point;
  }

  precompile static method trim_ascii_space : string ($string : string) {
    
    unless ($string) {
      return undef;
    }
    
    my $length = length $string;
    my $start_string_index = -1;
    my $end_string_index = -1;
    
    for (my $i = 0; $i < $length; $i++) {
      if ($start_string_index == -1) {
        if (&is_space($string->[$i])) {
          # Skip
        }
        else {
          $start_string_index = $i;
          last;
        }
      }
    }

    for (my $i = $length - 1; $i >= 0; $i--) {
      if ($end_string_index == -1) {
        if (&is_space($string->[$i])) {
          # Skip
        }
        else {
          $end_string_index = $i;
          last;
        }
      }
    }
    
    my $trimed_string : string;
    if ($start_string_index == -1 && $end_string_index == -1) {
      return "";
    }
    elsif ($end_string_index == -1) {
      $trimed_string = &substr($string, $start_string_index, $length - $start_string_index);
    }
    elsif ($end_string_index == -1) {
      $trimed_string = &substr($string, 0, $end_string_index + 1);
    }
    else {
      $trimed_string = &substr($string, $start_string_index, $end_string_index - $start_string_index + 1);
    }
    
    return $trimed_string;
  }


  precompile static method uc : string ($string : string) {

    unless ($string) { die "String must be defined"; }

    my $length = length $string;
    my $new_string = (mutable string)new_string_len($length);
    for (my $i = 0; $i < $length; $i++) {
      my $char = $string->[$i];
      if ($char >= 'a' && $char <= 'z') {
        $new_string->[$i] = (byte)($string->[$i] - 32);
      }
      else {
        $new_string->[$i] = $string->[$i];
      }
    }
    return $new_string;
  }

  precompile static method ucfirst : string ($string : string) {

    unless ($string) { die "String must be defined"; }

    my $length = length $string;
    my $new_string = (mutable string)new_string_len($length);
    if ($length > 0) {
      my $char = $string->[0];
      if ($char >= 'a' && $char <= 'z') {
        $new_string->[0] = (byte)($char - 32);
      }
      else {
        $new_string->[0] = $char;
      }
    }
    for (my $i = 1; $i < $length; ++$i) {
      $new_string->[$i] = $string->[$i];
    }
    return $new_string;
  }


  native static method _snsprintf_double : string ($format : string, $value : double);
}

