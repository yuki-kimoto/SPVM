package SPVM::StringUtil : precompile {
  use SPVM::Stringer;
  use SPVM::Cloner;
  use SPVM::EqualityChecker;
  use SPVM::StringBuffer;
  use SPVM::StringList;
  use SPVM::Unicode (uchar_to_utf8);
  use SPVM::ArrayUtil;
  
  sub split : string[] ($sep : string, $string : string) {
    my $string_length = length $string;
    my $sep_length = length $sep;


    if ($sep_length == 0) {
      die "Separator must not be empty string";
    }

    my $separated_strings_list = SPVM::StringList->new_len(0);

    my $match_start = 0;
    my $string_base = 0;
    for (my $string_index = 0; $string_index < $string_length; $string_index++) {
      if ($string->[$string_index] == $sep->[0]) {
        $match_start = 1;
      }

      if ($match_start) {
        my $match = 1;
        for (my $sep_index = 0; $sep_index < $sep_length; $sep_index++) {
          if ($string_index + $sep_index > $string_length - 1) {
            $match = 0;
            last;
          }
          else {
            unless ($string->[$string_index + $sep_index] == $sep->[$sep_index]) {
              $match = 0;
              last;
            }
          }
        }
        if ($match) {
          my $separated_string = substr($string, $string_base, $string_index - $string_base);
          $separated_strings_list->push($separated_string);
          $string_base = $string_index + $sep_length;
          $string_index += $sep_length - 1;
        }
      }
    }
    if ($string_base == $string_length) {
      $separated_strings_list->push("");
    }
    else {
      my $separated_string = substr($string, $string_base, $string_length - $string_base);
      $separated_strings_list->push($separated_string);
    }

    my $separated_strings = $separated_strings_list->to_array;

    return $separated_strings;
  }

  native sub _snsprintf_double : string ($format : string, $value : double);
  native sub _long_to_unsigned_digits : void ($value : long, $out_digits : byte[], $out_digit_count : int&);

  sub sprintf : string ($format : string, $args : object[]...) {
    my $format_length = length $format;
    my $index = 0;

    my $buffer = SPVM::StringBuffer->new;
    my $arg_count = 0;
    my $constant_string_length = 0;

    while ($index + $constant_string_length < $format_length) {

      if ($format->[$index + $constant_string_length] != '%') {
        # Read constant string
        ++$constant_string_length;
      }
      elsif ($index + $constant_string_length + 1 < $format_length &&
          $format->[$index + $constant_string_length + 1] == '%') {
        # Read %%
        ++$constant_string_length;

        # Add constant string
        if ($constant_string_length > 0) {
          $buffer->push_range($format, $index, $constant_string_length);
          $index += $constant_string_length;
          $constant_string_length = 0;
        }

        # Skip second %
        ++$index;
      }
      elsif ($index + $constant_string_length + 1 >= $format_length) {
        die "Invalid conversion in sprintf: end of string";
      }
      else {
        # Add constant string
        if ($constant_string_length > 0) {
          $buffer->push_range($format, $index, $constant_string_length);
          $index += $constant_string_length;
          $constant_string_length = 0;
        }

        # Read format string

        # Check the next element of @$args corresponding to the specifier
        unless ($arg_count < @$args) {
          die "Missing argument in sprintf";
        }

        # Read specifier %[flags][width][.precision][length]type

        my $specifier_base_index = $index;
        ++$index; # '%'

        # Read `flags`
        my $pad_char = ' ';
        my $plus_sign = 0;
        my $left_justified = 0;

        while ($index < $format_length) {
          my $flag = (int)($format->[$index]);
          switch($flag) {
            case '0': {
              ++$index;
              $pad_char = '0';
              break;
            }
            case '+': {
              ++$index;
              $plus_sign = 1;
              break;
            }
            case '-': {
              ++$index;
              $left_justified = 1;
              break;
            }
            default: {
              last;
              break;
            }
          }
        }

        # Read `width`
        my $width = 0;
        while ($index < $format_length) {
          my $c = $format->[$index];
          if ($c < '0' || '9' < $c) {
            last;
          }
          $width = $width * 10 + $c - '0';
          ++$index;
        }

        # Skip `precision` because of using native sprintf.
        if ($index < $format_length && $format->[$index] == '.') {
          ++$index;
          while ($index < $format_length) {
            my $c = $format->[$index];
            if ($c < '0' || '9' < $c) {
              last;
            }
            ++$index;
          }
        }

        unless ($index < $format_length) {
          die "Invalid conversion in sprintf: \""
              . substr($format, $specifier_base_index, $index - $specifier_base_index) . "\"";
        }

        my $specifier_char = $format->[$index];
        if ($specifier_char == 'c') {
          ++$index;
          my $arg = ((SPVM::Byte)$args->[$arg_count])->value;

          if ($left_justified) {
            $buffer->push_char($arg);
            my $space_count = $width - 1;
            if ($space_count > 0) {
              for (; $space_count > 0; --$space_count) {
                $buffer->push_char($pad_char);
              }
            }
          }
          else {
            my $space_count = $width - 1;
            if ($space_count > 0) {
              for (; $space_count > 0; --$space_count) {
                $buffer->push_char($pad_char);
              }
            }
            $buffer->push_char($arg);
          }
        }
        elsif ($specifier_char == 's') {
          ++$index;
          my $arg = (string)$args->[$arg_count];

          my $space_count = $width - length $arg;;
          if ($left_justified) {
            $buffer->push($arg);
            for (my $i = 0; $i < $space_count; ++$i) {
              $buffer->push_char($pad_char);
            }
          }
          else {
            for (my $i = 0; $i < $space_count; ++$i) {
              $buffer->push_char($pad_char);
            }
            $buffer->push($arg);
          }
        }
        elsif ($specifier_char == 'd') {
          ++$index;
          my $arg = ((SPVM::Int)$args->[$arg_count])->value;
          my $digits = new byte[11]; # -2147483648 has 11 digits
          my $digit_count = 0;
          while ($arg > 0) {
            $digits->[$digit_count++] = (byte)('0' + $arg % 10);
            $arg /= 10;
          }

          if ($left_justified) {
            my $space_count = $width - $digit_count;

            if ($arg < 0) {
              $buffer->push_char('-');
              --$space_count;
            }
            elsif ($plus_sign && $arg >= 0) {
              $buffer->push_char('+');
              --$space_count;
            }

            for (my $i = 0; $i < $digit_count; ++$i) {
              $buffer->push_char($digits->[$digit_count - $i - 1]);
            }

            if ($space_count > 0) {
              for (; $space_count > 0; --$space_count) {
                $buffer->push_char($pad_char);
              }
            }
          }
          else {
            my $space_count = $width - $digit_count;

            if ($arg < 0) {
              --$space_count;
            }
            elsif ($plus_sign && $arg >= 0) {
              --$space_count;
            }

            if ($space_count > 0) {
              for (; $space_count > 0; --$space_count) {
                $buffer->push_char($pad_char);
              }
            }

            if ($arg < 0) {
              $buffer->push_char('-');
            }
            elsif ($plus_sign && $arg >= 0) {
              $buffer->push_char('+');
            }

            for (my $i = 0; $i < $digit_count; ++$i) {
              $buffer->push_char($digits->[$digit_count - $i - 1]);
            }
          }
        }
        elsif ($specifier_char == 'u') {
          ++$index;
          my $arg = ((SPVM::Int)$args->[$arg_count])->value & 0xFFFFFFFFL;
          my $digits = new byte[10]; # 4294967295 has 10 digits
          my $digit_count = 0;
          while ($arg > 0) {
            $digits->[$digit_count++] = (byte)('0' + $arg % 10);
            $arg /= 10;
          }

          if ($left_justified) {
            my $space_count = $width - $digit_count;

            if ($arg < 0) {
              $buffer->push_char('-');
              --$space_count;
            }
            elsif ($plus_sign && $arg >= 0) {
              $buffer->push_char('+');
              --$space_count;
            }

            for (my $i = 0; $i < $digit_count; ++$i) {
              $buffer->push_char($digits->[$digit_count - $i - 1]);
            }

            if ($space_count > 0) {
              for (; $space_count > 0; --$space_count) {
                $buffer->push_char($pad_char);
              }
            }
          }
          else {
            my $space_count = $width - $digit_count;

            if ($arg < 0) {
              --$space_count;
            }
            elsif ($plus_sign && $arg >= 0) {
              --$space_count;
            }

            if ($space_count > 0) {
              for (; $space_count > 0; --$space_count) {
                $buffer->push_char($pad_char);
              }
            }

            if ($arg < 0) {
              $buffer->push_char('-');
            }
            elsif ($plus_sign && $arg >= 0) {
              $buffer->push_char('+');
            }

            for (my $i = 0; $i < $digit_count; ++$i) {
              $buffer->push_char($digits->[$digit_count - $i - 1]);
            }
          }
        }
        elsif ($specifier_char == 'l') {
          unless ($index + 1 < $format_length && ($format->[$index + 1] == 'd' || $format->[$index + 1] == 'u')) {
            die "Invalid conversion in sprintf: \""
                . substr($format, $specifier_base_index, $index - $specifier_base_index + 1) . "\"";
          }

          my $is_signed_format = $format->[$index + 1] == 'd';
          $index += 2;

          my $arg = ((SPVM::Long)$args->[$arg_count])->value;
          my $digits = new byte[20]; # -9223372036854775808[18446744073709551615] has 20 digits
          my $digit_count = 0;

          if ($is_signed_format) {
            while ($arg > 0) {
              $digits->[$digit_count++] = (byte)('0' + $arg % 10);
              $arg /= 10;
            }
          }
          else {
            _long_to_unsigned_digits($arg, $digits, \$digit_count);
          }

          if ($left_justified) {
            my $space_count = $width - $digit_count;

            if ($is_signed_format && $arg < 0) {
              $buffer->push_char('-');
              --$space_count;
            }
            elsif ($plus_sign && $arg >= 0) {
              $buffer->push_char('+');
              --$space_count;
            }

            for (my $i = 0; $i < $digit_count; ++$i) {
              $buffer->push_char($digits->[$digit_count - $i - 1]);
            }

            if ($space_count > 0) {
              for (; $space_count > 0; --$space_count) {
                $buffer->push_char($pad_char);
              }
            }
          }
          else {
            my $space_count = $width - $digit_count;

            if ($is_signed_format && $arg < 0) {
              --$space_count;
            }
            elsif ($plus_sign && $arg >= 0) {
              --$space_count;
            }

            if ($space_count > 0) {
              for (; $space_count > 0; --$space_count) {
                $buffer->push_char($pad_char);
              }
            }

            if ($is_signed_format && $arg < 0) {
              $buffer->push_char('-');
            }
            elsif ($plus_sign && $arg >= 0) {
              $buffer->push_char('+');
            }

            for (my $i = 0; $i < $digit_count; ++$i) {
              $buffer->push_char($digits->[$digit_count - $i - 1]);
            }
          }
        }
        elsif ($specifier_char == 'f' || $specifier_char == 'g') {
          ++$index;
          my $arg = (SPVM::Double)$args->[$arg_count];
          my $specifier_str = substr($format, $specifier_base_index, $index - $specifier_base_index);
          my $str = _snsprintf_double($specifier_str, $arg->value);
          $buffer->push($str);
        }
        elsif ($specifier_char == 'U') {
          ++$index;
          my $arg = (SPVM::Int)$args->[$arg_count];
          my $utf8 = uchar_to_utf8($arg->value);
          $buffer->push($utf8);
        }
        else {
          die "Invalid conversion in sprintf: \""
              . substr($format, $specifier_base_index, $index - $specifier_base_index + 1) . "\"";
        }

        ++$arg_count;
      }
    }

    # Add constant string
    if ($constant_string_length > 0) {
      $buffer->push_range($format, $index, $constant_string_length);
      $index += $constant_string_length;
      $constant_string_length = 0;
    }

    my $result = $buffer->to_string;
    return $result;
  }

  sub chomp_lf : string ($string : string) {
    unless ($string) {
      return undef;
    }

    my $new_string : string;
    my $length = length $string;
    if ($length == 0) {
      $new_string = copy_str($string);
    }
    else {
      if ($string->[$length - 1] == '\n') {
        $new_string = (string)SPVM::ArrayUtil->slice_byte((byte[])$string, 0, $length - 1);
      }
      else {
        $new_string = copy_str($string);
      }
    }

    return $new_string;
  }

  sub chomp_crlf : string ($string : string) {
    unless ($string) {
      return undef;
    }

    my $new_string : string;
    my $length = length $string;
    if ($length == 0 || $length == 1) {
      $new_string = copy_str($string);
    }
    else {
      if ($string->[$length - 2] == '\r' && $string->[$length - 1] == '\n') {
        $new_string = (string)SPVM::ArrayUtil->slice_byte((byte[])$string, 0, $length - 2);
      }
      else {
        $new_string = copy_str($string);
      }
    }

    return $new_string;
  }

  sub index : int ($str : string, $substr : string, $posision : int) {
    my $strCount = length $str;
    my $substrCount = length $substr;

    if ($posision >= $strCount) {
      my $ret : int;
      if ($substrCount == 0) {
        $ret = $strCount;
      }
      else {
        $ret = -1;
      }
      return $ret;
    }
    if ($posision < 0) {
      $posision = 0;
    }
    if ($substrCount == 0) {
      return $posision;
    }

    my $first : byte  = $substr->[0];
    my $max : int = ($strCount - $substrCount);

    for (my $i = $posision; $i <= $max; $i++) {
      if ($str->[$i] != $first) {
        while (++$i <= $max && $str->[$i] != $first) {}
      }

      if ($i <= $max) {
        my $j = $i + 1;
        my $end = $j + $substrCount - 1;
        for (my $k = 01; $j < $end && $str->[$j] == $substr->[$k]; ($j++, $k++)) {}

        if ($j == $end) {
          return $i;
        }
      }
    }
    return -1;
  }

  # The argument type of following charcter checking functions are int, not byte. This is intentinal.
  # ASCII code is represented by byte type.
  # On the other hand, Unicode Code Point can be represented by int tyep.
  # Unicode Code Point is upper compatibility of ASCII code.
  # So the following character check functions receive int type argument.
  sub isalnum : int ($char : int) {

    if (($char >= 'A' && $char <= 'Z') || ($char >= 'a' && $char <= 'z') || ($char >= '0' && $char <= '9')) {
      return 1;
    }
    else {
      return 0;
    }
  }

  sub isalpha : int ($char : int) {

    if (($char >= 'A' && $char <= 'Z') || ($char >= 'a' && $char <= 'z')) {
      return 1;
    }
    else {
      return 0;
    }
  }

  sub isblank : int ($char : int) {

    if ($char >= ' ' ||  $char <= '\t') {
      return 1;
    }
    else {
      return 0;
    }
  }

  sub iscntrl : int ($char : int) {

    if (($char >= 0x00 && $char <= 0x1f) || $char == 0x7f) {
      return 1;
    }
    else {
      return 0;
    }
  }

  sub isdigit : int ($char : int) {

    if ($char >= '0' && $char <= '9') {
      return 1;
    }
    else {
      return 0;
    }
  }

  sub isgraph : int ($char : int) {

    if ($char >= 0x21 && $char <= 0x7e) {
      return 1;
    }
    else {
      return 0;
    }
  }

  sub islower : int ($char : int) {

    if ($char >= 'a' && $char <= 'z') {
      return 1;
    }
    else {
      return 0;
    }
  }

  sub isprint : int ($char : int) {

    if ($char >= 0x20 && $char <= 0x7e) {
      return 1;
    }
    else {
      return 0;
    }
  }

  sub ispunct : int ($char : int) {

    if (($char >= 0x21 && $char <= 0x2f) || ($char >= 0x3a && $char <= 0x40) || ($char >= 0x5b && $char <= 0x60) || ($char >= 0x7b && $char <= 0x7e)) {
      return 1;
    }
    else {
      return 0;
    }
  }

  sub isspace : int ($char : int) {

    if (($char >= 0x09 && $char <= 0x0d) || $char == 0x20) {
      return 1;
    }
    else {
      return 0;
    }
  }

  sub isupper : int ($char : int) {

    if ($char >= 'A' && $char <= 'Z') {
      return 1;
    }
    else {
      return 0;
    }
  }

  sub isxdigit : int ($char : int) {

    if (($char >= 'A' && $char <= 'F') || ($char >= 'a' && $char <= 'f') || ($char >= '0' && $char <= '9')) {
      return 1;
    }
    else {
      return 0;
    }
  }

  sub tolower : int ($char : int) {

    if ($char >= 'A' && $char <= 'Z') {
      $char = $char + 0x20;
    }
    return $char;
  }

  sub toupper : int ($char : int) {

    if ($char >= 'a' && $char <= 'z') {
      $char = $char - 0x20;
    }
    return $char;
  }

  # This is same as Perl \s
  sub is_perl_space : int ($char : int) {
    my $ispspace = 0;
    switch ($char) {
      case ' ':
      case '\r':
      case '\n':
      case '\t':
      case '\f':
      {
        $ispspace = 1;
        break;
      }
    }
    return $ispspace;
  }

  sub is_perl_word : int ($char : int) {
    my $ispword = 0;

    if ($char >= 'a' && $char <= 'z') {
      $ispword = 1;
    }
    elsif ($char >= 'A' && $char <= 'Z') {
      $ispword = 1;
    }
    elsif ($char == '_') {
      $ispword = 1;
    }
    elsif ($char >= '0' && $char <= '9') {
      $ispword = 1;
    }
    return $ispword;
  }

  sub join : string ($sep : string, $strings : string[]) {
    my $join = "";

    for (my $i = 0; $i < @$strings; $i++) {
      my $string = $strings->[$i];
      $join .= $string;
      if ($i != @$strings - 1) {
        $join .= $sep;
      }
    }

    return $join;
  }

  sub lc : string($str : string) {

    unless ($str) { die "String must be defined"; }

    my $length = length $str;
    my $new_string = new byte [$length];
    for (my $i = 0; $i < $length; $i++) {
      my $char = $str->[$i];
      if ($char >= 'A' && $char <= 'Z') {
        $new_string->[$i] = (byte)($str->[$i] + 32);
      }
      else {
        $new_string->[$i] = $str->[$i];
      }
    }
    return (string)$new_string;
  }

  sub lcfirst : string($str : string) {

    unless ($str) { die "String must be defined"; }

    my $length = length $str;
    my $new_string = new byte [$length];
    if ($length > 0) {
      my $char = $str->[0];
      if ($char >= 'A' && $char <= 'Z') {
        $new_string->[0] = (byte)($char + 32);
      }
      else {
        $new_string->[0] = $char;
      }
    }
    for (my $i = 1; $i < $length; ++$i) {
      $new_string->[$i] = $str->[$i];
    }
    return (string)$new_string;
  }

  sub replace : string ($str : string, $substr : string, $replace : string, $start_offset : int, $found_offset_ref : int&) {
    unless ($substr && length $substr > 0) {
      die "Sub string must have length";
    }
    my $found_offset = index($str, $substr, $start_offset);
    $$found_offset_ref = $found_offset;
    if ($found_offset >= 0) {
      my $str_len = length $str;
      my $substr_len = length $substr;
      my $replace_len = length $replace;

      my $result_str_len = $str_len + $replace_len - $substr_len;
      my $result_str = new byte[$result_str_len];

      if ($found_offset > 0) {
        SPVM::ArrayUtil->memmove_byte((byte[])$result_str, 0, (byte[])$str, 0, $found_offset);
      }
      SPVM::ArrayUtil->memmove_byte((byte[])$result_str, $found_offset, (byte[])$replace, 0, $replace_len);

      my $str_rest_offset = $found_offset + $substr_len;
      my $str_rest_length = $str_len - $str_rest_offset;
      my $result_rest_offset = $found_offset + $replace_len;
      my $result_rest_length = $result_str_len - $result_rest_offset;
      SPVM::ArrayUtil->memmove_byte((byte[])$result_str, $result_rest_offset, (byte[])$str, $str_rest_offset, $str_rest_length);

      return (string)$result_str;
    }
    else {
      my $copy_str = copy_str($str);
      return $copy_str;
    }
  }

  sub replace_all : string ($str : string, $substr : string, $replace : string) {

    unless ($str) { die "String must be defined"; }

    my $offset = 0;
    my $found_offset : int;
    my $substr_len = length $substr;
    my $result_str = $str;
    while (1) {
      $result_str = replace($result_str, $substr, $replace, $offset, \$found_offset);
      if ($found_offset >= 0) {
        $offset = $found_offset + $substr_len;
      }
      else {
        return $result_str;
      }
    }
  }

  native sub strtoi : int ($string : string, $digit : int);
  native sub strtol : long ($string : string, $digit : int);
  native sub strtof : float ($string : string);
  native sub strtod : double ($string : string);

  sub uc : string($str : string) {

    unless ($str) { die "String must be defined"; }

    my $length = length $str;
    my $new_string = new byte [$length];
    for (my $i = 0; $i < $length; $i++) {
      my $char = $str->[$i];
      if ($char >= 'a' && $char <= 'z') {
        $new_string->[$i] = (byte)($str->[$i] - 32);
      }
      else {
        $new_string->[$i] = $str->[$i];
      }
    }
    return (string)$new_string;
  }

  sub ucfirst : string($str : string) {

    unless ($str) { die "String must be defined"; }

    my $length = length $str;
    my $new_string = new byte [$length];
    if ($length > 0) {
      my $char = $str->[0];
      if ($char >= 'a' && $char <= 'z') {
        $new_string->[0] = (byte)($char - 32);
      }
      else {
        $new_string->[0] = $char;
      }
    }
    for (my $i = 1; $i < $length; ++$i) {
      $new_string->[$i] = $str->[$i];
    }
    return (string)$new_string;
  }

  sub rindex : int ($str : string, $substr : string, $offset : int) {
    my $str_len = length $str;
    my $substr_len = length $substr;
    if ($offset > $str_len - $substr_len) {
      $offset = $str_len - $substr_len;
    }
    for (my $i = $offset; $i >= 0; --$i) {
      my $match = 1;
      for (my $j = 0; $j < $substr_len; ++$j) {
        if ($str->[$i + $j] != $substr->[$j]) {
          $match = 0;
          last;
        }
      }
      if ($match) {
        return $i;
      }
    }
    return -1;
  }

  sub contains : int ($str : string, $substr : string) {
    if (!$str) {
      die "Target string must be defined";
    }
    if (!$substr) {
      die "Search string must be defined";
    }

    my $pat_len = length $substr;
    my $str_len = length $str;
    my $i = 0;
    my $j = 0;

    while ($i < $str_len && $j < $pat_len) {
      if ($str->[$i] == $substr->[$j]) {
        $i++;
        $j++;
      } else {
        $i = $i - $j + 1;
        $j = 0;
      }
    }

    if ($j == $pat_len) {
      return 1;
    }
    else {
      return 0;
    }
  }

  sub substr : string ($string : string, $offset : int, $length : int) {

    if ($string == undef) {
      die "String must be defined";
    }

    my $string_length = length $string;

    if ($offset < 0 || $offset > $string_length - 1) {
      die "Invalid offset $offset";
    }

    if ($length < 0) {
      die "Length must be non-zero value";
    }

    if ($offset + $length > $string_length) {
      die "Offset + length must not be over array length";
    }

    my $slice = new byte[$length];

    my $pos = 0;
    for (my $i = $offset; $i < $offset + $length; $i++) {
      $slice->[$pos] = $string->[$i];
      $pos++;
    }

    return (string)$slice;
  }

  sub copy_str : string ($string : string) {
    my $bytes = (byte[])$string;

    return (string)$bytes;
  }
}
