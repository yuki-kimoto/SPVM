package SPVM::HTTP::Headers {
  use SPVM::Hash;
  use SPVM::Math::StringToNumber;
  use SPVM::StringBuffer;

  has referer           : ro string;
  has expires           : ro int;
  has last_modified     : ro int;
  has if_modified_since : ro int;
  has content_type      : ro string;
  has content_length    : ro int;
  has content_encoding  : ro string;
  has extra             : SPVM::Hash;

  our $HEADER_CASE : ro SPVM::Hash;

  BEGIN {
    $HEADER_CASE = SPVM::Hash->new;
    my $request_headers = REQUEST_HEADERS();
    my $entity_headers = ENTITY_HEADERS();
    for (my $i = 0; $i < @$request_headers; ++$i) {
      $HEADER_CASE->set(lc($request_headers->[$i]), $request_headers->[$i]);
    }
    for (my $i = 0; $i < @$entity_headers; ++$i) {
      $HEADER_CASE->set(lc($entity_headers->[$i]), $entity_headers->[$i]);
    }
  }

  private sub REQUEST_HEADERS : string[] () {
    return [
      "Accept", "Accept-Charset", "Accept-Encoding", "Accept-Language",
      "Authorization", "Expect", "From", "Host",
      "If-Match", "If-Modified-Since", "If-None-Match", "If-Range", "If-Unmodified-Since",
      "Max-Forwards", "Proxy-Authorization", "Range", "Referer", "TE", "User-Agent",
    ];
  }

  private sub ENTITY_HEADERS : string[] () {
    return [
      "Allow", "Content-Encoding", "Content-Language", "Content-Length", "Content-Location",
      "Content-MD5", "Content-Range", "Content-Type", "Expires", "Last-Modified",
    ];
  }

  private sub add_extra : void ($self : self, $k : string, $v : string) {
    unless ($self->{extra}) {
      $self->{extra} = SPVM::Hash->new;
    }
    if (my $c = $self->{extra}->get($k)) {
      if ($c isa SPVM::List) {
        ((SPVM::List)$c)->push($v);
      }
      elsif ($c isa string) {
        $self->{extra}->set($k, SPVM::List->new_with_array([(object)$c, $v]));
      }
      else {
        die "Unexpected type of extra value";
      }
    }
    else {
      $self->{extra}->set($k, $v);
    }
  }

  sub new : SPVM::HTTP::Headers () {
    my $self = new SPVM::HTTP::Headers;
    return $self;
  }

  sub new_with : SPVM::HTTP::Headers ($args : SPVM::Hash) {
    my $self = new SPVM::HTTP::Headers;
    my $keys = $args->keys;
    for (my $i = 0; $i < @$keys; ++$i) {
      $self->add($keys->[$i], $args->get($keys->[$i]));
    }
    return $self;
  }

  private sub to_s : string ($o : object) {
    return (string)$o;
  }

  private sub to_i : int ($o : object) {
    return ((SPVM::Int)$o)->val;
  }
 
  sub add : void ($self : self, $header : object[]...) {
    unless (@$header == 2) {
      die "Invalid size of args";
    }
    my $k = lc((string)($header->[0]));
    my $v = $header->[1];
    my $k0 = (int)($k->[0]);
    switch ($k0) {
      case 99: #'c':
        if ($k eq "content-type" || $k eq "content_type") {
          $self->{content_type} = to_s($v);
        } elsif ($k eq "content-length" || $k eq "content_length") {
          if ($v isa SPVM::Int) {
            $self->{content_length} = to_i($v);
          } else {
            $self->{content_length} =
              SPVM::Math::StringToNumber->from(to_s($v))->to_int;
          }
        } elsif ($k eq "content-encoding" || $k eq "content_encoding") {
          $self->{content_encoding} = to_s($v);
        } else {
          $self->add_extra($k, to_s($v));
        }
        last;
      case 105: #'i':
        if ($k eq "if-modified-since" || $k eq "if_modified_since") {
          if ($v isa SPVM::Int) {
            $self->{if_modified_since} = to_i($v);
          } else {
            $self->{if_modified_since} =
              SPVM::Math::StringToNumber->from(to_s($v))->to_int;
          }
        } else {
          $self->add_extra($k, to_s($v));
        }
        last;
      case 108: #'l':
        if ($k eq "last-modified" || $k eq "last_modified") {
          if ($v isa SPVM::Int) {
            $self->{last_modified} = to_i($v);
          } else {
            $self->{last_modified} =
              SPVM::Math::StringToNumber->from(to_s($v))->to_int;
          }
        } else {
          $self->add_extra($k, to_s($v));
        }
        last;
      case 114: #'r':
        if ($k eq "referer" || $k eq "referrer") {
          $self->{referer} = to_s($v);
        } else {
          $self->add_extra($k, to_s($v));
        }
        last;
      case 101: #'e':
        if ($k eq "expires") {
          if ($v isa SPVM::Int) {
            $self->{expires} = to_i($v);
          } else {
            $self->{expires} =
              SPVM::Math::StringToNumber->from(to_s($v))->to_int;
          }
        } else {
          $self->add_extra($k, to_s($v));
        }
        last;
      default:
        # XXX: 未登録のヘッダは入力のキーを $HEADER_CASE と見なして登録
        unless ($HEADER_CASE->exists($k)) {
          my $hk = (string)($header->[0]);
          # FIXME: $HEADER_CASE への set は Leak するので削除
          # $HEADER_CASE->set($k, $hk);
        }
        $self->add_extra($k, to_s($v));
        last;
    }
  }

  sub get : object ($self : self, $key : string) {
    my $lc_key = lc($key);
    my $ch = (int)($lc_key->[0]);
    switch ($ch) {
      case 99: #'c':
        if ($lc_key eq "content-type" || $lc_key eq "content_type") {
          return $self->{content_type};
        }
        elsif ($lc_key eq "content-length" || $lc_key eq "content_length") {
          return $self->{content_length};
        }
        elsif ($lc_key eq "content-encoding" || $lc_key eq "content_encoding") {
          return $self->{content_encoding};
        }
        last;
      case 105: #'i':
        if ($lc_key eq "if-modified-since" || $lc_key eq "if_modified_since") {
          return $self->{if_modified_since};
        }
        last;
      case 108: #'l':
        if ($lc_key eq "last-modified" || $lc_key eq "last_modified") {
          return $self->{last_modified};
        }
        last;
      case 114: #'r':
        if ($lc_key eq "referer" || $lc_key eq "referrer") {
          return $self->{referer};
        }
        last;
      case 101: #'e':
        if ($lc_key eq "expires") {
          return $self->{expires};
        }
        last;
      default:
        last;
    }
    unless ($self->{extra}) {
      return undef;
    }
    return $self->{extra}->get($lc_key);
  }

  sub append_to_buffer : void ($self : self, $buffer : SPVM::StringBuffer) {
    if ($self->{referer}) {
      $buffer->append_string("Referer: " . $self->{referer} . "\r\n");
    }
    if ($self->{expires}) {
      $buffer->append_string("Expires: " . $self->{expires} . "\r\n");
    }
    if ($self->{last_modified}) {
      $buffer->append_string("Last-Modified: " . $self->{last_modified} . "\r\n");
    }
    if ($self->{if_modified_since}) {
      $buffer->append_string("If-Modified-Since: " . $self->{if_modified_since} . "\r\n");
    }
    if ($self->{content_type}) {
      $buffer->append_string("Content-Type: " . $self->{content_type} . "\r\n");
    }
    if ($self->{content_length}) {
      $buffer->append_string("Content-Length: " . $self->{content_length} . "\r\n");
    }
    if ($self->{content_encoding}) {
      $buffer->append_string("Content-Encoding: " . $self->{content_encoding} . "\r\n");
    }
    if ($self->{extra}) {
      my $keys = $self->{extra}->keys();
      if (@$keys) {
        for (my $i = 0; $i < @$keys; ++$i) {
          my $hc = (string)$HEADER_CASE->get($keys->[$i]);
          unless ($hc) {
            die "Not found header case of '" . $keys->[$i] . "'";
          }
          my $v = (string)($self->{extra}->get($keys->[$i]));
          $buffer->append_string("$hc: $v\r\n");
        }
      }
    }
  }
}
