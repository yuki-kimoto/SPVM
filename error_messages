lib/SPVM/Global.pm:      $builder_compiler->compile_with_exit($native_compiler_module, __FILE__, __LINE__);
lib/SPVM/Global.pm:      my $builder_runtime = $builder_compiler->get_runtime;
lib/SPVM/Builder/Exe.pm:  $compiler->add_include_dir($_) for @{$builder->include_dirs};
lib/SPVM/Builder/Exe.pm:  $compiler->set_start_file(__FILE__);
lib/SPVM/Builder/Exe.pm:  $compiler->set_start_line(__LINE__ + 1);
lib/SPVM/Builder/Exe.pm:  my $success = $compiler->compile($basic_type_name);
lib/SPVM/Builder/Exe.pm:    my $error_messages = $compiler->get_error_messages;
lib/SPVM/Builder/Exe.pm:  my $runtime = $compiler->get_runtime;
lib/SPVM/Builder/Exe.pm:  void* compiler = env_api->api->compiler->new_instance();
lib/SPVM/Builder/Exe.pm:  env_api->api->compiler->free_instance(compiler);
lib/SPVM/Builder/Exe.pm:    my $module_file = $compiler->get_module_file($basic_type_name);
lib/SPVM/Builder/Exe.pm:    $source_module_file .= qq|    env->api->compiler->set_module_file(compiler, "$basic_type_name", module_file);\n\n|;
lib/SPVM/Builder/Exe.pm:  $source .= qq|  env->api->compiler->set_start_file(compiler, __FILE__);\n|;
lib/SPVM/Builder/Exe.pm:  $source .= qq|  env->api->compiler->set_start_line(compiler, __LINE__ + 1);\n|;
lib/SPVM/Builder/Exe.pm:  $source .= qq|  int32_t error_id = env->api->compiler->compile(compiler, \"$start_basic_type_name\");\n|;
lib/SPVM/Builder/Exe.pm:  $source .= qq|    fprintf(stderr, "[Unexpected Compile Error]%s.", env->api->compiler->get_error_message(compiler, 0));\n|;
lib/SPVM/Builder/Exe.pm:  $source .= qq|  void* runtime = env->api->compiler->get_runtime(compiler);\n|;
lib/SPVM/Builder/src/spvm_case_info.c:  SPVM_CASE_INFO* case_info = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, sizeof(SPVM_CASE_INFO));
lib/SPVM/Builder/src/spvm_opcode_builder.c:  for (int32_t basic_type_id = compiler->basic_types_base_id; basic_type_id < compiler->basic_types->length; basic_type_id++) {
lib/SPVM/Builder/src/spvm_opcode_builder.c:    SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_opcode_builder.c:      SPVM_LIST* block_stack_call_stack_index_top = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_opcode_builder.c:      SPVM_LIST* if_block_stack_goto_end_opcode_index = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_opcode_builder.c:      SPVM_LIST* loop_block_stack_goto_opcode_index = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_opcode_builder.c:      SPVM_LIST* loop_block_stack_next_base = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_opcode_builder.c:      SPVM_LIST* loop_block_stack_last_base = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_opcode_builder.c:      SPVM_LIST* switch_stack_switch_info = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_opcode_builder.c:      SPVM_LIST* switch_block_stack_break_base = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_opcode_builder.c:      SPVM_LIST* eval_block_stack_goto_opcode_index = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_opcode_builder.c:      SPVM_LIST* unresolved_if_eq_or_if_ne_opcode_index_stack = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_opcode_builder.c:      SPVM_LIST* unresolved_last_opcode_index_stack = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_opcode_builder.c:      SPVM_LIST* unresolved_break_opcode_index_stack = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_opcode_builder.c:      SPVM_LIST* unresolved_next_opcode_index_stack = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_opcode_builder.c:      SPVM_LIST* unresolved_return_opcode_index_stack = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_opcode_builder.c:      SPVM_LIST* unresolved_goto_end_of_eval_on_exception_opcode_index_stack = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_opcode_builder.c:      SPVM_LIST* unresolved_goto_end_of_method_on_exception_opcode_index_stack = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_opcode_builder.c:      SPVM_LIST* call_stack_indexs_stack = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_opcode_builder.c:                        SPVM_STRING* global_constant_string = SPVM_HASH_get(compiler->constant_string_symtable, constant_string_value, constant_string_length);
lib/SPVM/Builder/src/spvm_opcode_builder.c:  SPVM_DUMPER_dump_basic_types_opcode_list(compiler, compiler->basic_types);
lib/SPVM/Builder/src/spvm_constant.c:  SPVM_CONSTANT* constant = SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, sizeof(SPVM_CONSTANT));
lib/SPVM/Builder/src/spvm_class_var_access.c:  return SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, sizeof(SPVM_CLASS_VAR_ACCESS));
lib/SPVM/Builder/src/spvm_basic_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, sizeof(SPVM_BASIC_TYPE));
lib/SPVM/Builder/src/spvm_basic_type.c:  basic_type->constant_strings = SPVM_LIST_new_list_permanent(compiler->global_allocator, 128);
lib/SPVM/Builder/src/spvm_basic_type.c:  basic_type->constant_string_symtable = SPVM_HASH_new_hash_permanent(compiler->global_allocator, 128);
lib/SPVM/Builder/src/spvm_basic_type.c:  basic_type->string_pool = SPVM_STRING_BUFFER_new(compiler->global_allocator, 8192, SPVM_ALLOCATOR_C_ALLOC_TYPE_PERMANENT);
lib/SPVM/Builder/src/spvm_basic_type.c:  basic_type->unmerged_fields = SPVM_LIST_new_list_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_basic_type.c:  basic_type->unmerged_field_symtable = SPVM_HASH_new_hash_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_basic_type.c:  basic_type->field_symtable = SPVM_HASH_new_hash_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_basic_type.c:  basic_type->class_vars = SPVM_LIST_new_list_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_basic_type.c:  basic_type->class_var_symtable = SPVM_HASH_new_hash_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_basic_type.c:  basic_type->methods = SPVM_LIST_new_list_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_basic_type.c:  basic_type->method_symtable = SPVM_HASH_new_hash_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_basic_type.c:  basic_type->interfaces = SPVM_LIST_new_list_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_basic_type.c:  basic_type->interface_symtable = SPVM_HASH_new_hash_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_basic_type.c:  basic_type->allows = SPVM_LIST_new_list_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_basic_type.c:  basic_type->interface_decls = SPVM_LIST_new_list_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_basic_type.c:  basic_type->anon_unresolved_basic_type_names = SPVM_LIST_new_list_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_basic_type.c:  basic_type->anon_basic_types = SPVM_LIST_new_list_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_basic_type.c:  basic_type->alias_symtable = SPVM_HASH_new_hash_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_basic_type.c:  basic_type->use_basic_type_names = SPVM_LIST_new_list_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_basic_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_basic_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_basic_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_basic_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_basic_type.c:  SPVM_BASIC_TYPE* interface_basic_type = SPVM_LIST_get(compiler->basic_types, interface_basic_type_id);
lib/SPVM/Builder/src/spvm_basic_type.c:      parent_basic_type = SPVM_HASH_get(compiler->basic_type_symtable, parent_basic_type_name, strlen(parent_basic_type_name));
lib/SPVM/Builder/src/spvm_basic_type.c:  SPVM_BASIC_TYPE* super_basic_type = SPVM_LIST_get(compiler->basic_types, super_basic_type_id);
lib/SPVM/Builder/src/spvm_basic_type.c:  SPVM_BASIC_TYPE* child_basic_type = SPVM_LIST_get(compiler->basic_types, child_basic_type_id);
lib/SPVM/Builder/src/spvm_basic_type.c:        SPVM_BASIC_TYPE* current_parent_basic_type = SPVM_HASH_get(compiler->basic_type_symtable, current_parent_basic_type_name, strlen(current_parent_basic_type_name));
lib/SPVM/Builder/src/spvm_basic_type.c:    SPVM_STRING* string = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, sizeof(SPVM_STRING));
lib/SPVM/Builder/src/spvm_method.c:  SPVM_METHOD* method = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, sizeof(SPVM_METHOD));
lib/SPVM/Builder/src/spvm_method.c:  method->var_decls = SPVM_LIST_new_list_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_method.c:  method->anon_method_fields = SPVM_LIST_new_list_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_array_field_access.c:  return SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, sizeof(SPVM_ARRAY_FIELD_ACCESS));
lib/SPVM/Builder/src/spvm_field.c:  return SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, sizeof(SPVM_FIELD));
lib/SPVM/Builder/src/spvm_var_decl.c:  SPVM_VAR_DECL* var_decl = SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, sizeof(SPVM_VAR_DECL));
lib/SPVM/Builder/src/spvm_var_decl.c:  SPVM_VAR_DECL* var_decl = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, sizeof(SPVM_VAR_DECL));
Binary file lib/SPVM/Builder/src/spvm_compiler.o matches
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->global_allocator = allocator;
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->ch_ptr = "";
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->constant_string_symtable = SPVM_HASH_new_hash_permanent(compiler->global_allocator, 128);
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->include_dirs = SPVM_LIST_new_list_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->basic_types = SPVM_LIST_new_list_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->basic_type_symtable = SPVM_HASH_new_hash_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->module_file_symtable = SPVM_HASH_new_hash_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->if_require_not_found_basic_type_name_symtable = SPVM_HASH_new_hash_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->each_compile_allocators = SPVM_LIST_new_list_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->runtime = SPVM_RUNTIME_new();
lib/SPVM/Builder/src/spvm_compiler.c:  SPVM_MODULE_FILE* module_file = SPVM_HASH_get(compiler->module_file_symtable, module_name, strlen(module_name));
lib/SPVM/Builder/src/spvm_compiler.c:    SPVM_HASH_set(compiler->module_file_symtable, module_name, strlen(module_name), (void*)module_file);
lib/SPVM/Builder/src/spvm_compiler.c:   SPVM_BASIC_TYPE* basic_type = SPVM_HASH_get(compiler->basic_type_symtable, basic_type_name, strlen(basic_type_name));
lib/SPVM/Builder/src/spvm_compiler.c:     basic_type->id = compiler->basic_types->length;
lib/SPVM/Builder/src/spvm_compiler.c:     SPVM_LIST_push(compiler->basic_types, basic_type);
lib/SPVM/Builder/src/spvm_compiler.c:     SPVM_HASH_set(compiler->basic_type_symtable, basic_type->name, strlen(basic_type->name), basic_type);
lib/SPVM/Builder/src/spvm_compiler.c:  return compiler->error_messages->length;
lib/SPVM/Builder/src/spvm_compiler.c:  const char* error_message = (const char*)SPVM_LIST_get(compiler->error_messages, index);
lib/SPVM/Builder/src/spvm_compiler.c:  for (int32_t i = 0; i < compiler->error_messages->length; i++) {
lib/SPVM/Builder/src/spvm_compiler.c:    const char* error_message = (const char*)SPVM_LIST_get(compiler->error_messages, i);
lib/SPVM/Builder/src/spvm_compiler.c:  SPVM_LIST_push(compiler->op_use_stack, op_use);
lib/SPVM/Builder/src/spvm_compiler.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_compiler.c:  for (int32_t i = 0; i < compiler->ops->length; i++) {
lib/SPVM/Builder/src/spvm_compiler.c:    SPVM_OP* op = SPVM_LIST_get(compiler->ops, i);
lib/SPVM/Builder/src/spvm_compiler.c:        SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, op->uv.block);
lib/SPVM/Builder/src/spvm_compiler.c:        SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, op->uv.attribute);
lib/SPVM/Builder/src/spvm_compiler.c:        SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, use);
lib/SPVM/Builder/src/spvm_compiler.c:        SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, allow);
lib/SPVM/Builder/src/spvm_compiler.c:        SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, interface);
lib/SPVM/Builder/src/spvm_compiler.c:        SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, class_var_access);
lib/SPVM/Builder/src/spvm_compiler.c:        SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, constant);
lib/SPVM/Builder/src/spvm_compiler.c:        SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, array_field_access);
lib/SPVM/Builder/src/spvm_compiler.c:        SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, field_access);
lib/SPVM/Builder/src/spvm_compiler.c:        SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, call_method);
lib/SPVM/Builder/src/spvm_compiler.c:        SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, var);
lib/SPVM/Builder/src/spvm_compiler.c:          SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, var_decl);
lib/SPVM/Builder/src/spvm_compiler.c:    SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, op);
lib/SPVM/Builder/src/spvm_compiler.c:  for (int32_t basic_type_id = compiler->basic_types_base_id; basic_type_id < compiler->basic_types->length; basic_type_id++) {
lib/SPVM/Builder/src/spvm_compiler.c:    SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_compiler.c:  SPVM_LIST_free(compiler->op_use_stack);
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->op_use_stack = NULL;
lib/SPVM/Builder/src/spvm_compiler.c:  SPVM_LIST_free(compiler->op_types);
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->op_types = NULL;
lib/SPVM/Builder/src/spvm_compiler.c:  SPVM_LIST_free(compiler->ops);
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->ops = NULL;
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->error_messages = SPVM_LIST_new_list_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_compiler.c:  int32_t compile_start_memory_blocks_count_tmp = compiler->global_allocator->memory_blocks_count_tmp;
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->ops = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->op_use_stack = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->op_types = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->basic_types_base_id = compiler->basic_types->length;
lib/SPVM/Builder/src/spvm_compiler.c:  if (compiler->basic_types->length == 0) {
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->end_of_file = 1;
lib/SPVM/Builder/src/spvm_compiler.c:        int32_t build_opcode_list_start_memory_blocks_count_tmp = compiler->global_allocator->memory_blocks_count_tmp;
lib/SPVM/Builder/src/spvm_compiler.c:        assert(compiler->global_allocator->memory_blocks_count_tmp == build_opcode_list_start_memory_blocks_count_tmp);
lib/SPVM/Builder/src/spvm_compiler.c:  assert(compiler->global_allocator->memory_blocks_count_tmp == compile_start_memory_blocks_count_tmp);
lib/SPVM/Builder/src/spvm_compiler.c:  SPVM_RUNTIME* current_runtime = compiler->runtime;
lib/SPVM/Builder/src/spvm_compiler.c:  runtime->basic_types = SPVM_ALLOCATOR_alloc_memory_block_tmp(runtime->allocator, sizeof(SPVM_RUNTIME_BASIC_TYPE*) * compiler->basic_types->length);
lib/SPVM/Builder/src/spvm_compiler.c:  runtime->basic_types_length = compiler->basic_types->length;
lib/SPVM/Builder/src/spvm_compiler.c:  for (int32_t basic_type_id = current_runtime_basic_types_length; basic_type_id < compiler->basic_types->length; basic_type_id++) {
lib/SPVM/Builder/src/spvm_compiler.c:    SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_compiler.c:  for (int32_t basic_type_id = current_runtime_basic_types_length; basic_type_id < compiler->basic_types->length; basic_type_id++) {
lib/SPVM/Builder/src/spvm_compiler.c:    SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_compiler.c:      SPVM_BASIC_TYPE* parent_basic_type = SPVM_HASH_get(compiler->basic_type_symtable, basic_type->parent->name, strlen(basic_type->parent->name));
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->runtime = runtime;
lib/SPVM/Builder/src/spvm_compiler.c:  return compiler->runtime;
lib/SPVM/Builder/src/spvm_compiler.c:  char* message = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, message_length + 1);
lib/SPVM/Builder/src/spvm_compiler.c:  SPVM_LIST_push(compiler->error_messages, message);
lib/SPVM/Builder/src/spvm_compiler.c:    SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, (void*)start_file);
lib/SPVM/Builder/src/spvm_compiler.c:  if (compiler->runtime) {
lib/SPVM/Builder/src/spvm_compiler.c:    SPVM_RUNTIME_free(compiler->runtime);
lib/SPVM/Builder/src/spvm_compiler.c:    compiler->runtime = NULL;
lib/SPVM/Builder/src/spvm_compiler.c:  SPVM_ALLOCATOR_free(compiler->global_allocator);
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->global_allocator = NULL;
lib/SPVM/Builder/src/spvm_compiler.c:  return compiler->start_file;
lib/SPVM/Builder/src/spvm_compiler.c:  if (compiler->start_file) {
lib/SPVM/Builder/src/spvm_compiler.c:    SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, (void*)compiler->start_file);
lib/SPVM/Builder/src/spvm_compiler.c:    compiler->start_file = NULL;
lib/SPVM/Builder/src/spvm_compiler.c:    compiler_start_file = SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, start_file_length + 1);
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->start_file = compiler_start_file;
lib/SPVM/Builder/src/spvm_compiler.c:  return compiler->start_line;
lib/SPVM/Builder/src/spvm_compiler.c:  compiler->start_line = start_line;
lib/SPVM/Builder/src/spvm_compiler.c:  SPVM_LIST* include_dirs = compiler->include_dirs;
lib/SPVM/Builder/src/spvm_compiler.c:  char* compiler_include_dir = SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, include_dir_length + 1);
lib/SPVM/Builder/src/spvm_compiler.c:  SPVM_LIST_push(compiler->include_dirs, (void*)compiler_include_dir);
lib/SPVM/Builder/src/spvm_compiler.c:    SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, (void*)include_dir);
lib/SPVM/Builder/src/spvm_compiler.c:  SPVM_LIST_clear(compiler->include_dirs);
lib/SPVM/Builder/src/spvm_compiler.c:  const char* include_dir = SPVM_LIST_get(compiler->include_dirs, include_dir_id);
lib/SPVM/Builder/src/spvm_yacc.c:       to allow for a few compiler-allocated temporary stack slots.  */
lib/SPVM/Builder/src/spvm_yacc.c:      (yyval.opval) = SPVM_OP_new_op_list(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      (yyval.opval) = SPVM_OP_new_op_list(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_use = SPVM_OP_new_op_use(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_use = SPVM_OP_new_op_use(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      (yyval.opval) = SPVM_OP_new_op_list(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      (yyval.opval) = SPVM_OP_new_op_list(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      (yyval.opval) = SPVM_OP_new_op_list(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      (yyval.opval) = SPVM_OP_new_op_list(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      (yyval.opval) = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_DO_NOTHING, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_block = SPVM_OP_new_op_block(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_block = SPVM_OP_new_op_block(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      (yyval.opval) = SPVM_OP_new_op_list(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_if_require = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_IF_REQUIRE, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_if_require = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_IF_REQUIRE, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      (yyval.opval) = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_DO_NOTHING, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      (yyval.opval) = SPVM_OP_new_op_list(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      (yyval.opval) = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_DO_NOTHING, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:        SPVM_OP* op_sequence = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_SEQUENCE, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_array_init = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_ARRAY_INIT, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_array_init = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_ARRAY_INIT, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_array_init = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_ARRAY_INIT, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_list_elements = SPVM_OP_new_op_list(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_call_method = SPVM_OP_new_op_call_method(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_call_method = SPVM_OP_new_op_call_method(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_call_method = SPVM_OP_new_op_call_method(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_call_method = SPVM_OP_new_op_call_method(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_call_method = SPVM_OP_new_op_call_method(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_call_method = SPVM_OP_new_op_call_method(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_call_method = SPVM_OP_new_op_call_method(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_array_access = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_ARRAY_ACCESS, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_array_access = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_ARRAY_ACCESS, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_array_access = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_ARRAY_ACCESS, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_field_access = SPVM_OP_new_op_field_access(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_field_access = SPVM_OP_new_op_field_access(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_field_access = SPVM_OP_new_op_field_access(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_field_access = SPVM_OP_new_op_field_access(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_field_access = SPVM_OP_new_op_field_access(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_field_access = SPVM_OP_new_op_field_access(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_array_length = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_ARRAY_LENGTH, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_array_length = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_ARRAY_LENGTH, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_array_length = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_ARRAY_LENGTH, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      SPVM_OP* op_array_length = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_ARRAY_LENGTH, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      (yyval.opval) = SPVM_OP_new_op_void_type(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_yacc.c:      (yyval.opval) = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_DO_NOTHING, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_opcode_list.c:  SPVM_OPCODE_LIST* opcodes = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, sizeof(SPVM_OPCODE_LIST));
lib/SPVM/Builder/src/spvm_opcode_list.c:  SPVM_OPCODE* values = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, values_size);
lib/SPVM/Builder/src/spvm_opcode_list.c:    SPVM_OPCODE* new_values = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, new_values_size);
lib/SPVM/Builder/src/spvm_allow.c:  SPVM_ALLOW* allow = SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, sizeof(SPVM_ALLOW));
lib/SPVM/Builder/src/spvm_interface.c:  SPVM_INTERFACE* interface = SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, sizeof(SPVM_INTERFACE));
lib/SPVM/Builder/src/spvm_op.c:  SPVM_BASIC_TYPE* basic_type = SPVM_HASH_get(compiler->basic_type_symtable, basic_type_name, strlen(basic_type_name));
lib/SPVM/Builder/src/spvm_op.c:  type->basic_type->module_dir = compiler->current_include_dir;
lib/SPVM/Builder/src/spvm_op.c:  type->basic_type->module_rel_file = compiler->current_rel_file;
lib/SPVM/Builder/src/spvm_op.c:  type->basic_type->module_file = compiler->current_file;
lib/SPVM/Builder/src/spvm_op.c:  SPVM_BASIC_TYPE* found_basic_type = SPVM_HASH_get(compiler->basic_type_symtable, basic_type_name, strlen(basic_type_name));
lib/SPVM/Builder/src/spvm_op.c:    if (strcmp(basic_type_name, compiler->current_rel_file_basic_type_name) != 0) {
lib/SPVM/Builder/src/spvm_op.c:      SPVM_COMPILER_error(compiler, "The module name \"%s\" must be \"%s\".\n  at %s line %d", basic_type_name, compiler->current_rel_file_basic_type_name, op_module->file, op_module->line);
lib/SPVM/Builder/src/spvm_op.c:    SPVM_LIST* anon_op_types = compiler->current_anon_op_types;
lib/SPVM/Builder/src/spvm_op.c:      SPVM_BASIC_TYPE* anon_basic_type = SPVM_HASH_get(compiler->basic_type_symtable, anon_unresolved_basic_type_name, strlen(anon_unresolved_basic_type_name));
lib/SPVM/Builder/src/spvm_op.c:              SPVM_COMPILER_error(compiler, "A version string must be able to be parsed by the \"strtod\" C function.\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_op.c:          SPVM_OP* op_list_attributes = SPVM_OP_new_op_list(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_op.c:          SPVM_OP* op_attribute_static = SPVM_OP_new_op_attribute(compiler, SPVM_ATTRIBUTE_C_ID_STATIC, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_op.c:          char* method_name_tmp = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, 4 + strlen(class_var->name) - 1 + 1);
lib/SPVM/Builder/src/spvm_op.c:          SPVM_OP* op_list_attributes = SPVM_OP_new_op_list(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_op.c:          SPVM_OP* op_attribute_static = SPVM_OP_new_op_attribute(compiler, SPVM_ATTRIBUTE_C_ID_STATIC, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_op.c:          char* method_name_tmp = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, 4 + strlen(field->name) + 1);
lib/SPVM/Builder/src/spvm_op.c:          char* arg_name_tmp = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, 1 + strlen(field->name) + 1);
lib/SPVM/Builder/src/spvm_op.c:        char* method_abs_name = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, method_abs_name_length + 1);
lib/SPVM/Builder/src/spvm_op.c:  SPVM_LIST_push(compiler->op_use_stack, op_use);
lib/SPVM/Builder/src/spvm_op.c:  compiler->current_enum_value = 0;
lib/SPVM/Builder/src/spvm_op.c:      compiler->current_enum_value = constant->value.ival;
lib/SPVM/Builder/src/spvm_op.c:    compiler->current_enum_value++;
lib/SPVM/Builder/src/spvm_op.c:    op_constant = SPVM_OP_new_op_constant_int(compiler, (int32_t)compiler->current_enum_value, op_name->file, op_name->line);
lib/SPVM/Builder/src/spvm_op.c:    compiler->current_enum_value++;
lib/SPVM/Builder/src/spvm_op.c:  SPVM_OP* op_list_attributes = SPVM_OP_new_op_list(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_op.c:  SPVM_OP* op_attribute_static = SPVM_OP_new_op_attribute(compiler, SPVM_ATTRIBUTE_C_ID_STATIC, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_op.c:  SPVM_OP* op_list_definitions = SPVM_OP_new_op_list(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_op.c:  const char* anon_method_defined_rel_file_basic_type_name = compiler->current_rel_file_basic_type_name;
lib/SPVM/Builder/src/spvm_op.c:  char* name_basic_type_tmp = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, anon_method_basic_type_name_length + 1);
lib/SPVM/Builder/src/spvm_op.c:  SPVM_LIST_push(compiler->current_anon_op_types, op_type);
lib/SPVM/Builder/src/spvm_op.c:  SPVM_OP* op_array_length = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_ARRAY_LENGTH, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_op.c:  SPVM_OP* op_array_access = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_ARRAY_ACCESS, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_op.c:    SPVM_BASIC_TYPE* anon_basic_type = SPVM_HASH_get(compiler->basic_type_symtable, anon_basic_type_name, strlen(anon_basic_type_name));
lib/SPVM/Builder/src/spvm_op.c:  SPVM_BASIC_TYPE* found_basic_type = SPVM_HASH_get(compiler->basic_type_symtable, name, strlen(name));
lib/SPVM/Builder/src/spvm_op.c:    SPVM_BASIC_TYPE* new_basic_type = SPVM_LIST_get(compiler->basic_types, 0);
lib/SPVM/Builder/src/spvm_op.c:  SPVM_LIST_push(compiler->op_types, op_type);
lib/SPVM/Builder/src/spvm_op.c:  char* name = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, strlen("$.tmp_in_op2147483647") + 1);
lib/SPVM/Builder/src/spvm_op.c:  sprintf(name, "$.tmp_in_op%d", compiler->current_tmp_vars_length);
lib/SPVM/Builder/src/spvm_op.c:  compiler->current_tmp_vars_length++;
lib/SPVM/Builder/src/spvm_op.c:  SPVM_OP *op = SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, sizeof(SPVM_OP));
lib/SPVM/Builder/src/spvm_op.c:  SPVM_LIST_push(compiler->ops, op);
Binary file lib/SPVM/Builder/src/spvm_toke.o matches
lib/SPVM/Builder/src/spvm_string.c:  SPVM_STRING* found_string = SPVM_HASH_get(compiler->constant_string_symtable, value, length);
lib/SPVM/Builder/src/spvm_string.c:    SPVM_STRING* string = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, sizeof(SPVM_STRING));
lib/SPVM/Builder/src/spvm_string.c:    string->value = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, length + 1);
lib/SPVM/Builder/src/spvm_string.c:    SPVM_HASH_set(compiler->constant_string_symtable, string->value, length, string);
lib/SPVM/Builder/src/spvm_switch_info.c:  SPVM_SWITCH_INFO* switch_info = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, sizeof(SPVM_SWITCH_INFO));
lib/SPVM/Builder/src/spvm_switch_info.c:  switch_info->case_infos = SPVM_LIST_new_list_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_field_access.c:  return SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, sizeof(SPVM_FIELD_ACCESS));
lib/SPVM/Builder/src/spvm_class_var.c:  return SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, sizeof(SPVM_CLASS_VAR));
lib/SPVM/Builder/src/spvm_var.c:  return SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, sizeof(SPVM_VAR));
lib/SPVM/Builder/src/spvm_block.c:  SPVM_BLOCK* block = SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, sizeof(SPVM_BLOCK));
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_type.c:    type_name = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, type_name_length + 1);
lib/SPVM/Builder/src/spvm_type.c:    type_name = SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, type_name_length + 1);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_TYPE* type = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, sizeof(SPVM_TYPE));
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_TYPE* type = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, sizeof(SPVM_TYPE));
lib/SPVM/Builder/src/spvm_type.c:  SPVM_TYPE* type = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, sizeof(SPVM_TYPE));
lib/SPVM/Builder/src/spvm_type.c:  type->basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_UNKNOWN);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_VOID);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_ANY_OBJECT);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_UNDEF);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_BYTE);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_SHORT);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_INT);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_LONG);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_FLOAT);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_DOUBLE);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_STRING);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_ANY_OBJECT);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_BYTE_CLASS);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_SHORT_CLASS);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_INT_CLASS);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_LONG_CLASS);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_FLOAT_CLASS);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_DOUBLE_CLASS);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_BOOL_CLASS);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_BYTE);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_SHORT);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_INT);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_LONG);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_FLOAT);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_DOUBLE);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_ANY_OBJECT);
lib/SPVM/Builder/src/spvm_type.c:  SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, SPVM_NATIVE_C_BASIC_TYPE_ID_ANY_OBJECT);
lib/SPVM/Builder/src/spvm_type.c:    SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_type.c:    SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_yacc_util.c:  const char* ptr = compiler->before_ch_ptr;
lib/SPVM/Builder/src/spvm_yacc_util.c:  while (ptr != compiler->ch_ptr) {
lib/SPVM/Builder/src/spvm_yacc_util.c:  char* token = (char*) SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, length + 1);
lib/SPVM/Builder/src/spvm_yacc_util.c:  memcpy(token, compiler->before_ch_ptr + empty_count, length);
lib/SPVM/Builder/src/spvm_yacc_util.c:  int32_t char_pos = (int32_t)(compiler->before_ch_ptr + empty_count + 1 - compiler->line_begin_ptr);
lib/SPVM/Builder/src/spvm_yacc_util.c:  SPVM_COMPILER_error(compiler, "Unexpected token \"%s\"\n  at %s line %d:%d", token, compiler->current_file, compiler->current_line, char_pos);
lib/SPVM/Builder/src/spvm_yacc_util.c:  SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, token);
lib/SPVM/Builder/src/spvm_use.c:  SPVM_USE* use = SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, sizeof(SPVM_USE));
lib/SPVM/Builder/src/spvm_call_method.c:  return SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, sizeof(SPVM_CALL_METHOD));
lib/SPVM/Builder/src/spvm_attribute.c:  return SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, sizeof(SPVM_ATTRIBUTE));
lib/SPVM/Builder/src/spvm_module_file.c:  return SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, sizeof(SPVM_MODULE_FILE));
lib/SPVM/Builder/src/spvm_toke.c:  if (compiler->ch_ptr == NULL) {
lib/SPVM/Builder/src/spvm_toke.c:    compiler->ch_ptr = "";
lib/SPVM/Builder/src/spvm_toke.c:  compiler->before_ch_ptr = compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:  int32_t before_token_is_arrow = compiler->before_token_is_arrow;
lib/SPVM/Builder/src/spvm_toke.c:  compiler->before_token_is_arrow = 0;
lib/SPVM/Builder/src/spvm_toke.c:  int32_t expect_method_name = compiler->expect_method_name;
lib/SPVM/Builder/src/spvm_toke.c:  compiler->expect_method_name = 0;
lib/SPVM/Builder/src/spvm_toke.c:  int32_t expect_field_name = compiler->expect_field_name;
lib/SPVM/Builder/src/spvm_toke.c:  compiler->expect_field_name = 0;
lib/SPVM/Builder/src/spvm_toke.c:  int32_t var_expansion_state = compiler->var_expansion_state;
lib/SPVM/Builder/src/spvm_toke.c:  compiler->var_expansion_state = SPVM_TOKE_C_VAR_EXPANSION_STATE_NOT_STARTED;
lib/SPVM/Builder/src/spvm_toke.c:  int32_t end_of_file = compiler->end_of_file;
lib/SPVM/Builder/src/spvm_toke.c:  compiler->end_of_file = 0;
lib/SPVM/Builder/src/spvm_toke.c:    int32_t source_index = compiler->ch_ptr - compiler->current_source;
lib/SPVM/Builder/src/spvm_toke.c:    if (!compiler->current_source || source_index >= compiler->current_source_length) {
lib/SPVM/Builder/src/spvm_toke.c:        compiler->end_of_file = 1;
lib/SPVM/Builder/src/spvm_toke.c:      if (compiler->current_source) {
lib/SPVM/Builder/src/spvm_toke.c:    if (compiler->ch_ptr == compiler->next_string_literal_ch_ptr) {
lib/SPVM/Builder/src/spvm_toke.c:      compiler->next_string_literal_ch_ptr = NULL;
lib/SPVM/Builder/src/spvm_toke.c:          ch = *compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:          ch = *compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:      ch = *compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->before_ch_ptr = compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:        if (*compiler->ch_ptr == '\r' && *(compiler->ch_ptr + 1) == '\n') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->current_line++;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->line_begin_ptr = compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->before_ch_ptr = compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->var_expansion_state = SPVM_TOKE_C_VAR_EXPANSION_STATE_VAR;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->var_expansion_state = SPVM_TOKE_C_VAR_EXPANSION_STATE_BEGIN_NEXT_STRING_LITERAL;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          if (*compiler->ch_ptr == '=') {
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        if (*compiler->ch_ptr == '+') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        else if (*compiler->ch_ptr == '=') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        if (isdigit(*compiler->ch_ptr)) {
lib/SPVM/Builder/src/spvm_toke.c:        else if (*compiler->ch_ptr == '>') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->expect_method_name = 1;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->before_token_is_arrow = 1;
lib/SPVM/Builder/src/spvm_toke.c:        else if (*compiler->ch_ptr == '-') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        else if (*compiler->ch_ptr == '=') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        if (*compiler->ch_ptr == '=') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        if (*compiler->ch_ptr == '=') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        if (*compiler->ch_ptr == '=') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        if (*compiler->ch_ptr == '=') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        if (*compiler->ch_ptr == '|') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        else if (*compiler->ch_ptr == '=') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        if (*compiler->ch_ptr == '&') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        else if (*compiler->ch_ptr == '=') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        else if (isalpha(*compiler->ch_ptr) || *compiler->ch_ptr == '_') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->expect_method_name = 1;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          if (*compiler->ch_ptr == '\r' && *(compiler->ch_ptr + 1) == '\n') {
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          if (*compiler->ch_ptr == '\n' || *compiler->ch_ptr == '\r' || *compiler->ch_ptr == '\0') {
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        if (compiler->ch_ptr == compiler->current_source || *(compiler->ch_ptr - 1) == '\n') {
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:            if (*compiler->ch_ptr == '\n') {
lib/SPVM/Builder/src/spvm_toke.c:              compiler->current_line++;
lib/SPVM/Builder/src/spvm_toke.c:            if (*compiler->ch_ptr == '\0') {
lib/SPVM/Builder/src/spvm_toke.c:              *compiler->ch_ptr == '='
lib/SPVM/Builder/src/spvm_toke.c:              && strncmp(compiler->ch_ptr + 1, "cut", 3) == 0
lib/SPVM/Builder/src/spvm_toke.c:              && (*(compiler->ch_ptr + 4) == '\0' || SPVM_TOKE_is_white_space(compiler, *(compiler->ch_ptr + 4)))
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr += 4;
lib/SPVM/Builder/src/spvm_toke.c:                if (*compiler->ch_ptr == '\n' || *compiler->ch_ptr == '\0') {
lib/SPVM/Builder/src/spvm_toke.c:                compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          if (*compiler->ch_ptr == '=') {
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          if (*compiler->ch_ptr == '>') {
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        if (*compiler->ch_ptr == '<') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          if (*compiler->ch_ptr == '=') {
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        else if (*compiler->ch_ptr == '=') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          if (*compiler->ch_ptr == '>') {
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        if (*compiler->ch_ptr == '>') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          if (*compiler->ch_ptr == '>') {
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:            if (*compiler->ch_ptr == '=') {
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:            if (*compiler->ch_ptr == '=') {
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        else if (*compiler->ch_ptr == '=') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        if (*compiler->ch_ptr == '=') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        if (*compiler->ch_ptr == '\'') {
lib/SPVM/Builder/src/spvm_toke.c:          SPVM_COMPILER_error(compiler, "The character literal cannnot be empty.\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          if (*compiler->ch_ptr == '\\') {
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:            if (*compiler->ch_ptr == 'a') {
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:            else if (*compiler->ch_ptr == 't') {
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:            else if (*compiler->ch_ptr == 'n') {
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:            else if (*compiler->ch_ptr == 'f') {
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:            else if (*compiler->ch_ptr == 'r') {
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:            else if (*compiler->ch_ptr == '\'') {
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:            else if (*compiler->ch_ptr == '"') {
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:            else if (*compiler->ch_ptr == '\\') {
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:            else if (SPVM_TOKE_is_octal_number(compiler, *compiler->ch_ptr) || *compiler->ch_ptr == 'o') {
lib/SPVM/Builder/src/spvm_toke.c:              char* char_ptr = compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr = char_ptr;
lib/SPVM/Builder/src/spvm_toke.c:            else if (*compiler->ch_ptr == 'x') {
lib/SPVM/Builder/src/spvm_toke.c:              char* char_ptr = compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr = char_ptr;
lib/SPVM/Builder/src/spvm_toke.c:              SPVM_COMPILER_error(compiler, "\"\\%c\" is the invalid charater literal escape character.\n  at %s line %d", *compiler->ch_ptr, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:            ch = *compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          if (*compiler->ch_ptr == '\'') {
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:            SPVM_COMPILER_error(compiler, "The character literal must ends with \"'\".\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:        SPVM_OP* op_constant = SPVM_OP_new_op_constant_byte(compiler, ch, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:          compiler->var_expansion_state = SPVM_TOKE_C_VAR_EXPANSION_STATE_NOT_STARTED;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        const char* current_token_ptr = compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:        int32_t memory_blocks_count_tmp = compiler->global_allocator->memory_blocks_count_tmp;
lib/SPVM/Builder/src/spvm_toke.c:        if (*(compiler->ch_ptr) == '"') {
lib/SPVM/Builder/src/spvm_toke.c:          string_literal_tmp = SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, 1);
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:            if (*compiler->ch_ptr == '"') {
lib/SPVM/Builder/src/spvm_toke.c:            else if (*compiler->ch_ptr == '$') {
lib/SPVM/Builder/src/spvm_toke.c:              if (*(compiler->ch_ptr + 1) == '"') {
lib/SPVM/Builder/src/spvm_toke.c:                char* next_string_literal_ch_ptr = compiler->ch_ptr + 1;
lib/SPVM/Builder/src/spvm_toke.c:                          SPVM_COMPILER_error(compiler, "The character after \"->\" in a string literal must be \"[\" or \"{\".\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                          SPVM_COMPILER_error(compiler, "The getting field in a string literal must be closed with \"}\".\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                          SPVM_COMPILER_error(compiler, "The getting array element in a string literal must be closed with \"]\".\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                compiler->next_string_literal_ch_ptr = next_string_literal_ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:            else if (*compiler->ch_ptr == '\0') {
lib/SPVM/Builder/src/spvm_toke.c:              if (*compiler->ch_ptr == '\\') {
lib/SPVM/Builder/src/spvm_toke.c:                compiler->ch_ptr += 2;
lib/SPVM/Builder/src/spvm_toke.c:                compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          if (*compiler->ch_ptr == '\0') {
lib/SPVM/Builder/src/spvm_toke.c:            SPVM_COMPILER_error(compiler, "The string literal must be end with '\"'.\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:          int32_t string_literal_tmp_len = (int32_t)(compiler->ch_ptr - current_token_ptr) * 4;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          string_literal_tmp = SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, string_literal_tmp_len + 1);
lib/SPVM/Builder/src/spvm_toke.c:            while (char_ptr != compiler->ch_ptr - 1) {
lib/SPVM/Builder/src/spvm_toke.c:                        SPVM_COMPILER_error(compiler, "One or more than one hexadecimal numbers must be followed by \"\\N{U+\" of the Unicode escape character.\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                        SPVM_COMPILER_error(compiler, "Too big Unicode escape character.\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                        int32_t memory_blocks_count_tmp = compiler->global_allocator->memory_blocks_count_tmp;
lib/SPVM/Builder/src/spvm_toke.c:                        char* unicode_chars = SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, unicode_chars_length + 1);
lib/SPVM/Builder/src/spvm_toke.c:                          SPVM_COMPILER_error(compiler, "The code point of Unicode escape character must be a Unicode scalar value.\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                        SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, unicode_chars);
lib/SPVM/Builder/src/spvm_toke.c:                        assert(compiler->global_allocator->memory_blocks_count_tmp == memory_blocks_count_tmp);
lib/SPVM/Builder/src/spvm_toke.c:                      SPVM_COMPILER_error(compiler, "A Unicode escape character must be closed by \"}\".\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                    SPVM_COMPILER_error(compiler, "Invalid Unicode escape character.\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                      SPVM_COMPILER_error(compiler, "Invalid string literal escape character \"\\%c\".\n  at %s line %d", *char_ptr, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  compiler->current_line++;
lib/SPVM/Builder/src/spvm_toke.c:                  compiler->line_begin_ptr = compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:        SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, string_literal_tmp);
lib/SPVM/Builder/src/spvm_toke.c:        assert(compiler->global_allocator->memory_blocks_count_tmp == memory_blocks_count_tmp);
lib/SPVM/Builder/src/spvm_toke.c:        SPVM_OP* op_constant = SPVM_OP_new_op_constant_string(compiler, string_literal, string_literal_length, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:          compiler->var_expansion_state = next_var_expansion_state;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr--;
lib/SPVM/Builder/src/spvm_toke.c:        compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        if (*(compiler->ch_ptr + 1) == '$') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:        else if (*(compiler->ch_ptr + 1) == '@') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr += 2;
lib/SPVM/Builder/src/spvm_toke.c:          SPVM_OP* op_exception_var = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_EXCEPTION_VAR, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:        else if (*(compiler->ch_ptr + 1) == '{' && *(compiler->ch_ptr + 2) == '@' && *(compiler->ch_ptr + 3) == '}') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr += 4;
lib/SPVM/Builder/src/spvm_toke.c:          SPVM_OP* op_exception_var = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_EXCEPTION_VAR, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          if (*compiler->ch_ptr == '{') {
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          const char* var_name_symbol_name_part_start_ptr = compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:            isalnum(*compiler->ch_ptr)
lib/SPVM/Builder/src/spvm_toke.c:            || (*compiler->ch_ptr) == '_'
lib/SPVM/Builder/src/spvm_toke.c:            || (*compiler->ch_ptr == ':' && *(compiler->ch_ptr + 1) == ':')
lib/SPVM/Builder/src/spvm_toke.c:            if (*compiler->ch_ptr == ':' && *(compiler->ch_ptr + 1) == ':') {
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr += 2;
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          int32_t var_name_symbol_name_part_length = compiler->ch_ptr - var_name_symbol_name_part_start_ptr;
lib/SPVM/Builder/src/spvm_toke.c:            int32_t memory_blocks_count_tmp_var_name_tmp = compiler->global_allocator->memory_blocks_count_tmp;
lib/SPVM/Builder/src/spvm_toke.c:            char* var_name_tmp = SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, var_name_length + 1);
lib/SPVM/Builder/src/spvm_toke.c:            SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, var_name_tmp);
lib/SPVM/Builder/src/spvm_toke.c:            assert(compiler->global_allocator->memory_blocks_count_tmp == memory_blocks_count_tmp_var_name_tmp);
lib/SPVM/Builder/src/spvm_toke.c:            if (*compiler->ch_ptr == '}') {
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:              SPVM_COMPILER_error(compiler, "The variable name is not closed by \"}\".\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:              SPVM_COMPILER_error(compiler, "The variable name \"%s\" cannnot contain \"__\".\n  at %s line %d", var_name, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:              SPVM_COMPILER_error(compiler, "The variable name \"%s\" cannnot begin with \"$::\".\n  at %s line %d", var_name, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:              SPVM_COMPILER_error(compiler, "The variable name \"%s\" cannnot end with \"::\".\n  at %s line %d", var_name, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:              SPVM_COMPILER_error(compiler, "The variable name \"%s\" cannnot contain \"::::\".\n  at %s line %d", var_name, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:              SPVM_COMPILER_error(compiler, "The symbol name part of the variable name \"%s\" cannnot begin with a number.\n  at %s line %d", var_name, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:          SPVM_OP* op_name = SPVM_OP_new_op_name(compiler, var_name, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:        compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->expect_field_name = 1;
lib/SPVM/Builder/src/spvm_toke.c:          const char* number_literal_begin_ptr = compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:          if (*(compiler->ch_ptr) == '0') {
lib/SPVM/Builder/src/spvm_toke.c:            if (*(compiler->ch_ptr + 1) == 'x' || *(compiler->ch_ptr + 1) == 'X') {
lib/SPVM/Builder/src/spvm_toke.c:            else if (*(compiler->ch_ptr + 1) == 'b' || *(compiler->ch_ptr + 1) == 'B') {
lib/SPVM/Builder/src/spvm_toke.c:            else if (isdigit(*(compiler->ch_ptr + 1)) || *(compiler->ch_ptr + 1) == '_') {
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr += 2;
lib/SPVM/Builder/src/spvm_toke.c:              SPVM_TOKE_is_hex_number(compiler, *compiler->ch_ptr) || *compiler->ch_ptr == '_'
lib/SPVM/Builder/src/spvm_toke.c:              || *compiler->ch_ptr == '.' || *compiler->ch_ptr == 'p' || *compiler->ch_ptr == 'P' || *compiler->ch_ptr == '-' || *compiler->ch_ptr == '+'
lib/SPVM/Builder/src/spvm_toke.c:              if (*compiler->ch_ptr == '.' || *compiler->ch_ptr == 'p' || *compiler->ch_ptr == 'P') {
lib/SPVM/Builder/src/spvm_toke.c:              if (*compiler->ch_ptr == 'p' || *compiler->ch_ptr == 'P') {
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr += 1;
lib/SPVM/Builder/src/spvm_toke.c:              isdigit(*compiler->ch_ptr)
lib/SPVM/Builder/src/spvm_toke.c:              || *compiler->ch_ptr == '_'
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:              isdigit(*compiler->ch_ptr)
lib/SPVM/Builder/src/spvm_toke.c:              || *compiler->ch_ptr == '.' || *compiler->ch_ptr == '-' || *compiler->ch_ptr == '+' || *compiler->ch_ptr == 'e' || *compiler->ch_ptr == 'E'
lib/SPVM/Builder/src/spvm_toke.c:              || *compiler->ch_ptr == '_'
lib/SPVM/Builder/src/spvm_toke.c:              if (*compiler->ch_ptr == '.' || *compiler->ch_ptr == 'e' || *compiler->ch_ptr == 'E') {
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          int32_t str_len = (compiler->ch_ptr - number_literal_begin_ptr);
lib/SPVM/Builder/src/spvm_toke.c:          int32_t numeric_literal_memoyr_blocks_count = compiler->global_allocator->memory_blocks_count_tmp;
lib/SPVM/Builder/src/spvm_toke.c:          char* numeric_literal = (char*)SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, str_len + 1);
lib/SPVM/Builder/src/spvm_toke.c:          if (is_hex_floating_number && !isdigit(*(compiler->ch_ptr - 1))) {
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr--;
lib/SPVM/Builder/src/spvm_toke.c:          if (*compiler->ch_ptr == 'l' || *compiler->ch_ptr == 'L')  {
lib/SPVM/Builder/src/spvm_toke.c:            suffix[0] = *compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          else if (*compiler->ch_ptr == 'f' || *compiler->ch_ptr == 'F')  {
lib/SPVM/Builder/src/spvm_toke.c:            suffix[0] = *compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          else if (*compiler->ch_ptr == 'd' || *compiler->ch_ptr == 'D')  {
lib/SPVM/Builder/src/spvm_toke.c:            suffix[0] = *compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:            compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:              SPVM_COMPILER_error(compiler, "The numeric literal \"%s%s\" is out of range of maximum and minimum values of int type.\n  at %s line %d", minus ? "-" : "", numeric_literal, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:              SPVM_COMPILER_error(compiler, "The numeric literal \"%s%s%s\" is out of range of maximum and minimum values of long type.\n  at %s line %d", minus ? "-" : "", numeric_literal, suffix, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:              SPVM_COMPILER_error(compiler, "Invalid float literal.\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:              SPVM_COMPILER_error(compiler, "Invalid double literal.\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:          SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, numeric_literal);
lib/SPVM/Builder/src/spvm_toke.c:          assert(compiler->global_allocator->memory_blocks_count_tmp == numeric_literal_memoyr_blocks_count);
lib/SPVM/Builder/src/spvm_toke.c:              op_constant = SPVM_OP_new_op_constant_int(compiler, num.ival, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:              op_constant = SPVM_OP_new_op_constant_long(compiler, num.lval, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:              op_constant = SPVM_OP_new_op_constant_float(compiler, num.fval, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:              op_constant = SPVM_OP_new_op_constant_double(compiler, num.dval, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:          int32_t column = compiler->ch_ptr - compiler->line_begin_ptr;
lib/SPVM/Builder/src/spvm_toke.c:          const char* symbol_name_start_ptr = compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          while(isalnum(*compiler->ch_ptr)
lib/SPVM/Builder/src/spvm_toke.c:            || *compiler->ch_ptr == '_'
lib/SPVM/Builder/src/spvm_toke.c:            || (*compiler->ch_ptr == ':' && *(compiler->ch_ptr + 1) == ':'))
lib/SPVM/Builder/src/spvm_toke.c:            if (*compiler->ch_ptr == ':' && *(compiler->ch_ptr + 1) == ':') {
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr += 2;
lib/SPVM/Builder/src/spvm_toke.c:              compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:          int32_t symbol_name_length = (compiler->ch_ptr - symbol_name_start_ptr);
lib/SPVM/Builder/src/spvm_toke.c:          char* symbol_name = SPVM_ALLOCATOR_alloc_memory_block_tmp(compiler->global_allocator, symbol_name_length + 1);
lib/SPVM/Builder/src/spvm_toke.c:          char* fat_camma_check_ptr = compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:                  compiler->expect_field_name = 1;
lib/SPVM/Builder/src/spvm_toke.c:                  SPVM_OP* op_attribute = SPVM_OP_new_op_attribute(compiler, SPVM_ATTRIBUTE_C_ID_INTERFACE_T, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  SPVM_OP* op_var_decl = SPVM_OP_new_op_var_decl(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  SPVM_OP* op_attribute = SPVM_OP_new_op_attribute(compiler, SPVM_ATTRIBUTE_C_ID_MULNUM_T, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  compiler->expect_method_name = 1;
lib/SPVM/Builder/src/spvm_toke.c:                  SPVM_OP* op_attribute = SPVM_OP_new_op_attribute(compiler, SPVM_ATTRIBUTE_C_ID_NATIVE, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  SPVM_OP* op_attribute = SPVM_OP_new_op_attribute(compiler, SPVM_ATTRIBUTE_C_ID_PRIVATE, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  SPVM_OP* op_attribute = SPVM_OP_new_op_attribute(compiler, SPVM_ATTRIBUTE_C_ID_PROTECTED, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  SPVM_OP* op_attribute = SPVM_OP_new_op_attribute(compiler, SPVM_ATTRIBUTE_C_ID_PUBLIC, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  SPVM_OP* op_attribute = SPVM_OP_new_op_attribute(compiler, SPVM_ATTRIBUTE_C_ID_PRECOMPILE, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  SPVM_OP* op_attribute = SPVM_OP_new_op_attribute(compiler, SPVM_ATTRIBUTE_C_ID_POINTER, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  SPVM_OP* op_attribute = SPVM_OP_new_op_attribute(compiler, SPVM_ATTRIBUTE_C_ID_REQUIRED, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  SPVM_OP* op_attribute = SPVM_OP_new_op_attribute(compiler, SPVM_ATTRIBUTE_C_ID_RW, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  SPVM_OP* op_attribute = SPVM_OP_new_op_attribute(compiler, SPVM_ATTRIBUTE_C_ID_RO, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  SPVM_OP* op_attribute = SPVM_OP_new_op_attribute(compiler, SPVM_ATTRIBUTE_C_ID_STATIC, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  compiler->ch_ptr++;
lib/SPVM/Builder/src/spvm_toke.c:                  yylvalp->opval = SPVM_OP_new_op_undef(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  yylvalp->opval = SPVM_OP_new_op_use(compiler, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  SPVM_OP* op_attribute = SPVM_OP_new_op_attribute(compiler, SPVM_ATTRIBUTE_C_ID_WO, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  compiler->ch_ptr = compiler->current_source + compiler->current_source_length;
lib/SPVM/Builder/src/spvm_toke.c:                  compiler->before_ch_ptr = compiler->ch_ptr;
lib/SPVM/Builder/src/spvm_toke.c:                  compiler->end_of_file = 1;
lib/SPVM/Builder/src/spvm_toke.c:                  yylvalp->opval = SPVM_OP_new_op(compiler, SPVM_OP_C_ID_CURRENT_MODULE_NAME, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  SPVM_OP* op_constant = SPVM_OP_new_op_constant_string(compiler, compiler->current_rel_file, strlen(compiler->current_rel_file), compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                  SPVM_OP* op_constant = SPVM_OP_new_op_constant_int(compiler, compiler->current_line, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                SPVM_COMPILER_error(compiler, "The symbol name \"%s\" cannnot constain \"__\".\n  at %s line %d", symbol_name, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                SPVM_COMPILER_error(compiler, "The symbol name \"%s\" cannnot end with \"::\".\n  at %s line %d", symbol_name, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                SPVM_COMPILER_error(compiler, "The symbol name \"%s\" cannnot contains \"::::\".\n  at %s line %d", symbol_name, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:                SPVM_COMPILER_error(compiler, "The string literal \"%s\" of the left operand of the fat camma cannnot contains \"::\".\n  at %s line %d", symbol_name, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:              SPVM_OP* op_constant = SPVM_OP_new_op_constant_string(compiler, symbol_name, symbol_name_length, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:              SPVM_OP* op_name = SPVM_OP_new_op_name(compiler, symbol_name, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:          SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, symbol_name);
lib/SPVM/Builder/src/spvm_toke.c:          SPVM_COMPILER_error(compiler, "The character %d in a 8bit signed integer is not expected.\n  at %s line %d", ch, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:  compiler->current_file = NULL;
lib/SPVM/Builder/src/spvm_toke.c:  compiler->current_source = NULL;
lib/SPVM/Builder/src/spvm_toke.c:  compiler->current_tmp_vars_length = 0;
lib/SPVM/Builder/src/spvm_toke.c:  compiler->ch_ptr = NULL;
lib/SPVM/Builder/src/spvm_toke.c:  compiler->before_ch_ptr = NULL;
lib/SPVM/Builder/src/spvm_toke.c:  compiler->line_begin_ptr = NULL;
lib/SPVM/Builder/src/spvm_toke.c:  compiler->current_anon_op_types = SPVM_LIST_new_list_permanent(compiler->global_allocator, 128);
lib/SPVM/Builder/src/spvm_toke.c:  SPVM_LIST* op_use_stack = compiler->op_use_stack;
lib/SPVM/Builder/src/spvm_toke.c:      SPVM_BASIC_TYPE* basic_type = SPVM_HASH_get(compiler->basic_type_symtable, basic_type_name, strlen(basic_type_name));
lib/SPVM/Builder/src/spvm_toke.c:        char* current_rel_file = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, current_rel_file_length + 1);
lib/SPVM/Builder/src/spvm_toke.c:            current_file = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, file_name_length + 1);
lib/SPVM/Builder/src/spvm_toke.c:              char* include_dirs_str = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, include_dirs_str_length + 1);
lib/SPVM/Builder/src/spvm_toke.c:            char* source = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, source_length + 1);
lib/SPVM/Builder/src/spvm_toke.c:              SPVM_ALLOCATOR_free_memory_block_tmp(compiler->global_allocator, source);
lib/SPVM/Builder/src/spvm_toke.c:          compiler->current_source = (char*)module_file->content;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->current_source_length = module_file->content_length;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->current_include_dir = include_dir;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->current_rel_file = current_rel_file;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->current_rel_file_basic_type_name = basic_type_name;
lib/SPVM/Builder/src/spvm_toke.c:            compiler->current_file = current_file;
lib/SPVM/Builder/src/spvm_toke.c:            compiler->current_file = current_rel_file;
lib/SPVM/Builder/src/spvm_toke.c:          SPVM_STRING* current_file_string = SPVM_STRING_new(compiler, compiler->current_file, strlen(compiler->current_file));
lib/SPVM/Builder/src/spvm_toke.c:          compiler->current_file = current_file_string->value;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->ch_ptr = compiler->current_source;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->before_ch_ptr = compiler->current_source;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->line_begin_ptr = compiler->current_source;
lib/SPVM/Builder/src/spvm_toke.c:          compiler->current_line = 1;
lib/SPVM/Builder/src/spvm_toke.c:            SPVM_HASH_set(compiler->if_require_not_found_basic_type_name_symtable, basic_type_name, strlen(basic_type_name), (void*)basic_type_name);
lib/SPVM/Builder/src/spvm_toke.c:  SPVM_OP* op = SPVM_OP_new_op(compiler, type, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:  SPVM_OP* op = SPVM_OP_new_op(compiler, type, compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:        SPVM_COMPILER_error(compiler, "At least one octal number must be followed by \"\\o{\" of the octal escape character.\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:      SPVM_COMPILER_error(compiler, "\"\\o\" of the octal escape character must have its brace.\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:      SPVM_COMPILER_error(compiler, "The maxmum number of the octal escape charcater is 377.\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:      SPVM_COMPILER_error(compiler, "The octal escape character is not closed by \"}\".\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:    SPVM_COMPILER_error(compiler, "One or tow hexadecimal numbers must be followed by \"\\x\" of the hexadecimal escape character.\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_toke.c:      SPVM_COMPILER_error(compiler, "The hexadecimal escape character is not closed by \"}\".\n  at %s line %d", compiler->current_file, compiler->current_line);
lib/SPVM/Builder/src/spvm_check.c:    SPVM_DUMPER_dump_basic_types(compiler, compiler->basic_types);
lib/SPVM/Builder/src/spvm_check.c:  for (int32_t basic_type_id = compiler->basic_types_base_id; basic_type_id < compiler->basic_types->length; basic_type_id++) {
lib/SPVM/Builder/src/spvm_check.c:    SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_check.c:      SPVM_BASIC_TYPE* parent_basic_type = SPVM_HASH_get(compiler->basic_type_symtable, parent_basic_type_name, strlen(parent_basic_type_name));
lib/SPVM/Builder/src/spvm_check.c:      SPVM_BASIC_TYPE* interface_basic_type = SPVM_HASH_get(compiler->basic_type_symtable, interface_decl->op_type->uv.type->unresolved_basic_type_name, strlen(interface_decl->op_type->uv.type->unresolved_basic_type_name));
lib/SPVM/Builder/src/spvm_check.c:  for (int32_t basic_type_id = compiler->basic_types_base_id; basic_type_id < compiler->basic_types->length; basic_type_id++) {
lib/SPVM/Builder/src/spvm_check.c:    SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_check.c:  for (int32_t basic_type_id = compiler->basic_types_base_id; basic_type_id < compiler->basic_types->length; basic_type_id++) {
lib/SPVM/Builder/src/spvm_check.c:    SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_check.c:    SPVM_LIST* basic_type_merge_stack = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_check.c:    SPVM_LIST* merged_interfaces = SPVM_LIST_new_list_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_check.c:  for (int32_t basic_type_id = compiler->basic_types_base_id; basic_type_id < compiler->basic_types->length; basic_type_id++) {
lib/SPVM/Builder/src/spvm_check.c:    SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_check.c:  for (int32_t basic_type_id = compiler->basic_types_base_id; basic_type_id < compiler->basic_types->length; basic_type_id++) {
lib/SPVM/Builder/src/spvm_check.c:    SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_check.c:      char* tail_name = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, 255);
lib/SPVM/Builder/src/spvm_check.c:      SPVM_LIST* basic_type_merge_stack = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_check.c:      SPVM_LIST* merged_fields = SPVM_LIST_new_list_permanent(compiler->global_allocator, 0);
lib/SPVM/Builder/src/spvm_check.c:  for (int32_t basic_type_id = compiler->basic_types_base_id; basic_type_id < compiler->basic_types->length; basic_type_id++) {
lib/SPVM/Builder/src/spvm_check.c:    SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_check.c:        SPVM_BASIC_TYPE* use_basic_type = SPVM_HASH_get(compiler->basic_type_symtable, use_basic_type_name, strlen(use_basic_type_name));
lib/SPVM/Builder/src/spvm_check.c:        SPVM_BASIC_TYPE* anon_method_defined_basic_type = SPVM_HASH_get(compiler->basic_type_symtable, method->anon_method_defined_basic_type_name, strlen(method->anon_method_defined_basic_type_name));
lib/SPVM/Builder/src/spvm_check.c:  for (int32_t basic_type_id = compiler->basic_types_base_id; basic_type_id < compiler->basic_types->length; basic_type_id++) {
lib/SPVM/Builder/src/spvm_check.c:    SPVM_BASIC_TYPE* basic_type = SPVM_LIST_get(compiler->basic_types, basic_type_id);
lib/SPVM/Builder/src/spvm_check.c:    SPVM_BASIC_TYPE* found_basic_type = SPVM_HASH_get(compiler->basic_type_symtable, unresolved_basic_type_name, strlen(unresolved_basic_type_name));
lib/SPVM/Builder/src/spvm_check.c:    const char* if_require_not_found_basic_type_name = SPVM_HASH_get(compiler->if_require_not_found_basic_type_name_symtable, type->unresolved_basic_type_name, strlen(type->unresolved_basic_type_name));
lib/SPVM/Builder/src/spvm_check.c:  SPVM_LIST* op_types = compiler->op_types;
lib/SPVM/Builder/src/spvm_check.c:    basic_type_name = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, basic_type_name_length + 1);
lib/SPVM/Builder/src/spvm_check.c:    base_name = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, base_name_length + 1);
lib/SPVM/Builder/src/spvm_check.c:  SPVM_BASIC_TYPE* found_basic_type = SPVM_HASH_get(compiler->basic_type_symtable, basic_type_name, strlen(basic_type_name));
lib/SPVM/Builder/src/spvm_check.c:  SPVM_BASIC_TYPE* basic_type = SPVM_HASH_get(compiler->basic_type_symtable, invocant_type->basic_type->name, strlen(invocant_type->basic_type->name));
lib/SPVM/Builder/src/spvm_check.c:    SPVM_BASIC_TYPE* found_basic_type = SPVM_HASH_get(compiler->basic_type_symtable, basic_type_name, strlen(basic_type_name));
lib/SPVM/Builder/src/spvm_check.c:    SPVM_BASIC_TYPE* basic_type = SPVM_HASH_get(compiler->basic_type_symtable, basic_type_name, strlen(basic_type_name));
lib/SPVM/Builder/src/spvm_check.c:        SPVM_BASIC_TYPE* found_basic_type = SPVM_HASH_get(compiler->basic_type_symtable, abs_method_name, basic_type_name_length);
lib/SPVM/Builder/src/spvm_check.c:      SPVM_BASIC_TYPE* found_basic_type = SPVM_HASH_get(compiler->basic_type_symtable, use_basic_type_name, strlen(use_basic_type_name));
lib/SPVM/Builder/src/spvm_check.c:                op_type->uv.type->basic_type = SPVM_LIST_get(compiler->basic_types, 0);
lib/SPVM/Builder/src/spvm_check.c:  SPVM_LIST* var_decl_stack = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_PERMANENT);
lib/SPVM/Builder/src/spvm_check.c:  SPVM_LIST* var_decl_scope_base_stack = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_PERMANENT);
lib/SPVM/Builder/src/spvm_check.c:  SPVM_LIST* op_switch_stack = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_PERMANENT);
lib/SPVM/Builder/src/spvm_check.c:              SPVM_BASIC_TYPE* basic_type = SPVM_HASH_get(compiler->basic_type_symtable, type->basic_type->name, strlen(type->basic_type->name));
lib/SPVM/Builder/src/spvm_check.c:            SPVM_BASIC_TYPE* basic_type = SPVM_HASH_get(compiler->basic_type_symtable, basic_type_name, strlen(basic_type_name));
lib/SPVM/Builder/src/spvm_check.c:  SPVM_LIST* op_block_stack = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_check.c:  SPVM_LIST* tmp_var_decl_stack = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_check.c:  SPVM_LIST* call_stack_byte_vars = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_check.c:  SPVM_LIST* call_stack_short_vars = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_check.c:  SPVM_LIST* call_stack_int_vars = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_check.c:  SPVM_LIST* call_stack_long_vars = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_check.c:  SPVM_LIST* call_stack_float_vars = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_check.c:  SPVM_LIST* call_stack_double_vars = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_check.c:  SPVM_LIST* call_stack_object_vars = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_check.c:  SPVM_LIST* call_stack_ref_vars = SPVM_LIST_new(compiler->global_allocator, 0, SPVM_ALLOCATOR_C_ALLOC_TYPE_TMP);
lib/SPVM/Builder/src/spvm_check.c:  char* name = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, strlen("$.tmp_in_method2147483647") + 1);
lib/SPVM/Builder/src/spvm_check.c:  SPVM_LIST_push(compiler->op_types, op_type);
lib/SPVM/Builder/src/spvm_check.c:      SPVM_BASIC_TYPE* basic_type = SPVM_HASH_get(compiler->basic_type_symtable, first_type->basic_type->name, strlen(first_type->basic_type->name));
lib/SPVM/Builder/src/spvm_opcode.c:  SPVM_OPCODE* opcode = SPVM_ALLOCATOR_alloc_memory_block_permanent(compiler->global_allocator, sizeof(SPVM_OPCODE));
lib/SPVM/Builder.pm:  my $success = $compiler->compile($basic_type_name, __FILE__, __LINE__);
lib/SPVM/Builder.pm:    $compiler->print_error_messages(*STDERR);
lib/SPVM/Builder.pm:  my $runtime = $compiler->get_runtime;
lib/SPVM/Native/Compiler.pm:  $compiler->add_include_dir("lib");
lib/SPVM/Native/Compiler.pm:  $compiler->set_start_file(__FILE__);
lib/SPVM/Native/Compiler.pm:    $compiler->set_start_line(__LINE__ + 1);
lib/SPVM/Native/Compiler.pm:    my $success = $compiler->compile($basic_type_name);
lib/SPVM/Native/Compiler.pm:      my $error_messages = $compiler->get_error_messages;
lib/SPVM/Native/Compiler.pm:    $compiler->set_start_line(__LINE__ + 1);
lib/SPVM/Native/Compiler.pm:    my $success = $compiler->compile($basic_type_name);
lib/SPVM/Native/Compiler.pm:      my $error_messages = $compiler->get_error_messages;
lib/SPVM/Native/Compiler.pm:  my $runtime = $compiler->get_runtime;
lib/SPVM/Native/Runtime.pm:  my $runtime = $compiler->get_runtime;
lib/SPVM/Native/Env.c:    new_env->runtime = new_env->api->compiler->get_runtime(compiler);
lib/SPVM/Native/Compiler.c:  void* compiler = env->api->compiler->new_instance();
lib/SPVM/Native/Compiler.c:  env->api->compiler->free_instance(compiler);
lib/SPVM/Native/Compiler.c:  int32_t compile_die_error_id = env->api->compiler->compile(compiler, basic_type_name);
lib/SPVM/Native/Compiler.c:  void* runtime = env->api->compiler->get_runtime(compiler);
lib/SPVM/Native/Compiler.c:  env->api->compiler->set_start_file(compiler, start_file);
lib/SPVM/Native/Compiler.c:  env->api->compiler->set_start_line(compiler, start_line);
lib/SPVM/Native/Compiler.c:  int32_t error_messages_length = env->api->compiler->get_error_messages_length(compiler);
lib/SPVM/Native/Compiler.c:    const char* error_message = env->api->compiler->get_error_message(compiler, i);
lib/SPVM/Native/Compiler.c:  env->api->compiler->add_include_dir(compiler, include_dir);
lib/SPVM/Native/Compiler.c:  void* module_file = env->api->compiler->get_module_file(compiler, module_name);
lib/SPVM/Native/Compiler.c:  env->api->compiler->set_module_file(compiler, module_name, module_file);
lib/SPVM/Document/NativeAPI/Compiler.pm:  void* compiler = env->api->compiler->new_instance();
lib/SPVM/Document/NativeAPI/Compiler.pm:  env->api->compiler->add_include_dir(compiler, "lib");
lib/SPVM/Document/NativeAPI/Compiler.pm:  env->api->compiler->set_start_file(compiler, __FILE__);
lib/SPVM/Document/NativeAPI/Compiler.pm:  env->api->compiler->get_start_line(compiler, __LINE__ + 1);
lib/SPVM/Document/NativeAPI/Compiler.pm:  int32_t status = env->api->compiler->compile(compiler, "MyClass");
lib/SPVM/Document/NativeAPI/Compiler.pm:  env->api->compiler->free_instance(compiler);
lib/SPVM/Document/NativeModule.pm:  my @ccldflags = qw(--compiler-options '-fPIC');
