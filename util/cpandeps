#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use HTTP::Tiny;
use JSON::PP;
use Getopt::Long;
use Module::CoreList;

# Get options
my $verbose = 0;
my $run_cpanm = 0;
my $cpanm_opts = ''; # Default is empty
GetOptions(
    "v|verbose"    => \$verbose,
    "cpanm"        => \$run_cpanm,
    "cpanm-opts=s" => \$cpanm_opts,
);

my %visited;
my $json = JSON::PP->new->utf8;
my $http = HTTP::Tiny->new(timeout => 10);

sub get_dependencies_recursive {
  my ($name, $level) = @_;
  $level //= 0;

  # Skip if already visited
  return if $visited{$name}++;

  # Skip if the module is part of Perl core in the current version
  return if Module::CoreList::is_core($name, undef, $]);

  my $indent = "  " x $level;

  # Access via HTTP to avoid SSL issues
  my $url = "http://fastapi.metacpan.org/v1/module/$name";
  my $res = $http->get($url);

  unless ($res->{success}) {
    fetch_from_release($name, $name, $level);
    return;
  }

  my $mod_data = eval { $json->decode($res->{content}) };
  return if $@ || !$mod_data;

  my $dist = $mod_data->{distribution};
  fetch_from_release($name, $dist, $level);
}

sub fetch_from_release {
  my ($mod_name, $dist, $level) = @_;
  my $indent = "  " x $level;

  my $url = "http://fastapi.metacpan.org/v1/release/$dist";
  my $res = $http->get($url);
  return unless $res->{success};

  my $rel_data = eval { $json->decode($res->{content}) };
  return if $@ || !$rel_data;

  if ($verbose) {
    print STDERR "${indent}- $mod_name (Dist: $dist)\n";
  }

  my $deps = $rel_data->{dependency} || [];
  foreach my $dep (@$deps) {
    if ($dep->{phase} eq 'runtime' && $dep->{relationship} eq 'requires') {
      my $next_mod = $dep->{module};
      next if !$next_mod || $next_mod eq 'perl';
      get_dependencies_recursive($next_mod, $level + 1);
    }
  }
}

my $target = shift or die "Usage: $0 [-v] [--cpanm] [--cpanm-opts '--reinstall'] Module::Name\n";

print STDERR "--- Analyzing dependencies for $target ---\n" if $verbose;
get_dependencies_recursive($target);
print STDERR "--- Done ---\n" if $verbose;

# Collect final list
my @final_deps;
foreach my $mod (sort keys %visited) {
  next if $mod eq $target;
  next if Module::CoreList::is_core($mod, undef, $]);
  push @final_deps, $mod;
}

if ($run_cpanm) {
  my @opts = split(' ', $cpanm_opts);
  if (@final_deps) {
    my @cmd = ('cpanm', @opts, @final_deps, $target);
    print STDERR "Executing: @cmd\n" if $verbose;
    system(@cmd) == 0 or die "cpanm failed: $!";
  } else {
    system('cpanm', @opts, $target) == 0 or die "cpanm failed: $!";
  }
} else {
  foreach my $mod (@final_deps) {
    print "$mod\n";
  }
}

=head1 NAME

cpandeps - A tool to list or install non-core CPAN dependencies recursively.

=head1 Usage

  Usage: cpandeps [OPTIONS] Module::Name

    cpandeps SPVM::JSON

    cpandeps --cpanm SPVM::JSON

    cpandeps --cpanm --cpanm-opts "--reinstall" SPVM::JSON

  Options:
    -h, --help                      Shows this message
    -v, --verbose                   Shows recursive dependency tree to STDERR
    --cpanm                         Executes cpanm to install the modules
    --cpanm-opts OPTS               Specifies cpanm options (e.g., "--reinstall")

=cut

=cut

=head1 OPTIONS

=over 4

=item B<-v, --verbose>

Show recursive dependency tree to STDERR.

=item B<--cpanm>

Execute cpanm to install the modules.

=item B<--cpanm-opts>

Specify cpanm options (e.g., '--reinstall').

=back

=cut
